<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>osgEarth: /home/cube/sources/osgearth/src/osgEarthUtil/EarthManipulator.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">osgEarth</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('_earth_manipulator_8cpp.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<h1>/home/cube/sources/osgearth/src/osgEarthUtil/EarthManipulator.cpp</h1>  </div>
</div>
<div class="contents">
<a href="_earth_manipulator_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* -*-c++-*- */</span>
<a name="l00002"></a>00002 <span class="comment">/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph</span>
<a name="l00003"></a>00003 <span class="comment"> * Copyright 2008-2010 Pelican Mapping</span>
<a name="l00004"></a>00004 <span class="comment"> * http://osgearth.org</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * osgEarth is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment"> * it under the terms of the GNU Lesser General Public License as published by</span>
<a name="l00008"></a>00008 <span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00009"></a>00009 <span class="comment"> * (at your option) any later version.</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
<a name="l00012"></a>00012 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00013"></a>00013 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00014"></a>00014 <span class="comment"> * GNU Lesser General Public License for more details.</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * You should have received a copy of the GNU Lesser General Public License</span>
<a name="l00017"></a>00017 <span class="comment"> * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;</span>
<a name="l00018"></a>00018 <span class="comment"> */</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;osgEarthUtil/EarthManipulator&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;osgEarth/FindNode&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;osg/Quat&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;osg/Notify&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;osg/MatrixTransform&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;osgUtil/LineSegmentIntersector&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;osgViewer/View&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;osg/io_utils&gt;</span>
<a name="l00029"></a>00029 
<a name="l00030"></a><a class="code" href="_earth_manipulator_8cpp.html#aa499bb75bb504909cd0a72baf48c4653">00030</a> <span class="preprocessor">#define LC &quot;[EarthManip] &quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span>
<a name="l00032"></a>00032 <span class="keyword">using namespace </span>osgEarth::Util;
<a name="l00033"></a>00033 <span class="keyword">using namespace </span>osgEarth;
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="comment">/****************************************************************************/</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="keyword">namespace</span>
<a name="l00039"></a>00039 {
<a name="l00040"></a>00040     <span class="comment">// a reasonable approximation of cosine interpolation</span>
<a name="l00041"></a>00041     <span class="keywordtype">double</span>
<a name="l00042"></a>00042     smoothStepInterp( <span class="keywordtype">double</span> t ) {
<a name="l00043"></a>00043         <span class="keywordflow">return</span> (t*t)*(3.0-2.0*t);
<a name="l00044"></a>00044     }
<a name="l00045"></a>00045 
<a name="l00046"></a>00046     <span class="comment">// rough approximation of pow(x,y)</span>
<a name="l00047"></a>00047     <span class="keywordtype">double</span>
<a name="l00048"></a>00048     powFast( <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y ) {
<a name="l00049"></a>00049         <span class="keywordflow">return</span> x/(x+y-y*x);
<a name="l00050"></a>00050     }
<a name="l00051"></a>00051 
<a name="l00052"></a>00052     <span class="comment">// accel/decel curve (a &lt; 0 =&gt; decel)</span>
<a name="l00053"></a>00053     <span class="keywordtype">double</span>
<a name="l00054"></a>00054     accelerationInterp( <span class="keywordtype">double</span> t, <span class="keywordtype">double</span> a ) {
<a name="l00055"></a>00055         <span class="keywordflow">return</span> a == 0.0? t : a &gt; 0.0? powFast( t, a ) : 1.0 - powFast(1.0-t, -a);
<a name="l00056"></a>00056     }
<a name="l00057"></a>00057     
<a name="l00058"></a>00058     <span class="keywordtype">void</span>
<a name="l00059"></a>00059     s_getHPRFromQuat(<span class="keyword">const</span> osg::Quat&amp; q, <span class="keywordtype">double</span> &amp;h, <span class="keywordtype">double</span> &amp;p, <span class="keywordtype">double</span> &amp;r)
<a name="l00060"></a>00060     {
<a name="l00061"></a>00061 <span class="preprocessor">#if 0</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span>        <span class="comment">// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToEuler/index.htm</span>
<a name="l00063"></a>00063 
<a name="l00064"></a>00064         p = atan2(2*(q.y()*q.z() + q.w()*q.x()), (q.w()*q.w() - q.x()*q.x() - q.y()*q.y() + q.z() * q.z()));
<a name="l00065"></a>00065             h = asin (2*q.x()*q.y() + 2*q.z()*q.w());
<a name="l00066"></a>00066         r = atan2(2*q.x()*q.w()-2*q.y()*q.z() , 1 - 2*q.x()*q.x() - 2*q.z()*q.z());
<a name="l00067"></a>00067         
<a name="l00068"></a>00068         <span class="keywordflow">if</span>( osg::equivalent( q.x()*q.y() + q.z() *q.w(), 0.5 ) )
<a name="l00069"></a>00069             { 
<a name="l00070"></a>00070                     p = (float)(2 * atan2( q.x(),q.w())); 
<a name="l00071"></a>00071                     r = 0;     
<a name="l00072"></a>00072             }    
<a name="l00073"></a>00073         <span class="keywordflow">else</span> <span class="keywordflow">if</span>( osg::equivalent( q.x()*q.y() + q.z()*q.w(), -0.5 ) )
<a name="l00074"></a>00074             { 
<a name="l00075"></a>00075                     p = (float)(-2 * atan2(q.x(), q.w())); 
<a name="l00076"></a>00076                     r = 0; 
<a name="l00077"></a>00077             } 
<a name="l00078"></a>00078      
<a name="l00079"></a>00079 <span class="preprocessor">#else</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span>        osg::Matrixd rot(q);
<a name="l00081"></a>00081         p = asin(rot(1,2));
<a name="l00082"></a>00082         <span class="keywordflow">if</span>( osg::equivalent(osg::absolute(p), osg::PI_2) )
<a name="l00083"></a>00083         {
<a name="l00084"></a>00084             r = 0.0;
<a name="l00085"></a>00085             h = atan2( rot(0,1), rot(0,0) );
<a name="l00086"></a>00086         }
<a name="l00087"></a>00087         <span class="keywordflow">else</span>
<a name="l00088"></a>00088         {
<a name="l00089"></a>00089             r = atan2( rot(0,2), rot(2,2) );
<a name="l00090"></a>00090             h = atan2( rot(1,0), rot(1,1) );
<a name="l00091"></a>00091         }
<a name="l00092"></a>00092 <span class="preprocessor">#endif</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span>    }
<a name="l00094"></a>00094 }
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="comment">/****************************************************************************/</span>
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 EarthManipulator::Action::Action( ActionType type, <span class="keyword">const</span> ActionOptions&amp; options ) :
<a name="l00100"></a>00100 _type( type ),
<a name="l00101"></a>00101 _options( options )
<a name="l00102"></a>00102 { 
<a name="l00103"></a>00103     init();
<a name="l00104"></a>00104 }
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 EarthManipulator::Action::Action( ActionType type ) :
<a name="l00107"></a>00107 _type( type )
<a name="l00108"></a>00108 {
<a name="l00109"></a>00109     init();
<a name="l00110"></a>00110 }
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="keywordtype">void</span>
<a name="l00113"></a>00113 EarthManipulator::Action::init()
<a name="l00114"></a>00114 {
<a name="l00115"></a>00115     _dir =
<a name="l00116"></a>00116         _type == ACTION_PAN_LEFT  || _type == ACTION_ROTATE_LEFT? DIR_LEFT :
<a name="l00117"></a>00117         _type == ACTION_PAN_RIGHT || _type == ACTION_ROTATE_RIGHT? DIR_RIGHT :
<a name="l00118"></a>00118         _type == ACTION_PAN_UP    || _type == ACTION_ROTATE_UP   || _type == ACTION_ZOOM_IN ? DIR_UP :
<a name="l00119"></a>00119         _type == ACTION_PAN_DOWN  || _type == ACTION_ROTATE_DOWN || _type == ACTION_ZOOM_OUT ? DIR_DOWN :
<a name="l00120"></a>00120         DIR_NA;
<a name="l00121"></a>00121 }
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 EarthManipulator::Action::Action( <span class="keyword">const</span> Action&amp; rhs ) :
<a name="l00124"></a>00124 _type( rhs._type ),
<a name="l00125"></a>00125 _dir( rhs._dir ),
<a name="l00126"></a>00126 _options( rhs._options )
<a name="l00127"></a>00127 {
<a name="l00128"></a>00128     <span class="comment">//nop</span>
<a name="l00129"></a>00129 }
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="keywordtype">bool</span> 
<a name="l00132"></a>00132 EarthManipulator::Action::getBoolOption( <span class="keywordtype">int</span> option, <span class="keywordtype">bool</span> defaultValue )<span class="keyword"> const</span>
<a name="l00133"></a>00133 <span class="keyword"></span>{
<a name="l00134"></a>00134     <span class="keywordflow">for</span>(ActionOptions::const_iterator i = _options.begin(); i != _options.end(); i++ ) {
<a name="l00135"></a>00135         <span class="keywordflow">if</span> ( i-&gt;option() == option )
<a name="l00136"></a>00136             <span class="keywordflow">return</span> i-&gt;boolValue();
<a name="l00137"></a>00137     }
<a name="l00138"></a>00138     <span class="keywordflow">return</span> defaultValue;
<a name="l00139"></a>00139 }
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 <span class="keywordtype">int</span> 
<a name="l00142"></a>00142 EarthManipulator::Action::getIntOption( <span class="keywordtype">int</span> option, <span class="keywordtype">int</span> defaultValue )<span class="keyword"> const</span>
<a name="l00143"></a>00143 <span class="keyword"></span>{
<a name="l00144"></a>00144     <span class="keywordflow">for</span>(ActionOptions::const_iterator i = _options.begin(); i != _options.end(); i++ ) {
<a name="l00145"></a>00145         <span class="keywordflow">if</span> ( i-&gt;option() == option )
<a name="l00146"></a>00146             <span class="keywordflow">return</span> i-&gt;intValue();
<a name="l00147"></a>00147     }
<a name="l00148"></a>00148     <span class="keywordflow">return</span> defaultValue;
<a name="l00149"></a>00149 }
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 <span class="keywordtype">double</span> 
<a name="l00152"></a>00152 EarthManipulator::Action::getDoubleOption( <span class="keywordtype">int</span> option, <span class="keywordtype">double</span> defaultValue )<span class="keyword"> const</span>
<a name="l00153"></a>00153 <span class="keyword"></span>{
<a name="l00154"></a>00154     <span class="keywordflow">for</span>(ActionOptions::const_iterator i = _options.begin(); i != _options.end(); i++ ) {
<a name="l00155"></a>00155         <span class="keywordflow">if</span> ( i-&gt;option() == option )
<a name="l00156"></a>00156             <span class="keywordflow">return</span> i-&gt;doubleValue();
<a name="l00157"></a>00157     }
<a name="l00158"></a>00158     <span class="keywordflow">return</span> defaultValue;
<a name="l00159"></a>00159 }
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="comment">/****************************************************************************/</span>
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 EarthManipulator::Action EarthManipulator::NullAction( EarthManipulator::ACTION_NULL );
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 <span class="keyword">static</span> std::string s_actionNames[] = {
<a name="l00166"></a>00166     <span class="stringliteral">&quot;null&quot;</span>,
<a name="l00167"></a>00167     <span class="stringliteral">&quot;home&quot;</span>,
<a name="l00168"></a>00168     <span class="stringliteral">&quot;goto&quot;</span>,
<a name="l00169"></a>00169     <span class="stringliteral">&quot;pan&quot;</span>,
<a name="l00170"></a>00170     <span class="stringliteral">&quot;pan-left&quot;</span>,
<a name="l00171"></a>00171     <span class="stringliteral">&quot;pan-right&quot;</span>,
<a name="l00172"></a>00172     <span class="stringliteral">&quot;pan-up&quot;</span>,
<a name="l00173"></a>00173     <span class="stringliteral">&quot;pan-down&quot;</span>,
<a name="l00174"></a>00174     <span class="stringliteral">&quot;rotate&quot;</span>,
<a name="l00175"></a>00175     <span class="stringliteral">&quot;rotate-left&quot;</span>,
<a name="l00176"></a>00176     <span class="stringliteral">&quot;rotate-right&quot;</span>,
<a name="l00177"></a>00177     <span class="stringliteral">&quot;rotate-up&quot;</span>,
<a name="l00178"></a>00178     <span class="stringliteral">&quot;rotate-down&quot;</span>,
<a name="l00179"></a>00179     <span class="stringliteral">&quot;zoom&quot;</span>,
<a name="l00180"></a>00180     <span class="stringliteral">&quot;zoom-in&quot;</span>,
<a name="l00181"></a>00181     <span class="stringliteral">&quot;zoom-out&quot;</span>,
<a name="l00182"></a>00182     <span class="stringliteral">&quot;earth-drag&quot;</span>
<a name="l00183"></a>00183 };
<a name="l00184"></a>00184 
<a name="l00185"></a>00185 <span class="keyword">static</span> std::string s_actionOptionNames[] = {
<a name="l00186"></a>00186     <span class="stringliteral">&quot;scale-x&quot;</span>,
<a name="l00187"></a>00187     <span class="stringliteral">&quot;scale-y&quot;</span>,
<a name="l00188"></a>00188     <span class="stringliteral">&quot;continuous&quot;</span>,
<a name="l00189"></a>00189     <span class="stringliteral">&quot;single-axis&quot;</span>,
<a name="l00190"></a>00190     <span class="stringliteral">&quot;goto-range-factor&quot;</span>,
<a name="l00191"></a>00191     <span class="stringliteral">&quot;duration&quot;</span>
<a name="l00192"></a>00192 };
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 <span class="keyword">static</span> <span class="keywordtype">short</span> s_actionOptionTypes[] = { 1, 1, 0, 0, 1, 1 }; <span class="comment">// 0=bool, 1=double</span>
<a name="l00195"></a>00195 
<a name="l00196"></a>00196 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 EarthManipulator::Settings::Settings() :
<a name="l00199"></a>00199 _single_axis_rotation( false ),
<a name="l00200"></a>00200 _throwing( false ),
<a name="l00201"></a>00201 _lock_azim_while_panning( true ),
<a name="l00202"></a>00202 _mouse_sens( 1.0 ),
<a name="l00203"></a>00203 _keyboard_sens( 1.0 ),
<a name="l00204"></a>00204 _scroll_sens( 1.0 ),
<a name="l00205"></a>00205 _min_pitch( -89.9 ),
<a name="l00206"></a>00206 _max_pitch( -10.0 ),
<a name="l00207"></a>00207 _max_x_offset( 0.0 ),
<a name="l00208"></a>00208 _max_y_offset( 0.0 ),
<a name="l00209"></a>00209 _min_distance( 0.001 ),
<a name="l00210"></a>00210 _max_distance( DBL_MAX ),
<a name="l00211"></a>00211 _tether_mode( TETHER_CENTER ),
<a name="l00212"></a>00212 _arc_viewpoints( false ),
<a name="l00213"></a>00213 _auto_vp_duration( false ),
<a name="l00214"></a>00214 _min_vp_duration_s( 3.0 ),
<a name="l00215"></a>00215 _max_vp_duration_s( 8.0 )
<a name="l00216"></a>00216 {
<a name="l00217"></a>00217     <span class="comment">//NOP</span>
<a name="l00218"></a>00218 }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220 EarthManipulator::Settings::Settings( <span class="keyword">const</span> EarthManipulator::Settings&amp; rhs ) :
<a name="l00221"></a>00221 _bindings( rhs._bindings ),
<a name="l00222"></a>00222 _single_axis_rotation( rhs._single_axis_rotation ),
<a name="l00223"></a>00223 _throwing( rhs._throwing ),
<a name="l00224"></a>00224 _lock_azim_while_panning( rhs._lock_azim_while_panning ),
<a name="l00225"></a>00225 _mouse_sens( rhs._mouse_sens ),
<a name="l00226"></a>00226 _keyboard_sens( rhs._keyboard_sens ),
<a name="l00227"></a>00227 _scroll_sens( rhs._scroll_sens ),
<a name="l00228"></a>00228 _min_pitch( rhs._min_pitch ),
<a name="l00229"></a>00229 _max_pitch( rhs._max_pitch ),
<a name="l00230"></a>00230 _max_x_offset( rhs._max_x_offset ),
<a name="l00231"></a>00231 _max_y_offset( rhs._max_y_offset ),
<a name="l00232"></a>00232 _min_distance( rhs._min_distance ),
<a name="l00233"></a>00233 _max_distance( rhs._max_distance ),
<a name="l00234"></a>00234 _tether_mode( rhs._tether_mode ),
<a name="l00235"></a>00235 _arc_viewpoints( rhs._arc_viewpoints ),
<a name="l00236"></a>00236 _auto_vp_duration( rhs._auto_vp_duration ),
<a name="l00237"></a>00237 _min_vp_duration_s( rhs._min_vp_duration_s ),
<a name="l00238"></a>00238 _max_vp_duration_s( rhs._max_vp_duration_s )
<a name="l00239"></a>00239 {
<a name="l00240"></a>00240     <span class="comment">//NOP</span>
<a name="l00241"></a>00241 }
<a name="l00242"></a>00242 
<a name="l00243"></a><a class="code" href="_earth_manipulator_8cpp.html#aec30b60c26a90cca8132688bcf2073c1">00243</a> <span class="preprocessor">#define HASMODKEY( W, V ) (( W &amp; V ) == V )</span>
<a name="l00244"></a>00244 <span class="preprocessor"></span>
<a name="l00245"></a>00245 <span class="comment">// expands one input spec into many if necessary, to deal with modifier key combos.</span>
<a name="l00246"></a>00246 <span class="keywordtype">void</span>
<a name="l00247"></a>00247 EarthManipulator::Settings::expandSpec( <span class="keyword">const</span> InputSpec&amp; input, InputSpecs&amp; output )<span class="keyword"> const</span>
<a name="l00248"></a>00248 <span class="keyword"></span>{
<a name="l00249"></a>00249     <span class="keywordtype">int</span> e = input._event_type;
<a name="l00250"></a>00250     <span class="keywordtype">int</span> i = input._input_mask;
<a name="l00251"></a>00251     <span class="keywordtype">int</span> m = input._modkey_mask;
<a name="l00252"></a>00252 
<a name="l00253"></a>00253     <span class="keywordflow">if</span> ( <a class="code" href="_earth_manipulator_8cpp.html#aec30b60c26a90cca8132688bcf2073c1">HASMODKEY</a>(m, osgGA::GUIEventAdapter::MODKEY_CTRL) )
<a name="l00254"></a>00254     {
<a name="l00255"></a>00255         expandSpec( InputSpec( e, i, m &amp; ~osgGA::GUIEventAdapter::MODKEY_LEFT_CTRL ), output );
<a name="l00256"></a>00256         expandSpec( InputSpec( e, i, m &amp; ~osgGA::GUIEventAdapter::MODKEY_RIGHT_CTRL ), output );
<a name="l00257"></a>00257     }
<a name="l00258"></a>00258     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="_earth_manipulator_8cpp.html#aec30b60c26a90cca8132688bcf2073c1">HASMODKEY</a>(m, osgGA::GUIEventAdapter::MODKEY_ALT) )
<a name="l00259"></a>00259     {
<a name="l00260"></a>00260         expandSpec( InputSpec( e, i, m &amp; ~osgGA::GUIEventAdapter::MODKEY_LEFT_ALT ), output );
<a name="l00261"></a>00261         expandSpec( InputSpec( e, i, m &amp; ~osgGA::GUIEventAdapter::MODKEY_RIGHT_ALT ), output );
<a name="l00262"></a>00262     }
<a name="l00263"></a>00263     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="_earth_manipulator_8cpp.html#aec30b60c26a90cca8132688bcf2073c1">HASMODKEY</a>(m, osgGA::GUIEventAdapter::MODKEY_SHIFT) )
<a name="l00264"></a>00264     {
<a name="l00265"></a>00265         expandSpec( InputSpec( e, i, m &amp; ~osgGA::GUIEventAdapter::MODKEY_LEFT_SHIFT ), output );
<a name="l00266"></a>00266         expandSpec( InputSpec( e, i, m &amp; ~osgGA::GUIEventAdapter::MODKEY_RIGHT_SHIFT ), output );
<a name="l00267"></a>00267     }
<a name="l00268"></a>00268     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="_earth_manipulator_8cpp.html#aec30b60c26a90cca8132688bcf2073c1">HASMODKEY</a>(m, osgGA::GUIEventAdapter::MODKEY_META) )
<a name="l00269"></a>00269     {
<a name="l00270"></a>00270         expandSpec( InputSpec( e, i, m &amp; ~osgGA::GUIEventAdapter::MODKEY_LEFT_META ), output );
<a name="l00271"></a>00271         expandSpec( InputSpec( e, i, m &amp; ~osgGA::GUIEventAdapter::MODKEY_RIGHT_META ), output );
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="_earth_manipulator_8cpp.html#aec30b60c26a90cca8132688bcf2073c1">HASMODKEY</a>(m, osgGA::GUIEventAdapter::MODKEY_HYPER) )
<a name="l00274"></a>00274     {
<a name="l00275"></a>00275         expandSpec( InputSpec( e, i, m &amp; ~osgGA::GUIEventAdapter::MODKEY_LEFT_HYPER ), output );
<a name="l00276"></a>00276         expandSpec( InputSpec( e, i, m &amp; ~osgGA::GUIEventAdapter::MODKEY_RIGHT_HYPER ), output );
<a name="l00277"></a>00277     }
<a name="l00278"></a>00278 
<a name="l00279"></a>00279     <span class="comment">//Always add the input so if we are dealing with a windowing system like QT that just sends MODKEY_CTRL it will still work.</span>
<a name="l00280"></a>00280     output.push_back( input );
<a name="l00281"></a>00281 }
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 <span class="keywordtype">void</span>
<a name="l00284"></a>00284 EarthManipulator::Settings::bind( <span class="keyword">const</span> InputSpec&amp; spec, <span class="keyword">const</span> Action&amp; action )
<a name="l00285"></a>00285 {
<a name="l00286"></a>00286     InputSpecs specs;
<a name="l00287"></a>00287     expandSpec( spec, specs );
<a name="l00288"></a>00288     <span class="keywordflow">for</span>( InputSpecs::const_iterator i = specs.begin(); i != specs.end(); i++ )
<a name="l00289"></a>00289     {
<a name="l00290"></a>00290         _bindings[*i] = action; <span class="comment">//ActionBinding(*i, action);</span>
<a name="l00291"></a>00291     }
<a name="l00292"></a>00292         <span class="comment">//_bindings.push_back( ActionBinding( *i, action ) );</span>
<a name="l00293"></a>00293 }
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 <span class="keywordtype">void</span>
<a name="l00296"></a>00296 EarthManipulator::Settings::bindMouse(ActionType actionType,
<a name="l00297"></a>00297                                       <span class="keywordtype">int</span> button_mask, <span class="keywordtype">int</span> modkey_mask,
<a name="l00298"></a>00298                                       <span class="keyword">const</span> ActionOptions&amp; options)
<a name="l00299"></a>00299 {
<a name="l00300"></a>00300     bind(
<a name="l00301"></a>00301         InputSpec( osgGA::GUIEventAdapter::DRAG, button_mask, modkey_mask ),
<a name="l00302"></a>00302         Action( actionType, options ) );
<a name="l00303"></a>00303 }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305 <span class="keywordtype">void</span>
<a name="l00306"></a>00306 EarthManipulator::Settings::bindMouseClick(ActionType action,
<a name="l00307"></a>00307                                            <span class="keywordtype">int</span> button_mask, <span class="keywordtype">int</span> modkey_mask,
<a name="l00308"></a>00308                                            <span class="keyword">const</span> ActionOptions&amp; options)
<a name="l00309"></a>00309 {
<a name="l00310"></a>00310     bind(
<a name="l00311"></a>00311         InputSpec( EVENT_MOUSE_CLICK, button_mask, modkey_mask ),
<a name="l00312"></a>00312         Action( action, options ) );
<a name="l00313"></a>00313 }
<a name="l00314"></a>00314 
<a name="l00315"></a>00315 <span class="keywordtype">void</span>
<a name="l00316"></a>00316 EarthManipulator::Settings::bindMouseDoubleClick(ActionType action,
<a name="l00317"></a>00317                                                  <span class="keywordtype">int</span> button_mask, <span class="keywordtype">int</span> modkey_mask,
<a name="l00318"></a>00318                                                  <span class="keyword">const</span> ActionOptions&amp; options)
<a name="l00319"></a>00319 {
<a name="l00320"></a>00320     bind(
<a name="l00321"></a>00321         InputSpec( EVENT_MOUSE_DOUBLE_CLICK, button_mask, modkey_mask ),
<a name="l00322"></a>00322         Action( action, options ) );
<a name="l00323"></a>00323 }
<a name="l00324"></a>00324 
<a name="l00325"></a>00325 <span class="keywordtype">void</span>
<a name="l00326"></a>00326 EarthManipulator::Settings::bindKey(ActionType action,
<a name="l00327"></a>00327                                     <span class="keywordtype">int</span> key, <span class="keywordtype">int</span> modkey_mask,
<a name="l00328"></a>00328                                     <span class="keyword">const</span> ActionOptions&amp; options)
<a name="l00329"></a>00329 {
<a name="l00330"></a>00330     bind(
<a name="l00331"></a>00331         InputSpec( osgGA::GUIEventAdapter::KEYDOWN, key, modkey_mask ),
<a name="l00332"></a>00332         Action( action, options ) );
<a name="l00333"></a>00333 }
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 <span class="keywordtype">void</span>
<a name="l00336"></a>00336 EarthManipulator::Settings::bindScroll(ActionType action, <span class="keywordtype">int</span> scrolling_motion,
<a name="l00337"></a>00337                                        <span class="keywordtype">int</span> modkey_mask, <span class="keyword">const</span> ActionOptions&amp; options )
<a name="l00338"></a>00338 {
<a name="l00339"></a>00339     bind(
<a name="l00340"></a>00340         InputSpec ( osgGA::GUIEventAdapter::SCROLL, scrolling_motion, modkey_mask ),
<a name="l00341"></a>00341         Action( action, options ) );
<a name="l00342"></a>00342 }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 <span class="keyword">const</span> EarthManipulator::Action&amp;
<a name="l00345"></a>00345 EarthManipulator::Settings::getAction(<span class="keywordtype">int</span> event_type, <span class="keywordtype">int</span> input_mask, <span class="keywordtype">int</span> modkey_mask)<span class="keyword"> const</span>
<a name="l00346"></a>00346 <span class="keyword"></span>{
<a name="l00347"></a>00347     InputSpec spec( event_type, input_mask, modkey_mask );
<a name="l00348"></a>00348     ActionBindings::const_iterator i = _bindings.find(spec);
<a name="l00349"></a>00349     <span class="keywordflow">return</span> i != _bindings.end() ? i-&gt;second : NullAction;
<a name="l00350"></a>00350     <span class="comment">//for( ActionBindings::const_iterator i = _bindings.begin(); i != _bindings.end(); i++ )</span>
<a name="l00351"></a>00351     <span class="comment">//    if ( i-&gt;first == spec )</span>
<a name="l00352"></a>00352     <span class="comment">//        return i-&gt;second;</span>
<a name="l00353"></a>00353     <span class="comment">//return NullAction;</span>
<a name="l00354"></a>00354 }
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 <span class="keywordtype">void</span>
<a name="l00357"></a>00357 EarthManipulator::Settings::setMinMaxPitch( <span class="keywordtype">double</span> min_pitch, <span class="keywordtype">double</span> max_pitch )
<a name="l00358"></a>00358 {
<a name="l00359"></a>00359     _min_pitch = osg::clampBetween( min_pitch, -89.9, 89.0 );
<a name="l00360"></a>00360     _max_pitch = osg::clampBetween( max_pitch, min_pitch, 89.0 );
<a name="l00361"></a>00361 }
<a name="l00362"></a>00362 
<a name="l00363"></a>00363 <span class="keywordtype">void</span>
<a name="l00364"></a>00364 EarthManipulator::Settings::setMaxOffset(<span class="keywordtype">double</span> max_x_offset, <span class="keywordtype">double</span> max_y_offset)
<a name="l00365"></a>00365 {
<a name="l00366"></a>00366         _max_x_offset = max_x_offset;
<a name="l00367"></a>00367         _max_y_offset = max_y_offset;
<a name="l00368"></a>00368 }
<a name="l00369"></a>00369 
<a name="l00370"></a>00370 <span class="keywordtype">void</span>
<a name="l00371"></a>00371 EarthManipulator::Settings::setMinMaxDistance( <span class="keywordtype">double</span> min_distance, <span class="keywordtype">double</span> max_distance)
<a name="l00372"></a>00372 {
<a name="l00373"></a>00373         _min_distance = min_distance;
<a name="l00374"></a>00374         _max_distance = max_distance;
<a name="l00375"></a>00375 }
<a name="l00376"></a>00376 
<a name="l00377"></a>00377 <span class="keywordtype">void</span>
<a name="l00378"></a>00378 EarthManipulator::Settings::setArcViewpointTransitions( <span class="keywordtype">bool</span> value )
<a name="l00379"></a>00379 {
<a name="l00380"></a>00380     _arc_viewpoints = value;
<a name="l00381"></a>00381 }
<a name="l00382"></a>00382 
<a name="l00383"></a>00383 <span class="keywordtype">void</span>
<a name="l00384"></a>00384 EarthManipulator::Settings::setAutoViewpointDurationEnabled( <span class="keywordtype">bool</span> value )
<a name="l00385"></a>00385 {
<a name="l00386"></a>00386     _auto_vp_duration = value;
<a name="l00387"></a>00387 }
<a name="l00388"></a>00388 
<a name="l00389"></a>00389 <span class="keywordtype">void</span>
<a name="l00390"></a>00390 EarthManipulator::Settings::setAutoViewpointDurationLimits( <span class="keywordtype">double</span> minSeconds, <span class="keywordtype">double</span> maxSeconds )
<a name="l00391"></a>00391 {
<a name="l00392"></a>00392     _min_vp_duration_s = osg::clampAbove( minSeconds, 0.0 );
<a name="l00393"></a>00393     _max_vp_duration_s = osg::clampAbove( maxSeconds, _min_vp_duration_s );
<a name="l00394"></a>00394 }
<a name="l00395"></a>00395 
<a name="l00396"></a>00396 <span class="comment">/************************************************************************/</span>
<a name="l00397"></a>00397 
<a name="l00398"></a>00398 
<a name="l00399"></a>00399 EarthManipulator::EarthManipulator() :
<a name="l00400"></a>00400 _last_action( ACTION_NULL )
<a name="l00401"></a>00401 {
<a name="l00402"></a>00402     reinitialize();
<a name="l00403"></a>00403     configureDefaultSettings();
<a name="l00404"></a>00404 }
<a name="l00405"></a>00405 
<a name="l00406"></a>00406 EarthManipulator::EarthManipulator( <span class="keyword">const</span> EarthManipulator&amp; rhs ) :
<a name="l00407"></a>00407 _thrown( rhs._thrown ),
<a name="l00408"></a>00408 _distance( rhs._distance ),
<a name="l00409"></a>00409 _offset_x( rhs._offset_x ),
<a name="l00410"></a>00410 _offset_y( rhs._offset_y ),
<a name="l00411"></a>00411 _continuous( rhs._continuous ),
<a name="l00412"></a>00412 _task( new Task() ),
<a name="l00413"></a>00413 _settings( new Settings( *rhs._settings.get() ) ),
<a name="l00414"></a>00414 _srs_lookup_failed( rhs._srs_lookup_failed ),
<a name="l00415"></a>00415 _last_action( rhs._last_action ),
<a name="l00416"></a>00416 _setting_viewpoint( rhs._setting_viewpoint ),
<a name="l00417"></a>00417 _delta_t( rhs._delta_t ),
<a name="l00418"></a>00418 _t_factor( rhs._t_factor ),
<a name="l00419"></a>00419 _time_s_last_frame( rhs._time_s_last_frame  ),
<a name="l00420"></a>00420 _local_azim( rhs._local_azim ),
<a name="l00421"></a>00421 _local_pitch( rhs._local_pitch  ),
<a name="l00422"></a>00422 _has_pending_viewpoint( rhs._has_pending_viewpoint ),
<a name="l00423"></a>00423 _homeViewpoint( rhs._homeViewpoint.get() ),
<a name="l00424"></a>00424 _homeViewpointDuration( rhs._homeViewpointDuration ),
<a name="l00425"></a>00425 _after_first_frame( rhs._after_first_frame ),
<a name="l00426"></a>00426 _lastPointOnEarth( rhs._lastPointOnEarth ),
<a name="l00427"></a>00427 _arc_height( rhs._arc_height )
<a name="l00428"></a>00428 {
<a name="l00429"></a>00429 }
<a name="l00430"></a>00430 
<a name="l00431"></a>00431 
<a name="l00432"></a>00432 EarthManipulator::~EarthManipulator()
<a name="l00433"></a>00433 {
<a name="l00434"></a>00434     <span class="comment">//NOP</span>
<a name="l00435"></a>00435 }
<a name="l00436"></a>00436 
<a name="l00437"></a>00437 <span class="keywordtype">void</span>
<a name="l00438"></a>00438 EarthManipulator::configureDefaultSettings()
<a name="l00439"></a>00439 {
<a name="l00440"></a>00440     _settings = <span class="keyword">new</span> Settings();
<a name="l00441"></a>00441 
<a name="l00442"></a>00442     <span class="comment">// install default action bindings:</span>
<a name="l00443"></a>00443     ActionOptions options;
<a name="l00444"></a>00444 
<a name="l00445"></a>00445     _settings-&gt;bindKey( ACTION_HOME, osgGA::GUIEventAdapter::KEY_Space );
<a name="l00446"></a>00446 
<a name="l00447"></a>00447     _settings-&gt;bindMouse( ACTION_PAN, osgGA::GUIEventAdapter::LEFT_MOUSE_BUTTON );
<a name="l00448"></a>00448     <span class="comment">//_settings-&gt;bindMouse( ACTION_EARTH_DRAG, osgGA::GUIEventAdapter::LEFT_MOUSE_BUTTON );</span>
<a name="l00449"></a>00449 
<a name="l00450"></a>00450     <span class="comment">// zoom as you hold the right button:</span>
<a name="l00451"></a>00451     options.clear();
<a name="l00452"></a>00452     options.add( OPTION_CONTINUOUS, <span class="keyword">true</span> );
<a name="l00453"></a>00453     _settings-&gt;bindMouse( ACTION_ZOOM, osgGA::GUIEventAdapter::RIGHT_MOUSE_BUTTON, 0L, options );
<a name="l00454"></a>00454 
<a name="l00455"></a>00455     <span class="comment">// rotate with either the middle button or the left+right buttons:</span>
<a name="l00456"></a>00456     _settings-&gt;bindMouse( ACTION_ROTATE, osgGA::GUIEventAdapter::MIDDLE_MOUSE_BUTTON );
<a name="l00457"></a>00457     _settings-&gt;bindMouse( ACTION_ROTATE, osgGA::GUIEventAdapter::LEFT_MOUSE_BUTTON | osgGA::GUIEventAdapter::RIGHT_MOUSE_BUTTON );
<a name="l00458"></a>00458 
<a name="l00459"></a>00459     <span class="comment">// zoom with the scroll wheel:</span>
<a name="l00460"></a>00460     _settings-&gt;bindScroll( ACTION_ZOOM_IN,  osgGA::GUIEventAdapter::SCROLL_DOWN );
<a name="l00461"></a>00461     _settings-&gt;bindScroll( ACTION_ZOOM_OUT, osgGA::GUIEventAdapter::SCROLL_UP );
<a name="l00462"></a>00462 
<a name="l00463"></a>00463     <span class="comment">// pan around with arrow keys:</span>
<a name="l00464"></a>00464     _settings-&gt;bindKey( ACTION_PAN_LEFT,  osgGA::GUIEventAdapter::KEY_Left );
<a name="l00465"></a>00465     _settings-&gt;bindKey( ACTION_PAN_RIGHT, osgGA::GUIEventAdapter::KEY_Right );
<a name="l00466"></a>00466     _settings-&gt;bindKey( ACTION_PAN_UP,    osgGA::GUIEventAdapter::KEY_Up );
<a name="l00467"></a>00467     _settings-&gt;bindKey( ACTION_PAN_DOWN,  osgGA::GUIEventAdapter::KEY_Down );
<a name="l00468"></a>00468 
<a name="l00469"></a>00469     <span class="comment">// double click the left button to zoom in on a point:</span>
<a name="l00470"></a>00470     options.clear();
<a name="l00471"></a>00471     options.add( OPTION_GOTO_RANGE_FACTOR, 0.4 );
<a name="l00472"></a>00472     _settings-&gt;bindMouseDoubleClick( ACTION_GOTO, osgGA::GUIEventAdapter::LEFT_MOUSE_BUTTON, 0L, options );
<a name="l00473"></a>00473 
<a name="l00474"></a>00474     <span class="comment">// double click the right button (or CTRL-left button) to zoom out to a point</span>
<a name="l00475"></a>00475     options.clear();
<a name="l00476"></a>00476     options.add( OPTION_GOTO_RANGE_FACTOR, 2.5 );
<a name="l00477"></a>00477     _settings-&gt;bindMouseDoubleClick( ACTION_GOTO, osgGA::GUIEventAdapter::RIGHT_MOUSE_BUTTON, 0L, options );
<a name="l00478"></a>00478     _settings-&gt;bindMouseDoubleClick( ACTION_GOTO, osgGA::GUIEventAdapter::LEFT_MOUSE_BUTTON, osgGA::GUIEventAdapter::MODKEY_CTRL, options );
<a name="l00479"></a>00479 
<a name="l00480"></a>00480     _settings-&gt;setThrowingEnabled( <span class="keyword">false</span> );
<a name="l00481"></a>00481     _settings-&gt;setLockAzimuthWhilePanning( <span class="keyword">true</span> );
<a name="l00482"></a>00482 }
<a name="l00483"></a>00483 
<a name="l00484"></a>00484 <span class="keywordtype">void</span>
<a name="l00485"></a>00485 EarthManipulator::applySettings( Settings* settings )
<a name="l00486"></a>00486 {
<a name="l00487"></a>00487     <span class="keywordflow">if</span> ( settings )
<a name="l00488"></a>00488     {
<a name="l00489"></a>00489         _settings = settings;
<a name="l00490"></a>00490     }
<a name="l00491"></a>00491     <span class="keywordflow">else</span>
<a name="l00492"></a>00492     {
<a name="l00493"></a>00493         configureDefaultSettings();
<a name="l00494"></a>00494     }
<a name="l00495"></a>00495 
<a name="l00496"></a>00496     _task-&gt;_type = TASK_NONE;
<a name="l00497"></a>00497     flushMouseEventStack();
<a name="l00498"></a>00498 
<a name="l00499"></a>00499     <span class="comment">// apply new pitch restrictions</span>
<a name="l00500"></a>00500     <span class="keywordtype">double</span> old_pitch = osg::RadiansToDegrees( _local_pitch );
<a name="l00501"></a>00501     <span class="keywordtype">double</span> new_pitch = osg::clampBetween( old_pitch, _settings-&gt;getMinPitch(), _settings-&gt;getMaxPitch() );
<a name="l00502"></a>00502         setDistance(_distance);
<a name="l00503"></a>00503 
<a name="l00504"></a>00504     <span class="keywordflow">if</span> ( new_pitch != old_pitch )
<a name="l00505"></a>00505     {
<a name="l00506"></a>00506         Viewpoint vp = getViewpoint();
<a name="l00507"></a>00507         setViewpoint( Viewpoint(vp.getFocalPoint(), vp.getHeading(), new_pitch, vp.getRange(), vp.getSRS()) );
<a name="l00508"></a>00508     }
<a name="l00509"></a>00509 }
<a name="l00510"></a>00510 
<a name="l00511"></a>00511 EarthManipulator::Settings*
<a name="l00512"></a>00512 EarthManipulator::getSettings()<span class="keyword"> const</span>
<a name="l00513"></a>00513 <span class="keyword"></span>{
<a name="l00514"></a>00514     <span class="keywordflow">return</span> _settings.get();
<a name="l00515"></a>00515 }
<a name="l00516"></a>00516 
<a name="l00517"></a>00517 <span class="keywordtype">void</span>
<a name="l00518"></a>00518 EarthManipulator::reinitialize()
<a name="l00519"></a>00519 {
<a name="l00520"></a>00520     _distance = 1.0;
<a name="l00521"></a>00521     _offset_x = 0.0;
<a name="l00522"></a>00522     _offset_y = 0.0;
<a name="l00523"></a>00523     _thrown = <span class="keyword">false</span>;
<a name="l00524"></a>00524     _continuous = <span class="keyword">false</span>;
<a name="l00525"></a>00525     _task = <span class="keyword">new</span> Task();
<a name="l00526"></a>00526     _last_action = ACTION_NULL;
<a name="l00527"></a>00527     _srs_lookup_failed = <span class="keyword">false</span>;
<a name="l00528"></a>00528     _setting_viewpoint = <span class="keyword">false</span>;
<a name="l00529"></a>00529     _delta_t = 0.0;
<a name="l00530"></a>00530     _t_factor = 1.0;
<a name="l00531"></a>00531     _local_azim = 0.0;
<a name="l00532"></a>00532     _local_pitch = 0.0;
<a name="l00533"></a>00533     _has_pending_viewpoint = <span class="keyword">false</span>;
<a name="l00534"></a>00534     _lastPointOnEarth.set(0.0, 0.0, 0.0);
<a name="l00535"></a>00535     _arc_height = 0.0;
<a name="l00536"></a>00536 }
<a name="l00537"></a>00537 
<a name="l00538"></a>00538 <span class="keywordtype">bool</span>
<a name="l00539"></a>00539 EarthManipulator::established()
<a name="l00540"></a>00540 {
<a name="l00541"></a>00541 <span class="preprocessor">#ifdef USE_OBSERVER_NODE_PATH</span>
<a name="l00542"></a>00542 <span class="preprocessor"></span>    <span class="keywordtype">bool</span> needToReestablish = (!_csn.valid() || _csnObserverPath.empty()) &amp;&amp; _node.valid();
<a name="l00543"></a>00543 <span class="preprocessor">#else</span>
<a name="l00544"></a>00544 <span class="preprocessor"></span>    <span class="keywordtype">bool</span> needToReestablish = !_csn.valid() &amp;&amp; _node.valid();
<a name="l00545"></a>00545 <span class="preprocessor">#endif</span>
<a name="l00546"></a>00546 <span class="preprocessor"></span>
<a name="l00547"></a>00547     <span class="keywordflow">if</span> ( needToReestablish )
<a name="l00548"></a>00548     {
<a name="l00549"></a>00549         osg::ref_ptr&lt;osg::Node&gt; safeNode = _node.get();
<a name="l00550"></a>00550         <span class="keywordflow">if</span> ( !safeNode.valid() )
<a name="l00551"></a>00551             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00552"></a>00552         
<a name="l00553"></a>00553         <span class="comment">// check the kids, then the parents</span>
<a name="l00554"></a>00554         osg::ref_ptr&lt;osg::CoordinateSystemNode&gt; csn = osgEarth::findTopMostNodeOfType&lt;osg::CoordinateSystemNode&gt;( safeNode.get() );    
<a name="l00555"></a>00555         <span class="keywordflow">if</span> ( !csn.valid() )
<a name="l00556"></a>00556             csn = osgEarth::findFirstParentOfType&lt;osg::CoordinateSystemNode&gt;( safeNode.get() );        
<a name="l00557"></a>00557 
<a name="l00558"></a>00558         <span class="keywordflow">if</span> ( csn.valid() )
<a name="l00559"></a>00559         {
<a name="l00560"></a>00560             _csn = csn.get();
<a name="l00561"></a>00561             _node = csn.get();
<a name="l00562"></a>00562 
<a name="l00563"></a>00563 <span class="preprocessor">#if USE_OBSERVER_NODE_PATH</span>
<a name="l00564"></a>00564 <span class="preprocessor"></span>            _csnObserverPath.setNodePathTo( csn.get() );
<a name="l00565"></a>00565 <span class="preprocessor">#endif</span>
<a name="l00566"></a>00566 <span class="preprocessor"></span>
<a name="l00567"></a>00567             <span class="keywordflow">if</span> ( !_homeViewpoint.isSet() )
<a name="l00568"></a>00568             {
<a name="l00569"></a>00569                 <span class="keywordflow">if</span> ( _has_pending_viewpoint )
<a name="l00570"></a>00570                 {
<a name="l00571"></a>00571                     setHomeViewpoint(
<a name="l00572"></a>00572                         _pending_viewpoint,
<a name="l00573"></a>00573                         _pending_viewpoint_duration_s );
<a name="l00574"></a>00574 
<a name="l00575"></a>00575                     _has_pending_viewpoint = <span class="keyword">false</span>;
<a name="l00576"></a>00576                 }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578                 <span class="comment">//If we have a CoordinateSystemNode and it has an ellipsoid model</span>
<a name="l00579"></a>00579                 <span class="keywordflow">if</span> ( csn-&gt;getEllipsoidModel() )
<a name="l00580"></a>00580                 {
<a name="l00581"></a>00581                     setHomeViewpoint( 
<a name="l00582"></a>00582                         Viewpoint(osg::Vec3d(-90,0,0), 0, -89,
<a name="l00583"></a>00583                         csn-&gt;getEllipsoidModel()-&gt;getRadiusEquator()*3.0 ) );
<a name="l00584"></a>00584                 }
<a name="l00585"></a>00585                 <span class="keywordflow">else</span>
<a name="l00586"></a>00586                 {
<a name="l00587"></a>00587                     setHomeViewpoint( Viewpoint(
<a name="l00588"></a>00588                         safeNode-&gt;getBound().center(),
<a name="l00589"></a>00589                         0, -89.9, 
<a name="l00590"></a>00590                         safeNode-&gt;getBound().radius()*2.0) );
<a name="l00591"></a>00591                 }
<a name="l00592"></a>00592             }
<a name="l00593"></a>00593 
<a name="l00594"></a>00594             <span class="keywordflow">if</span> ( !_has_pending_viewpoint )
<a name="l00595"></a>00595                 setViewpoint( _homeViewpoint.get(), _homeViewpointDuration );
<a name="l00596"></a>00596             <span class="keywordflow">else</span>
<a name="l00597"></a>00597                 setViewpoint( _pending_viewpoint, _pending_viewpoint_duration_s );
<a name="l00598"></a>00598 
<a name="l00599"></a>00599             _has_pending_viewpoint = <span class="keyword">false</span>;
<a name="l00600"></a>00600         }
<a name="l00601"></a>00601 
<a name="l00602"></a>00602         <span class="comment">//if (getAutoComputeHomePosition()) computeHomePosition();</span>
<a name="l00603"></a>00603 
<a name="l00604"></a>00604         <span class="comment">// reset the srs cache:</span>
<a name="l00605"></a>00605         _cached_srs = NULL;
<a name="l00606"></a>00606         _srs_lookup_failed = <span class="keyword">false</span>;
<a name="l00607"></a>00607 
<a name="l00608"></a>00608         <span class="comment">// track the local angles.</span>
<a name="l00609"></a>00609         recalculateLocalPitchAndAzimuth();
<a name="l00610"></a>00610 
<a name="l00611"></a>00611         <span class="comment">//OE_DEBUG &lt;&lt; &quot;[EarthManip] new CSN established.&quot; &lt;&lt; std::endl;</span>
<a name="l00612"></a>00612     }
<a name="l00613"></a>00613 
<a name="l00614"></a>00614     <span class="keywordflow">return</span> _csn.valid() &amp;&amp; _node.valid();
<a name="l00615"></a>00615 }
<a name="l00616"></a>00616 
<a name="l00617"></a>00617 <span class="comment">// This is code taken from osgViewer::View and placed here so that we can control the</span>
<a name="l00618"></a>00618 <span class="comment">// caching of the CSNPath ourselves without relying on View. This helps when switching</span>
<a name="l00619"></a>00619 <span class="comment">// out the Manipulator&#39;s Node.</span>
<a name="l00620"></a>00620 osg::CoordinateFrame
<a name="l00621"></a>00621 EarthManipulator::getMyCoordinateFrame( <span class="keyword">const</span> osg::Vec3d&amp; position )<span class="keyword"> const</span>
<a name="l00622"></a>00622 <span class="keyword"></span>{
<a name="l00623"></a>00623     osg::CoordinateFrame coordinateFrame;
<a name="l00624"></a>00624 
<a name="l00625"></a>00625     osg::ref_ptr&lt;osg::CoordinateSystemNode&gt; csnSafe = _csn.get();
<a name="l00626"></a>00626 
<a name="l00627"></a>00627     <span class="keywordflow">if</span> ( csnSafe.valid() )
<a name="l00628"></a>00628     {
<a name="l00629"></a>00629 <span class="preprocessor">#ifdef USE_OBSERVER_NODE_PATH</span>
<a name="l00630"></a>00630 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( _csnObserverPath.empty() )
<a name="l00631"></a>00631         {
<a name="l00632"></a>00632             <span class="keyword">const_cast&lt;</span>EarthManipulator*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;_csnObserverPath.setNodePathTo( csnSafe.get() );
<a name="l00633"></a>00633             _csnObserverPath.getNodePath( const_cast&lt;EarthManipulator*&gt;(<span class="keyword">this</span>)-&gt;_csnPath );
<a name="l00634"></a>00634         }
<a name="l00635"></a>00635 <span class="preprocessor">#else</span>
<a name="l00636"></a>00636 <span class="preprocessor"></span>        <span class="keyword">const_cast&lt;</span>EarthManipulator*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;_csnPath = csnSafe-&gt;getParentalNodePaths()[0];
<a name="l00637"></a>00637 <span class="preprocessor">#endif</span>
<a name="l00638"></a>00638 <span class="preprocessor"></span>
<a name="l00639"></a>00639         osg::Vec3 local_position = position * osg::computeWorldToLocal( _csnPath );
<a name="l00640"></a>00640 
<a name="l00641"></a>00641         <span class="comment">// get the coordinate frame in world coords.</span>
<a name="l00642"></a>00642         coordinateFrame = csnSafe-&gt;computeLocalCoordinateFrame( local_position ) * osg::computeLocalToWorld( _csnPath );
<a name="l00643"></a>00643 
<a name="l00644"></a>00644         <span class="comment">// keep the position of the coordinate frame to reapply after rescale.</span>
<a name="l00645"></a>00645         osg::Vec3d pos = coordinateFrame.getTrans();
<a name="l00646"></a>00646 
<a name="l00647"></a>00647         <span class="comment">// compensate for any scaling, so that the coordinate frame is a unit size</span>
<a name="l00648"></a>00648         osg::Vec3d x(1.0,0.0,0.0);
<a name="l00649"></a>00649         osg::Vec3d y(0.0,1.0,0.0);
<a name="l00650"></a>00650         osg::Vec3d z(0.0,0.0,1.0);
<a name="l00651"></a>00651         x = osg::Matrixd::transform3x3(x,coordinateFrame);
<a name="l00652"></a>00652         y = osg::Matrixd::transform3x3(y,coordinateFrame);
<a name="l00653"></a>00653         z = osg::Matrixd::transform3x3(z,coordinateFrame);
<a name="l00654"></a>00654         coordinateFrame.preMultScale( osg::Vec3d(1.0/x.length(),1.0/y.length(),1.0/z.length()) );
<a name="l00655"></a>00655 
<a name="l00656"></a>00656         <span class="comment">// reapply the position.</span>
<a name="l00657"></a>00657         coordinateFrame.setTrans( pos );
<a name="l00658"></a>00658     }
<a name="l00659"></a>00659     <span class="keywordflow">else</span>
<a name="l00660"></a>00660     {
<a name="l00661"></a>00661         coordinateFrame = osg::computeLocalToWorld( _csnPath );
<a name="l00662"></a>00662     }
<a name="l00663"></a>00663 
<a name="l00664"></a>00664     <span class="keywordflow">return</span> coordinateFrame;
<a name="l00665"></a>00665 }
<a name="l00666"></a>00666 
<a name="l00667"></a>00667 <span class="keywordtype">void</span>
<a name="l00668"></a>00668 EarthManipulator::setNode(osg::Node* node)
<a name="l00669"></a>00669 {
<a name="l00670"></a>00670     <span class="comment">// you can only set the node if it has not already been set, OR if you are setting</span>
<a name="l00671"></a>00671     <span class="comment">// it to NULL. (So to change it, you must first set it to NULL.) This is to prevent</span>
<a name="l00672"></a>00672     <span class="comment">// OSG from overwriting the node after you have already set on manually.</span>
<a name="l00673"></a>00673     <span class="keywordflow">if</span> ( node == 0L || !_node.valid() )
<a name="l00674"></a>00674     {
<a name="l00675"></a>00675         _node = node;
<a name="l00676"></a>00676         _csn = 0L;
<a name="l00677"></a>00677 <span class="preprocessor">#ifdef USE_OBSERVER_NODE_PATH</span>
<a name="l00678"></a>00678 <span class="preprocessor"></span>        _csnObserverPath.clearNodePath();
<a name="l00679"></a>00679 <span class="preprocessor">#endif</span>
<a name="l00680"></a>00680 <span class="preprocessor"></span>        _csnPath.clear();
<a name="l00681"></a>00681         reinitialize();
<a name="l00682"></a>00682 
<a name="l00683"></a>00683         <span class="comment">// this might be unnecessary..</span>
<a name="l00684"></a>00684         established();
<a name="l00685"></a>00685     }
<a name="l00686"></a>00686 }
<a name="l00687"></a>00687 
<a name="l00688"></a>00688 osg::Node*
<a name="l00689"></a>00689 EarthManipulator::getNode()
<a name="l00690"></a>00690 {
<a name="l00691"></a>00691     <span class="keywordflow">return</span> _node.get();
<a name="l00692"></a>00692 }
<a name="l00693"></a>00693 
<a name="l00694"></a>00694 <span class="keyword">const</span> osgEarth::SpatialReference*
<a name="l00695"></a>00695 EarthManipulator::getSRS()<span class="keyword"> const</span>
<a name="l00696"></a>00696 <span class="keyword"></span>{
<a name="l00697"></a>00697     osg::ref_ptr&lt;osg::Node&gt; safeNode = _node.get();
<a name="l00698"></a>00698 
<a name="l00699"></a>00699     <span class="keywordflow">if</span> ( !_cached_srs.valid() &amp;&amp; !_srs_lookup_failed &amp;&amp; safeNode.valid() )
<a name="l00700"></a>00700     {
<a name="l00701"></a>00701         EarthManipulator* nonconst_this = <span class="keyword">const_cast&lt;</span>EarthManipulator*<span class="keyword">&gt;</span>(<span class="keyword">this</span>);
<a name="l00702"></a>00702 
<a name="l00703"></a>00703         nonconst_this-&gt;_is_geocentric = <span class="keyword">false</span>;
<a name="l00704"></a>00704 
<a name="l00705"></a>00705         <span class="comment">// first try to find a map node:</span>
<a name="l00706"></a>00706         osgEarth::MapNode* mapNode = osgEarth::MapNode::findMapNode( safeNode.get() );       
<a name="l00707"></a>00707         <span class="keywordflow">if</span> ( mapNode )
<a name="l00708"></a>00708         {
<a name="l00709"></a>00709             nonconst_this-&gt;_cached_srs = mapNode-&gt;getMap()-&gt;getProfile()-&gt;getSRS();
<a name="l00710"></a>00710             nonconst_this-&gt;_is_geocentric = mapNode-&gt;isGeocentric();
<a name="l00711"></a>00711         }
<a name="l00712"></a>00712 
<a name="l00713"></a>00713         <span class="comment">// if that doesn&#39;t work, try gleaning info from a CSN:</span>
<a name="l00714"></a>00714         <span class="keywordflow">if</span> ( !_cached_srs.valid() )
<a name="l00715"></a>00715         {
<a name="l00716"></a>00716             osg::CoordinateSystemNode* csn = osgEarth::findTopMostNodeOfType&lt;osg::CoordinateSystemNode&gt;( safeNode.get() );
<a name="l00717"></a>00717             <span class="keywordflow">if</span> ( csn )
<a name="l00718"></a>00718             {
<a name="l00719"></a>00719                 nonconst_this-&gt;_cached_srs = osgEarth::SpatialReference::create( csn );
<a name="l00720"></a>00720                 nonconst_this-&gt;_is_geocentric = csn-&gt;getEllipsoidModel() != NULL;
<a name="l00721"></a>00721             }
<a name="l00722"></a>00722         }
<a name="l00723"></a>00723 
<a name="l00724"></a>00724         nonconst_this-&gt;_srs_lookup_failed = !_cached_srs.valid();
<a name="l00725"></a>00725 
<a name="l00726"></a>00726         <span class="keywordflow">if</span> ( _cached_srs.valid() )
<a name="l00727"></a>00727         {
<a name="l00728"></a>00728             OE_INFO &lt;&lt; <span class="stringliteral">&quot;[EarthManip] cached SRS: &quot;</span>
<a name="l00729"></a>00729                 &lt;&lt; _cached_srs-&gt;getName()
<a name="l00730"></a>00730                 &lt;&lt; <span class="stringliteral">&quot;, geocentric=&quot;</span> &lt;&lt; _is_geocentric
<a name="l00731"></a>00731                 &lt;&lt; std::endl;
<a name="l00732"></a>00732         }
<a name="l00733"></a>00733     }
<a name="l00734"></a>00734 
<a name="l00735"></a>00735     <span class="keywordflow">return</span> _cached_srs.get();
<a name="l00736"></a>00736 }
<a name="l00737"></a>00737 
<a name="l00738"></a>00738 
<a name="l00739"></a>00739 <span class="keyword">static</span> <span class="keywordtype">double</span>
<a name="l00740"></a>00740 normalizeAzimRad( <span class="keywordtype">double</span> input ) {
<a name="l00741"></a>00741         <span class="keywordflow">if</span>(fabs(input) &gt; 2*osg::PI)
<a name="l00742"></a>00742                 input = fmod(input,2*osg::PI);
<a name="l00743"></a>00743     <span class="keywordflow">if</span>( input &lt; -osg::PI ) input += osg::PI*2.0;
<a name="l00744"></a>00744     <span class="keywordflow">if</span>( input &gt; osg::PI ) input -= osg::PI*2.0;
<a name="l00745"></a>00745     <span class="keywordflow">return</span> input;
<a name="l00746"></a>00746 }
<a name="l00747"></a>00747 
<a name="l00748"></a>00748 osg::Matrixd
<a name="l00749"></a>00749 EarthManipulator::getRotation(<span class="keyword">const</span> osg::Vec3d&amp; point)<span class="keyword"> const</span>
<a name="l00750"></a>00750 <span class="keyword"></span>{
<a name="l00751"></a>00751     <span class="comment">//The look vector will be going directly from the eye point to the point on the earth,</span>
<a name="l00752"></a>00752     <span class="comment">//so the look vector is simply the up vector at the center point</span>
<a name="l00753"></a>00753     osg::CoordinateFrame cf = getMyCoordinateFrame( point ); <span class="comment">//getCoordinateFrame(point);</span>
<a name="l00754"></a>00754     osg::Vec3d lookVector = -getUpVector(cf);
<a name="l00755"></a>00755 
<a name="l00756"></a>00756     osg::Vec3d side;
<a name="l00757"></a>00757 
<a name="l00758"></a>00758     <span class="comment">//Force the side vector to be orthogonal to north</span>
<a name="l00759"></a>00759     osg::Vec3d worldUp(0,0,1);
<a name="l00760"></a>00760 
<a name="l00761"></a>00761     <span class="keywordtype">double</span> dot = osg::absolute(worldUp * lookVector);
<a name="l00762"></a>00762     <span class="keywordflow">if</span> (osg::equivalent(dot, 1.0))
<a name="l00763"></a>00763     {
<a name="l00764"></a>00764         <span class="comment">//We are looking nearly straight down the up vector, so use the Y vector for world up instead</span>
<a name="l00765"></a>00765         worldUp = osg::Vec3d(0, 1, 0);
<a name="l00766"></a>00766         <span class="comment">//OE_NOTICE &lt;&lt; &quot;using y vector victor&quot; &lt;&lt; std::endl;</span>
<a name="l00767"></a>00767     }
<a name="l00768"></a>00768 
<a name="l00769"></a>00769     side = lookVector ^ worldUp;
<a name="l00770"></a>00770     osg::Vec3d up = side ^ lookVector;
<a name="l00771"></a>00771     up.normalize();
<a name="l00772"></a>00772 
<a name="l00773"></a>00773     <span class="comment">//We want a very slight offset</span>
<a name="l00774"></a>00774     <span class="keywordtype">double</span> offset = 1e-6;
<a name="l00775"></a>00775 
<a name="l00776"></a>00776     <span class="keywordflow">return</span> osg::Matrixd::lookAt( point - (lookVector * offset), point, up);
<a name="l00777"></a>00777 }
<a name="l00778"></a>00778 
<a name="l00779"></a>00779 <span class="keywordtype">void</span>
<a name="l00780"></a>00780 EarthManipulator::setViewpoint( <span class="keyword">const</span> Viewpoint&amp; vp, <span class="keywordtype">double</span> duration_s )
<a name="l00781"></a>00781 {
<a name="l00782"></a>00782     <span class="keywordflow">if</span> ( !established() ) <span class="comment">// !_node.valid() ) // || !_after_first_frame )</span>
<a name="l00783"></a>00783     {
<a name="l00784"></a>00784         _pending_viewpoint = vp;
<a name="l00785"></a>00785         _pending_viewpoint_duration_s = duration_s;
<a name="l00786"></a>00786         _has_pending_viewpoint = <span class="keyword">true</span>;
<a name="l00787"></a>00787     }
<a name="l00788"></a>00788 
<a name="l00789"></a>00789     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( duration_s &gt; 0.0 )
<a name="l00790"></a>00790     {
<a name="l00791"></a>00791         _start_viewpoint = getViewpoint();
<a name="l00792"></a>00792         
<a name="l00793"></a>00793         _delta_heading = vp.getHeading() - _start_viewpoint.getHeading(); <span class="comment">//TODO: adjust for crossing -180</span>
<a name="l00794"></a>00794         _delta_pitch   = vp.getPitch() - _start_viewpoint.getPitch();
<a name="l00795"></a>00795         _delta_range   = vp.getRange() - _start_viewpoint.getRange();
<a name="l00796"></a>00796         _delta_focal_point = vp.getFocalPoint() - _start_viewpoint.getFocalPoint(); <span class="comment">// TODO: adjust for lon=180 crossing</span>
<a name="l00797"></a>00797 
<a name="l00798"></a>00798         <span class="keywordflow">while</span>( _delta_heading &gt; 180.0 ) _delta_heading -= 360.0;
<a name="l00799"></a>00799         <span class="keywordflow">while</span>( _delta_heading &lt; -180.0 ) _delta_heading += 360.0;
<a name="l00800"></a>00800 
<a name="l00801"></a>00801         <span class="comment">// adjust for geocentric date-line crossing</span>
<a name="l00802"></a>00802         <span class="keywordflow">if</span> ( _is_geocentric )
<a name="l00803"></a>00803         {
<a name="l00804"></a>00804             <span class="keywordflow">while</span>( _delta_focal_point.x() &gt; 180.0 ) _delta_focal_point.x() -= 360.0;
<a name="l00805"></a>00805             <span class="keywordflow">while</span>( _delta_focal_point.x() &lt; -180.0 ) _delta_focal_point.x() += 360.0;
<a name="l00806"></a>00806         }
<a name="l00807"></a>00807 
<a name="l00808"></a>00808         <span class="comment">// calculate an acceleration factor based on the Z differential</span>
<a name="l00809"></a>00809         <span class="keywordtype">double</span> h0 = _start_viewpoint.getRange() * sin( osg::DegreesToRadians(-_start_viewpoint.getPitch()) );
<a name="l00810"></a>00810         <span class="keywordtype">double</span> h1 = vp.getRange() * sin( osg::DegreesToRadians( -vp.getPitch() ) );
<a name="l00811"></a>00811         <span class="keywordtype">double</span> dh = (h1 - h0);
<a name="l00812"></a>00812 
<a name="l00813"></a>00813         <span class="comment">// calculate the total distance the focal point will travel and derive an arc height:</span>
<a name="l00814"></a>00814         <span class="keywordtype">double</span> de;
<a name="l00815"></a>00815         <span class="keywordflow">if</span> ( _is_geocentric &amp;&amp; (vp.getSRS() == 0L || vp.getSRS()-&gt;isGeographic()) )
<a name="l00816"></a>00816         {
<a name="l00817"></a>00817             osg::Vec3d startFP = _start_viewpoint.getFocalPoint();
<a name="l00818"></a>00818             <span class="keywordtype">double</span> x0,y0,z0, x1,y1,z1;
<a name="l00819"></a>00819             _cached_srs-&gt;getEllipsoid()-&gt;convertLatLongHeightToXYZ(
<a name="l00820"></a>00820                 osg::DegreesToRadians( _start_viewpoint.y() ), osg::DegreesToRadians( _start_viewpoint.x() ), 0.0, x0, y0, z0 );
<a name="l00821"></a>00821             _cached_srs-&gt;getEllipsoid()-&gt;convertLatLongHeightToXYZ(
<a name="l00822"></a>00822                 osg::DegreesToRadians( vp.y() ), osg::DegreesToRadians( vp.x() ), 0.0, x1, y1, z1 );
<a name="l00823"></a>00823             de = (osg::Vec3d(x0,y0,z0) - osg::Vec3d(x1,y1,z1)).length();
<a name="l00824"></a>00824         }
<a name="l00825"></a>00825         <span class="keywordflow">else</span>
<a name="l00826"></a>00826         {
<a name="l00827"></a>00827             de = _delta_focal_point.length();
<a name="l00828"></a>00828         }
<a name="l00829"></a>00829 
<a name="l00830"></a>00830         _arc_height = 0.0;
<a name="l00831"></a>00831         <span class="keywordflow">if</span> ( _settings-&gt;getArcViewpointTransitions() )
<a name="l00832"></a>00832         {         
<a name="l00833"></a>00833             _arc_height = osg::maximum( de - fabs(dh), 0.0 );
<a name="l00834"></a>00834         }
<a name="l00835"></a>00835 
<a name="l00836"></a>00836         <span class="comment">// calculate acceleration coefficients</span>
<a name="l00837"></a>00837         <span class="keywordflow">if</span> ( _arc_height &gt; 0.0 )
<a name="l00838"></a>00838         {
<a name="l00839"></a>00839             <span class="comment">// if we&#39;re arcing, we need seperate coefficients for the up and down stages</span>
<a name="l00840"></a>00840             <span class="keywordtype">double</span> h_apex = 2.0*(h0+h1) + _arc_height;
<a name="l00841"></a>00841             <span class="keywordtype">double</span> dh2_up = fabs(h_apex - h0)/100000.0;
<a name="l00842"></a>00842             _set_viewpoint_accel = log10( dh2_up );
<a name="l00843"></a>00843             <span class="keywordtype">double</span> dh2_down = fabs(h_apex - h1)/100000.0;
<a name="l00844"></a>00844             _set_viewpoint_accel_2 = -log10( dh2_down );
<a name="l00845"></a>00845         }
<a name="l00846"></a>00846         <span class="keywordflow">else</span>
<a name="l00847"></a>00847         {
<a name="l00848"></a>00848             <span class="comment">// on arc =&gt; simple unidirectional acceleration:</span>
<a name="l00849"></a>00849             <span class="keywordtype">double</span> dh2 = (h1 - h0)/100000.0;
<a name="l00850"></a>00850             _set_viewpoint_accel = fabs(dh2) &lt;= 1.0? 0.0 : dh2 &gt; 0.0? log10( dh2 ) : -log10( -dh2 );
<a name="l00851"></a>00851             <span class="keywordflow">if</span> ( fabs( _set_viewpoint_accel ) &lt; 1.0 ) _set_viewpoint_accel = 0.0;
<a name="l00852"></a>00852         }
<a name="l00853"></a>00853         
<a name="l00854"></a>00854         <span class="keywordflow">if</span> ( _settings-&gt;getAutoViewpointDurationEnabled() )
<a name="l00855"></a>00855         {
<a name="l00856"></a>00856             <span class="keywordtype">double</span> maxDistance = _cached_srs-&gt;getEllipsoid()-&gt;getRadiusEquator();
<a name="l00857"></a>00857             <span class="keywordtype">double</span> ratio = osg::clampBetween( de/maxDistance, 0.0, 1.0 );
<a name="l00858"></a>00858             ratio = accelerationInterp( ratio, -4.5 );
<a name="l00859"></a>00859             <span class="keywordtype">double</span> minDur, maxDur;
<a name="l00860"></a>00860             _settings-&gt;getAutoViewpointDurationLimits( minDur, maxDur );
<a name="l00861"></a>00861             duration_s = minDur + ratio*(maxDur-minDur);
<a name="l00862"></a>00862         }
<a name="l00863"></a>00863         
<a name="l00864"></a>00864         <span class="comment">// don&#39;t use _time_s_now; that&#39;s the time of the last event</span>
<a name="l00865"></a>00865         _time_s_set_viewpoint = osg::Timer::instance()-&gt;time_s();
<a name="l00866"></a>00866         _set_viewpoint_duration_s = duration_s;
<a name="l00867"></a>00867 
<a name="l00868"></a>00868 <span class="comment">//        OE_NOTICE</span>
<a name="l00872"></a>00872 <span class="comment"></span><span class="comment">//            &lt;&lt; &quot;, h0=&quot; &lt;&lt; h0</span>
<a name="l00873"></a>00873 <span class="comment">//            &lt;&lt; &quot;, h1=&quot; &lt;&lt; h0</span>
<a name="l00874"></a>00874 <span class="comment">//            &lt;&lt; &quot;, dh=&quot; &lt;&lt; dh</span>
<a name="l00875"></a>00875 <span class="comment">//            //&lt;&lt; &quot;, h_delta=&quot; &lt;&lt; h_delta</span>
<a name="l00876"></a>00876 <span class="comment">//            &lt;&lt; &quot;, accel = &quot; &lt;&lt; _set_viewpoint_accel</span>
<a name="l00877"></a>00877 <span class="comment">//            &lt;&lt; &quot;, archeight = &quot; &lt;&lt; _arc_height</span>
<a name="l00879"></a>00879 <span class="comment"></span><span class="comment">//            &lt;&lt; std::endl;</span>
<a name="l00880"></a>00880 
<a name="l00881"></a>00881         _setting_viewpoint = <span class="keyword">true</span>;
<a name="l00882"></a>00882         
<a name="l00883"></a>00883         _thrown = <span class="keyword">false</span>;
<a name="l00884"></a>00884         _task-&gt;_type = TASK_NONE;
<a name="l00885"></a>00885 
<a name="l00886"></a>00886         recalculateCenter( getMyCoordinateFrame(_center) );
<a name="l00887"></a>00887         <span class="comment">//recalculateCenter( getCoordinateFrame(_center) );</span>
<a name="l00888"></a>00888     }
<a name="l00889"></a>00889     <span class="keywordflow">else</span>
<a name="l00890"></a>00890     {
<a name="l00891"></a>00891         osg::Vec3d new_center = vp.getFocalPoint();
<a name="l00892"></a>00892 
<a name="l00893"></a>00893         <span class="comment">// start by transforming the requested focal point into world coordinates:</span>
<a name="l00894"></a>00894         <span class="keywordflow">if</span> ( getSRS() )
<a name="l00895"></a>00895         {
<a name="l00896"></a>00896             <span class="comment">// resolve the VP&#39;s srs. If the VP&#39;s SRS is not specified, assume that it</span>
<a name="l00897"></a>00897             <span class="comment">// is either lat/long (if the map is geocentric) or X/Y (otherwise).</span>
<a name="l00898"></a>00898             osg::ref_ptr&lt;const SpatialReference&gt; vp_srs = vp.getSRS()? vp.getSRS() :
<a name="l00899"></a>00899                 _is_geocentric? getSRS()-&gt;getGeographicSRS() :
<a name="l00900"></a>00900                 getSRS();
<a name="l00901"></a>00901 
<a name="l00902"></a>00902             <span class="keywordflow">if</span> ( !getSRS()-&gt;isEquivalentTo( vp_srs.get() ) )
<a name="l00903"></a>00903             {
<a name="l00904"></a>00904                 osg::Vec3d local = new_center;
<a name="l00905"></a>00905                 <span class="comment">// reproject the focal point if necessary:</span>
<a name="l00906"></a>00906                 vp_srs-&gt;transform2D( new_center.x(), new_center.y(), getSRS(), local.x(), local.y() );
<a name="l00907"></a>00907                 new_center = local;
<a name="l00908"></a>00908             }
<a name="l00909"></a>00909 
<a name="l00910"></a>00910             <span class="comment">// convert to geocentric coords if necessary:</span>
<a name="l00911"></a>00911             <span class="keywordflow">if</span> ( _is_geocentric )
<a name="l00912"></a>00912             {
<a name="l00913"></a>00913                 osg::Vec3d geocentric;
<a name="l00914"></a>00914 
<a name="l00915"></a>00915                 getSRS()-&gt;getEllipsoid()-&gt;convertLatLongHeightToXYZ(
<a name="l00916"></a>00916                     osg::DegreesToRadians( new_center.y() ),
<a name="l00917"></a>00917                     osg::DegreesToRadians( new_center.x() ),
<a name="l00918"></a>00918                     new_center.z(),
<a name="l00919"></a>00919                     geocentric.x(), geocentric.y(), geocentric.z() );
<a name="l00920"></a>00920 
<a name="l00921"></a>00921                 new_center = geocentric;            
<a name="l00922"></a>00922             }
<a name="l00923"></a>00923         }
<a name="l00924"></a>00924 
<a name="l00925"></a>00925         <span class="comment">// now calculate the new rotation matrix based on the angles:</span>
<a name="l00926"></a>00926 
<a name="l00927"></a>00927 
<a name="l00928"></a>00928         <span class="keywordtype">double</span> new_pitch = osg::DegreesToRadians(
<a name="l00929"></a>00929             osg::clampBetween( vp.getPitch(), _settings-&gt;getMinPitch(), _settings-&gt;getMaxPitch() ) );
<a name="l00930"></a>00930 
<a name="l00931"></a>00931         <span class="keywordtype">double</span> new_azim = normalizeAzimRad( osg::DegreesToRadians( vp.getHeading() ) );
<a name="l00932"></a>00932 
<a name="l00933"></a>00933         _center = new_center;
<a name="l00934"></a>00934                 setDistance( vp.getRange() );
<a name="l00935"></a>00935         
<a name="l00936"></a>00936         osg::CoordinateFrame local_frame = getMyCoordinateFrame( new_center ); <span class="comment">//getCoordinateFrame( new_center );</span>
<a name="l00937"></a>00937         _previousUp = getUpVector( local_frame );
<a name="l00938"></a>00938 
<a name="l00939"></a>00939         _centerRotation = getRotation( new_center ).getRotate().inverse();
<a name="l00940"></a>00940 
<a name="l00941"></a>00941                 osg::Quat azim_q( new_azim, osg::Vec3d(0,0,1) );
<a name="l00942"></a>00942         osg::Quat pitch_q( -new_pitch -osg::PI_2, osg::Vec3d(1,0,0) );
<a name="l00943"></a>00943 
<a name="l00944"></a>00944                 osg::Matrix new_rot = osg::Matrixd( azim_q * pitch_q );
<a name="l00945"></a>00945 
<a name="l00946"></a>00946                 _rotation = osg::Matrixd::inverse(new_rot).getRotate();
<a name="l00947"></a>00947 
<a name="l00948"></a>00948                 <span class="comment">//OE_NOTICE &lt;&lt; &quot;Pitch old=&quot; &lt;&lt; _local_pitch &lt;&lt; &quot; new=&quot; &lt;&lt; new_pitch &lt;&lt; std::endl;</span>
<a name="l00949"></a>00949                 <span class="comment">//OE_NOTICE &lt;&lt; &quot;Azim old=&quot; &lt;&lt; _local_azim &lt;&lt; &quot; new=&quot; &lt;&lt; new_azim &lt;&lt; std::endl;</span>
<a name="l00950"></a>00950 
<a name="l00951"></a>00951         _local_pitch = new_pitch;
<a name="l00952"></a>00952         _local_azim  = new_azim;
<a name="l00953"></a>00953 
<a name="l00954"></a>00954         <span class="comment">// re-intersect the terrain to get a new correct center point, but only if this is</span>
<a name="l00955"></a>00955         <span class="comment">// NOT a viewpoint transition update. (disabled check for now)</span>
<a name="l00956"></a>00956         <span class="comment">//if ( !_setting_viewpoint )</span>
<a name="l00957"></a>00957         recalculateCenter( local_frame );
<a name="l00958"></a>00958     }
<a name="l00959"></a>00959 }
<a name="l00960"></a>00960 
<a name="l00961"></a>00961 <span class="keywordtype">void</span>
<a name="l00962"></a>00962 EarthManipulator::updateSetViewpoint()
<a name="l00963"></a>00963 {
<a name="l00964"></a>00964     <span class="keywordtype">double</span> t = ( _time_s_now - _time_s_set_viewpoint ) / _set_viewpoint_duration_s;
<a name="l00965"></a>00965     <span class="keywordtype">double</span> tp = t;
<a name="l00966"></a>00966 
<a name="l00967"></a>00967     <span class="keywordflow">if</span> ( t &gt;= 1.0 )
<a name="l00968"></a>00968     {
<a name="l00969"></a>00969         t = tp = 1.0;
<a name="l00970"></a>00970         _setting_viewpoint = <span class="keyword">false</span>;
<a name="l00971"></a>00971     }
<a name="l00972"></a>00972     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( _arc_height &gt; 0.0 )
<a name="l00973"></a>00973     {
<a name="l00974"></a>00974         <span class="keywordflow">if</span> ( tp &lt;= 0.5 )
<a name="l00975"></a>00975         {
<a name="l00976"></a>00976             <span class="keywordtype">double</span> t2 = 2.0*tp;
<a name="l00977"></a>00977             t2 = accelerationInterp( t2, _set_viewpoint_accel );
<a name="l00978"></a>00978             tp = 0.5*t2;
<a name="l00979"></a>00979         }
<a name="l00980"></a>00980         <span class="keywordflow">else</span>
<a name="l00981"></a>00981         {
<a name="l00982"></a>00982             <span class="keywordtype">double</span> t2 = 2.0*(tp-0.5);
<a name="l00983"></a>00983             t2 = accelerationInterp( t2, _set_viewpoint_accel_2 );
<a name="l00984"></a>00984             tp = 0.5+(0.5*t2);
<a name="l00985"></a>00985         }
<a name="l00986"></a>00986 
<a name="l00987"></a>00987         <span class="comment">// the more smoothsteps you do, the more pronounced the fade-in/out effect        </span>
<a name="l00988"></a>00988         tp = smoothStepInterp( tp );
<a name="l00989"></a>00989         tp = smoothStepInterp( tp );
<a name="l00990"></a>00990     }
<a name="l00991"></a>00991     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( t &gt; 0.0 )
<a name="l00992"></a>00992     {
<a name="l00993"></a>00993         tp = accelerationInterp( tp, _set_viewpoint_accel );
<a name="l00994"></a>00994         tp = smoothStepInterp( tp );
<a name="l00995"></a>00995     }
<a name="l00996"></a>00996 
<a name="l00997"></a>00997     Viewpoint new_vp(
<a name="l00998"></a>00998         _start_viewpoint.getFocalPoint() + _delta_focal_point * tp,
<a name="l00999"></a>00999         _start_viewpoint.getHeading() + _delta_heading * tp,
<a name="l01000"></a>01000         _start_viewpoint.getPitch() + _delta_pitch * tp,
<a name="l01001"></a>01001         _start_viewpoint.getRange() + _delta_range * tp + (sin(osg::PI*tp)*_arc_height),
<a name="l01002"></a>01002         _start_viewpoint.getSRS() );
<a name="l01003"></a>01003 
<a name="l01004"></a>01004 <span class="preprocessor">#if 0</span>
<a name="l01005"></a>01005 <span class="preprocessor"></span>    OE_INFO
<a name="l01006"></a>01006         &lt;&lt; <span class="stringliteral">&quot;t=&quot;</span> &lt;&lt; t 
<a name="l01007"></a>01007         &lt;&lt; <span class="stringliteral">&quot;, tp=&quot;</span> &lt;&lt; tp
<a name="l01008"></a>01008         &lt;&lt; <span class="stringliteral">&quot;, tsv=&quot;</span> &lt;&lt; _time_s_set_viewpoint
<a name="l01009"></a>01009         &lt;&lt; <span class="stringliteral">&quot;, now=&quot;</span> &lt;&lt; _time_s_now
<a name="l01010"></a>01010         &lt;&lt; <span class="stringliteral">&quot;, accel=&quot;</span> &lt;&lt; _set_viewpoint_accel
<a name="l01011"></a>01011         &lt;&lt; <span class="stringliteral">&quot;, accel2=&quot;</span> &lt;&lt; _set_viewpoint_accel_2
<a name="l01012"></a>01012         &lt;&lt; std::endl;
<a name="l01013"></a>01013 <span class="preprocessor">#endif</span>
<a name="l01014"></a>01014 <span class="preprocessor"></span>
<a name="l01015"></a>01015     setViewpoint( new_vp );
<a name="l01016"></a>01016 }
<a name="l01017"></a>01017 
<a name="l01018"></a>01018 
<a name="l01019"></a>01019 Viewpoint
<a name="l01020"></a>01020 EarthManipulator::getViewpoint()<span class="keyword"> const</span>
<a name="l01021"></a>01021 <span class="keyword"></span>{
<a name="l01022"></a>01022     osg::Vec3d focal_point = _center;
<a name="l01023"></a>01023 
<a name="l01024"></a>01024     <span class="keywordflow">if</span> ( getSRS() &amp;&amp; _is_geocentric )
<a name="l01025"></a>01025     {
<a name="l01026"></a>01026         <span class="comment">// convert geocentric to lat/long:</span>
<a name="l01027"></a>01027         getSRS()-&gt;getEllipsoid()-&gt;convertXYZToLatLongHeight(
<a name="l01028"></a>01028             _center.x(), _center.y(), _center.z(),
<a name="l01029"></a>01029             focal_point.y(), focal_point.x(), focal_point.z() );
<a name="l01030"></a>01030 
<a name="l01031"></a>01031         focal_point.x() = osg::RadiansToDegrees( focal_point.x() );
<a name="l01032"></a>01032         focal_point.y() = osg::RadiansToDegrees( focal_point.y() );
<a name="l01033"></a>01033     }
<a name="l01034"></a>01034 
<a name="l01035"></a>01035     <span class="keywordflow">return</span> Viewpoint(
<a name="l01036"></a>01036         focal_point,
<a name="l01037"></a>01037         osg::RadiansToDegrees( _local_azim ),
<a name="l01038"></a>01038         osg::RadiansToDegrees( _local_pitch ),
<a name="l01039"></a>01039         _distance,
<a name="l01040"></a>01040         getSRS() );
<a name="l01041"></a>01041 }
<a name="l01042"></a>01042 
<a name="l01043"></a>01043 
<a name="l01044"></a>01044 <span class="keywordtype">void</span>
<a name="l01045"></a>01045 EarthManipulator::setTetherNode( osg::Node* node )
<a name="l01046"></a>01046 {
<a name="l01047"></a>01047         <span class="keywordflow">if</span> (_tether_node != node)
<a name="l01048"></a>01048         {
<a name="l01049"></a>01049                 _offset_x = 0.0;
<a name="l01050"></a>01050                 _offset_y = 0.0;
<a name="l01051"></a>01051         }
<a name="l01052"></a>01052     _tether_node = node;
<a name="l01053"></a>01053 }
<a name="l01054"></a>01054 
<a name="l01055"></a>01055 osg::Node*
<a name="l01056"></a>01056 EarthManipulator::getTetherNode()<span class="keyword"> const</span>
<a name="l01057"></a>01057 <span class="keyword"></span>{
<a name="l01058"></a>01058     <span class="keywordflow">return</span> _tether_node.get();
<a name="l01059"></a>01059 }
<a name="l01060"></a>01060 
<a name="l01061"></a>01061 
<a name="l01062"></a>01062 <span class="keywordtype">bool</span>
<a name="l01063"></a>01063 EarthManipulator::intersect(<span class="keyword">const</span> osg::Vec3d&amp; start, <span class="keyword">const</span> osg::Vec3d&amp; end, osg::Vec3d&amp; intersection)<span class="keyword"> const</span>
<a name="l01064"></a>01064 <span class="keyword"></span>{
<a name="l01065"></a>01065     osg::ref_ptr&lt;osg::Node&gt; safeNode = _node.get();
<a name="l01066"></a>01066     <span class="keywordflow">if</span> ( safeNode.valid() )
<a name="l01067"></a>01067     {
<a name="l01068"></a>01068         osg::ref_ptr&lt;osgUtil::LineSegmentIntersector&gt; lsi = <span class="keyword">new</span> osgUtil::LineSegmentIntersector(start,end);
<a name="l01069"></a>01069 
<a name="l01070"></a>01070         osgUtil::IntersectionVisitor iv(lsi.get());
<a name="l01071"></a>01071         iv.setTraversalMask(_intersectTraversalMask);
<a name="l01072"></a>01072 
<a name="l01073"></a>01073         safeNode-&gt;accept(iv);
<a name="l01074"></a>01074 
<a name="l01075"></a>01075         <span class="keywordflow">if</span> (lsi-&gt;containsIntersections())
<a name="l01076"></a>01076         {
<a name="l01077"></a>01077             intersection = lsi-&gt;getIntersections().begin()-&gt;getWorldIntersectPoint();
<a name="l01078"></a>01078             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01079"></a>01079         }
<a name="l01080"></a>01080     }
<a name="l01081"></a>01081     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01082"></a>01082 }
<a name="l01083"></a>01083 
<a name="l01084"></a>01084 <span class="keywordtype">void</span>
<a name="l01085"></a>01085 EarthManipulator::home(<span class="keyword">const</span> osgGA::GUIEventAdapter&amp; ,osgGA::GUIActionAdapter&amp; us)
<a name="l01086"></a>01086 {
<a name="l01087"></a>01087     handleAction( ACTION_HOME, 0, 0, 0 );
<a name="l01088"></a>01088     <span class="comment">//if (getAutoComputeHomePosition()) computeHomePosition();</span>
<a name="l01089"></a>01089     <span class="comment">//setByLookAt(_homeEye, _homeCenter, _homeUp);</span>
<a name="l01090"></a>01090     us.requestRedraw();
<a name="l01091"></a>01091 }
<a name="l01092"></a>01092 
<a name="l01093"></a>01093 <span class="keywordtype">void</span>
<a name="l01094"></a>01094 EarthManipulator::computeHomePosition()
<a name="l01095"></a>01095 {    
<a name="l01096"></a>01096     <span class="keywordflow">if</span>( getNode() )
<a name="l01097"></a>01097     {
<a name="l01098"></a>01098         <span class="keyword">const</span> osg::BoundingSphere&amp; boundingSphere = getNode()-&gt;getBound();
<a name="l01099"></a>01099 
<a name="l01100"></a>01100         osg::Vec3d eye =
<a name="l01101"></a>01101             boundingSphere._center +
<a name="l01102"></a>01102             osg::Vec3( 0.0, -3.5f * boundingSphere._radius, boundingSphere._radius * 0.0001 );
<a name="l01103"></a>01103 
<a name="l01104"></a>01104         setHomePosition(
<a name="l01105"></a>01105             eye,
<a name="l01106"></a>01106             boundingSphere._center,
<a name="l01107"></a>01107             osg::Vec3d( 0, 0, 1 ),
<a name="l01108"></a>01108             _autoComputeHomePosition );
<a name="l01109"></a>01109     }
<a name="l01110"></a>01110 }
<a name="l01111"></a>01111 
<a name="l01112"></a>01112 <span class="keywordtype">void</span>
<a name="l01113"></a>01113 EarthManipulator::init(<span class="keyword">const</span> osgGA::GUIEventAdapter&amp;, osgGA::GUIActionAdapter&amp; )
<a name="l01114"></a>01114 {
<a name="l01115"></a>01115     flushMouseEventStack();
<a name="l01116"></a>01116 }
<a name="l01117"></a>01117 
<a name="l01118"></a>01118 
<a name="l01119"></a>01119 <span class="keywordtype">void</span>
<a name="l01120"></a>01120 EarthManipulator::getUsage(osg::ApplicationUsage&amp; <a class="code" href="osgearth__annotation_8cpp.html#a0c2ae8a349dcb4ee981a199a687bf549">usage</a>)<span class="keyword"> const</span>
<a name="l01121"></a>01121 <span class="keyword"></span>{
<a name="l01122"></a>01122 }
<a name="l01123"></a>01123 
<a name="l01124"></a>01124 <span class="keywordtype">void</span>
<a name="l01125"></a>01125 EarthManipulator::resetMouse( osgGA::GUIActionAdapter&amp; aa )
<a name="l01126"></a>01126 {
<a name="l01127"></a>01127     flushMouseEventStack();
<a name="l01128"></a>01128     aa.requestContinuousUpdate( <span class="keyword">false</span> );
<a name="l01129"></a>01129     _thrown = <span class="keyword">false</span>;
<a name="l01130"></a>01130     _continuous = <span class="keyword">false</span>;
<a name="l01131"></a>01131     _single_axis_x = 1.0;
<a name="l01132"></a>01132     _single_axis_y = 1.0;
<a name="l01133"></a>01133     _lastPointOnEarth.set(0.0, 0.0, 0.0);
<a name="l01134"></a>01134 }
<a name="l01135"></a>01135 
<a name="l01136"></a>01136 <span class="comment">// this method will automatically install or uninstall the camera post-update callback </span>
<a name="l01137"></a>01137 <span class="comment">// depending on whether there&#39;s a tether node.</span>
<a name="l01138"></a>01138 <span class="comment">//</span>
<a name="l01139"></a>01139 <span class="comment">// Camera updates get called AFTER the scene gets its update traversal. So, if you have</span>
<a name="l01140"></a>01140 <span class="comment">// tethering enabled (or some other feature that tracks scene graph nodes), this will</span>
<a name="l01141"></a>01141 <span class="comment">// update the camera after the scene graph. This is important in order to maintain</span>
<a name="l01142"></a>01142 <span class="comment">// frame coherency and prevent &quot;jitter&quot;.</span>
<a name="l01143"></a>01143 <span class="comment">//</span>
<a name="l01144"></a>01144 <span class="comment">// The reason we install/uninstall instead of just leaving it there is so we can</span>
<a name="l01145"></a>01145 <span class="comment">// support OSG&#39;s &quot;ON_DEMAND&quot; frame scheme, which disables itself is there are any</span>
<a name="l01146"></a>01146 <span class="comment">// update callbacks in the scene graph.</span>
<a name="l01147"></a>01147 <span class="keywordtype">void</span>
<a name="l01148"></a>01148 EarthManipulator::updateCamera( osg::Camera* eventCamera )
<a name="l01149"></a>01149 {
<a name="l01150"></a>01150     <span class="comment">// check to see if the camera has changed, and update the callback if necessary</span>
<a name="l01151"></a>01151     <span class="keywordflow">if</span> ( _viewCamera.get() != eventCamera )
<a name="l01152"></a>01152     {
<a name="l01153"></a>01153         <span class="keywordflow">if</span> ( _cameraUpdateCB.valid() )
<a name="l01154"></a>01154             _viewCamera-&gt;removeUpdateCallback( _cameraUpdateCB.get() );
<a name="l01155"></a>01155 
<a name="l01156"></a>01156         _viewCamera = eventCamera;
<a name="l01157"></a>01157         <span class="keywordflow">if</span> ( _cameraUpdateCB.valid() )
<a name="l01158"></a>01158             _viewCamera-&gt;addUpdateCallback( _cameraUpdateCB.get() );
<a name="l01159"></a>01159     }
<a name="l01160"></a>01160 
<a name="l01161"></a>01161     <span class="comment">// check to see if we need to install a new camera callback:</span>
<a name="l01162"></a>01162     <span class="keywordflow">if</span> ( _tether_node.valid() &amp;&amp; !_cameraUpdateCB.valid() )
<a name="l01163"></a>01163     {
<a name="l01164"></a>01164         _cameraUpdateCB = <span class="keyword">new</span> CameraPostUpdateCallback(<span class="keyword">this</span>);
<a name="l01165"></a>01165         _viewCamera-&gt;addUpdateCallback( _cameraUpdateCB.get() );
<a name="l01166"></a>01166     }
<a name="l01167"></a>01167     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( !_tether_node.valid() &amp;&amp; _cameraUpdateCB.valid() )
<a name="l01168"></a>01168     {
<a name="l01169"></a>01169         _viewCamera-&gt;removeUpdateCallback( _cameraUpdateCB.get() );
<a name="l01170"></a>01170         _cameraUpdateCB = 0L;
<a name="l01171"></a>01171     }
<a name="l01172"></a>01172 }
<a name="l01173"></a>01173 
<a name="l01174"></a>01174 <span class="keywordtype">bool</span>
<a name="l01175"></a>01175 EarthManipulator::handle(<span class="keyword">const</span> osgGA::GUIEventAdapter&amp; ea, osgGA::GUIActionAdapter&amp; aa)
<a name="l01176"></a>01176 {
<a name="l01177"></a>01177     <span class="keywordtype">bool</span> handled = <span class="keyword">false</span>;
<a name="l01178"></a>01178     
<a name="l01179"></a>01179     <span class="comment">// first order of business: make sure the CSN is established.</span>
<a name="l01180"></a>01180     <span class="keywordflow">if</span> ( !established() )
<a name="l01181"></a>01181         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01182"></a>01182 
<a name="l01183"></a>01183     <span class="comment">// make sure the camera callback is up to date:</span>
<a name="l01184"></a>01184     updateCamera( aa.asView()-&gt;getCamera() );
<a name="l01185"></a>01185 
<a name="l01186"></a>01186     <span class="keywordflow">if</span> ( ea.getEventType() == osgGA::GUIEventAdapter::FRAME )
<a name="l01187"></a>01187     {
<a name="l01188"></a>01188         _time_s_last_frame = _time_s_now;
<a name="l01189"></a>01189         _time_s_now = osg::Timer::instance()-&gt;time_s();
<a name="l01190"></a>01190         _delta_t = _time_s_now - _time_s_last_frame;
<a name="l01191"></a>01191         <span class="comment">// this factor adjusts for the variation of frame rate relative to 60fps</span>
<a name="l01192"></a>01192         _t_factor = _delta_t / 0.01666666666;
<a name="l01193"></a>01193 
<a name="l01194"></a>01194         <span class="comment">//OE_NOTICE</span>
<a name="l01195"></a>01195         <span class="comment">//    &lt;&lt; &quot;center=(&quot; &lt;&lt; _center.x() &lt;&lt; &quot;,&quot; &lt;&lt; _center.y() &lt;&lt; &quot;,&quot; &lt;&lt; _center.z() &lt;&lt; &quot;)&quot;</span>
<a name="l01196"></a>01196         <span class="comment">//    &lt;&lt; &quot;, dist=&quot; &lt;&lt; _distance</span>
<a name="l01197"></a>01197         <span class="comment">//    &lt;&lt; &quot;, p=&quot; &lt;&lt; _local_pitch</span>
<a name="l01198"></a>01198         <span class="comment">//    &lt;&lt; &quot;, h=&quot; &lt;&lt; _local_azim</span>
<a name="l01199"></a>01199         <span class="comment">//    &lt;&lt; std::endl;</span>
<a name="l01200"></a>01200 
<a name="l01201"></a>01201         <span class="keywordflow">if</span> ( _has_pending_viewpoint &amp;&amp; _node.valid() )
<a name="l01202"></a>01202         {
<a name="l01203"></a>01203             _has_pending_viewpoint = <span class="keyword">false</span>;
<a name="l01204"></a>01204             setViewpoint( _pending_viewpoint, _pending_viewpoint_duration_s );
<a name="l01205"></a>01205             aa.requestRedraw();
<a name="l01206"></a>01206         }
<a name="l01207"></a>01207 
<a name="l01208"></a>01208         <span class="keywordflow">if</span> ( _setting_viewpoint )
<a name="l01209"></a>01209         {
<a name="l01210"></a>01210             updateSetViewpoint();
<a name="l01211"></a>01211             aa.requestRedraw();
<a name="l01212"></a>01212         }
<a name="l01213"></a>01213 
<a name="l01214"></a>01214         <span class="keywordflow">if</span> ( _thrown || _continuous )
<a name="l01215"></a>01215         {
<a name="l01216"></a>01216             handleContinuousAction( _last_action, aa.asView() );
<a name="l01217"></a>01217             aa.requestRedraw();
<a name="l01218"></a>01218         }
<a name="l01219"></a>01219 
<a name="l01220"></a>01220         <span class="keywordflow">if</span> ( !_continuous )
<a name="l01221"></a>01221         {
<a name="l01222"></a>01222             _continuous_dx = 0.0;
<a name="l01223"></a>01223             _continuous_dy = 0.0;
<a name="l01224"></a>01224         }
<a name="l01225"></a>01225         
<a name="l01226"></a>01226         <span class="keywordflow">if</span> ( _task.valid() )
<a name="l01227"></a>01227         {
<a name="l01228"></a>01228             <span class="keywordflow">if</span> ( serviceTask() )
<a name="l01229"></a>01229                 aa.requestRedraw();
<a name="l01230"></a>01230         }
<a name="l01231"></a>01231 
<a name="l01232"></a>01232         _after_first_frame = <span class="keyword">true</span>;
<a name="l01233"></a>01233 
<a name="l01234"></a>01234         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01235"></a>01235     }
<a name="l01236"></a>01236 
<a name="l01237"></a>01237     <span class="comment">// the camera manipulator runs last after any other event handlers. So bail out</span>
<a name="l01238"></a>01238     <span class="comment">// if the incoming event has already been handled by another handler.</span>
<a name="l01239"></a>01239     <span class="keywordflow">if</span> ( ea.getHandled() )
<a name="l01240"></a>01240     {
<a name="l01241"></a>01241         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01242"></a>01242     }
<a name="l01243"></a>01243    
<a name="l01244"></a>01244     <span class="comment">// form the current Action based on the event type:</span>
<a name="l01245"></a>01245     Action action = ACTION_NULL;
<a name="l01246"></a>01246 
<a name="l01247"></a>01247     <span class="keywordflow">switch</span>( ea.getEventType() )
<a name="l01248"></a>01248     {
<a name="l01249"></a>01249         <span class="keywordflow">case</span> osgGA::GUIEventAdapter::PUSH:
<a name="l01250"></a>01250             resetMouse( aa );
<a name="l01251"></a>01251             addMouseEvent( ea );
<a name="l01252"></a>01252             _mouse_down_event = &amp;ea;
<a name="l01253"></a>01253             aa.requestRedraw();
<a name="l01254"></a>01254             handled = <span class="keyword">true</span>;
<a name="l01255"></a>01255             <span class="keywordflow">break</span>;       
<a name="l01256"></a>01256         
<a name="l01257"></a>01257         <span class="keywordflow">case</span> osgGA::GUIEventAdapter::RELEASE:
<a name="l01258"></a>01258 
<a name="l01259"></a>01259             <span class="keywordflow">if</span> ( _continuous )
<a name="l01260"></a>01260             {
<a name="l01261"></a>01261                 <span class="comment">// bail out of continuous mode if necessary:</span>
<a name="l01262"></a>01262                 _continuous = <span class="keyword">false</span>;
<a name="l01263"></a>01263             }
<a name="l01264"></a>01264             <span class="keywordflow">else</span>
<a name="l01265"></a>01265             {
<a name="l01266"></a>01266                 <span class="comment">// check for a mouse-throw continuation:</span>
<a name="l01267"></a>01267                 <span class="keywordflow">if</span> ( _settings-&gt;getThrowingEnabled() &amp;&amp; isMouseMoving() )
<a name="l01268"></a>01268                 {
<a name="l01269"></a>01269                     action = _last_action;
<a name="l01270"></a>01270                     <span class="keywordflow">if</span>( handleMouseAction( action, aa.asView() ) )
<a name="l01271"></a>01271                     {
<a name="l01272"></a>01272                         aa.requestRedraw();
<a name="l01273"></a>01273                         aa.requestContinuousUpdate( <span class="keyword">true</span> );
<a name="l01274"></a>01274                         _thrown = <span class="keyword">true</span>;
<a name="l01275"></a>01275                     }
<a name="l01276"></a>01276                 }
<a name="l01277"></a>01277                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( isMouseClick( &amp;ea ) )
<a name="l01278"></a>01278                 {
<a name="l01279"></a>01279                     addMouseEvent( ea );
<a name="l01280"></a>01280                     <span class="keywordflow">if</span> ( _mouse_down_event )
<a name="l01281"></a>01281                     {
<a name="l01282"></a>01282                         action = _settings-&gt;getAction( EVENT_MOUSE_CLICK, _mouse_down_event-&gt;getButtonMask(), _mouse_down_event-&gt;getModKeyMask() );
<a name="l01283"></a>01283                         <span class="keywordflow">if</span> ( handlePointAction( action, ea.getX(), ea.getY(), aa.asView() ))
<a name="l01284"></a>01284                             aa.requestRedraw();                
<a name="l01285"></a>01285                     }
<a name="l01286"></a>01286                     resetMouse( aa );
<a name="l01287"></a>01287                 }
<a name="l01288"></a>01288                 <span class="keywordflow">else</span>
<a name="l01289"></a>01289                 {
<a name="l01290"></a>01290                     resetMouse( aa );
<a name="l01291"></a>01291                     addMouseEvent( ea );
<a name="l01292"></a>01292                 }
<a name="l01293"></a>01293             }
<a name="l01294"></a>01294             handled = <span class="keyword">true</span>;
<a name="l01295"></a>01295             <span class="keywordflow">break</span>;
<a name="l01296"></a>01296             
<a name="l01297"></a>01297         <span class="keywordflow">case</span> osgGA::GUIEventAdapter::DOUBLECLICK:
<a name="l01298"></a>01298             <span class="comment">// bail out of continuous mode if necessary:</span>
<a name="l01299"></a>01299             _continuous = <span class="keyword">false</span>;
<a name="l01300"></a>01300 
<a name="l01301"></a>01301             addMouseEvent( ea );
<a name="l01302"></a>01302                         <span class="keywordflow">if</span> (_mouse_down_event)
<a name="l01303"></a>01303                         {
<a name="l01304"></a>01304                                 action = _settings-&gt;getAction( EVENT_MOUSE_DOUBLE_CLICK, _mouse_down_event-&gt;getButtonMask(), _mouse_down_event-&gt;getModKeyMask() );
<a name="l01305"></a>01305                                 <span class="keywordflow">if</span> ( handlePointAction( action, ea.getX(), ea.getY(), aa.asView() ) )
<a name="l01306"></a>01306                                         aa.requestRedraw();
<a name="l01307"></a>01307                                 resetMouse( aa );
<a name="l01308"></a>01308                                 handled = <span class="keyword">true</span>;
<a name="l01309"></a>01309                         }
<a name="l01310"></a>01310             <span class="keywordflow">break</span>;
<a name="l01311"></a>01311 
<a name="l01312"></a>01312         <span class="keywordflow">case</span> osgGA::GUIEventAdapter::MOVE: <span class="comment">// MOVE not currently bindable</span>
<a name="l01313"></a>01313             <span class="comment">//NOP</span>
<a name="l01314"></a>01314             <span class="keywordflow">break</span>;
<a name="l01315"></a>01315 
<a name="l01316"></a>01316         <span class="keywordflow">case</span> osgGA::GUIEventAdapter::DRAG:
<a name="l01317"></a>01317             {
<a name="l01318"></a>01318                 action = _settings-&gt;getAction( ea.getEventType(), ea.getButtonMask(), ea.getModKeyMask() );
<a name="l01319"></a>01319                 addMouseEvent( ea );
<a name="l01320"></a>01320                 _continuous = action.getBoolOption(OPTION_CONTINUOUS, <span class="keyword">false</span>);
<a name="l01321"></a>01321                 <span class="keywordflow">if</span> ( handleMouseAction( action, aa.asView() ) )
<a name="l01322"></a>01322                     aa.requestRedraw();
<a name="l01323"></a>01323                 aa.requestContinuousUpdate(<span class="keyword">false</span>);
<a name="l01324"></a>01324                 _thrown = <span class="keyword">false</span>;
<a name="l01325"></a>01325                 handled = <span class="keyword">true</span>;
<a name="l01326"></a>01326             }
<a name="l01327"></a>01327             <span class="keywordflow">break</span>;
<a name="l01328"></a>01328 
<a name="l01329"></a>01329         <span class="keywordflow">case</span> osgGA::GUIEventAdapter::KEYDOWN:
<a name="l01330"></a>01330             <span class="keywordflow">if</span> ( ea.getKey() &lt; osgGA::GUIEventAdapter::KEY_Shift_L )
<a name="l01331"></a>01331             {
<a name="l01332"></a>01332                 resetMouse( aa );
<a name="l01333"></a>01333                 action = _settings-&gt;getAction( ea.getEventType(), ea.getKey(), ea.getModKeyMask() );
<a name="l01334"></a>01334                 <span class="keywordflow">if</span> ( handleKeyboardAction( action ) )
<a name="l01335"></a>01335                     aa.requestRedraw();
<a name="l01336"></a>01336                 handled = <span class="keyword">true</span>;
<a name="l01337"></a>01337             }
<a name="l01338"></a>01338             <span class="keywordflow">break</span>;
<a name="l01339"></a>01339             
<a name="l01340"></a>01340         <span class="keywordflow">case</span> osgGA::GUIEventAdapter::KEYUP:
<a name="l01341"></a>01341             resetMouse( aa );
<a name="l01342"></a>01342             _task-&gt;_type = TASK_NONE;
<a name="l01343"></a>01343             handled = <span class="keyword">true</span>;
<a name="l01344"></a>01344             <span class="keywordflow">break</span>;
<a name="l01345"></a>01345 
<a name="l01346"></a>01346         <span class="keywordflow">case</span> osgGA::GUIEventAdapter::SCROLL:
<a name="l01347"></a>01347             resetMouse( aa );
<a name="l01348"></a>01348             addMouseEvent( ea );
<a name="l01349"></a>01349             action = _settings-&gt;getAction( ea.getEventType(), ea.getScrollingMotion(), ea.getModKeyMask() );
<a name="l01350"></a>01350             <span class="keywordflow">if</span> ( handleScrollAction( action, 0.2 ) )
<a name="l01351"></a>01351                 aa.requestRedraw();
<a name="l01352"></a>01352             handled = <span class="keyword">true</span>;
<a name="l01353"></a>01353             <span class="keywordflow">break</span>;
<a name="l01354"></a>01354     }
<a name="l01355"></a>01355 
<a name="l01356"></a>01356     <span class="keywordflow">if</span> ( handled &amp;&amp; action._type != ACTION_NULL )
<a name="l01357"></a>01357         _last_action = action;
<a name="l01358"></a>01358 
<a name="l01359"></a>01359     <span class="keywordflow">return</span> handled;
<a name="l01360"></a>01360 }
<a name="l01361"></a>01361 
<a name="l01362"></a>01362 <span class="keywordtype">void</span>
<a name="l01363"></a>01363 EarthManipulator::postUpdate()
<a name="l01364"></a>01364 {
<a name="l01365"></a>01365     updateTether();
<a name="l01366"></a>01366 }
<a name="l01367"></a>01367 
<a name="l01368"></a>01368 <span class="keywordtype">void</span>
<a name="l01369"></a>01369 EarthManipulator::updateTether()
<a name="l01370"></a>01370 {
<a name="l01371"></a>01371     <span class="comment">// capture a temporary ref since _tether_node is just an observer:</span>
<a name="l01372"></a>01372     osg::ref_ptr&lt;osg::Node&gt; temp = _tether_node.get();
<a name="l01373"></a>01373     <span class="keywordflow">if</span> ( temp.valid() )
<a name="l01374"></a>01374     {
<a name="l01375"></a>01375 
<a name="l01376"></a>01376                 osg::NodePathList nodePaths = temp-&gt;getParentalNodePaths();
<a name="l01377"></a>01377         <span class="keywordflow">if</span> ( nodePaths.empty() )
<a name="l01378"></a>01378             <span class="keywordflow">return</span>;
<a name="l01379"></a>01379         osg::NodePath path = nodePaths[0];
<a name="l01380"></a>01380 
<a name="l01381"></a>01381         osg::Matrixd localToWorld = osg::computeLocalToWorld( path );
<a name="l01382"></a>01382         _center = osg::Vec3d(0,0,0) * localToWorld;
<a name="l01383"></a>01383 
<a name="l01384"></a>01384         <span class="comment">// if the tether node is a MT, we are set. If it&#39;s not, we need to get the</span>
<a name="l01385"></a>01385         <span class="comment">// local bound and add its translation to the localToWorld. We cannot just use</span>
<a name="l01386"></a>01386         <span class="comment">// the bounds directly because they are single precision (unless you built OSG</span>
<a name="l01387"></a>01387         <span class="comment">// with double-precision bounding spheres, which you probably did not :)</span>
<a name="l01388"></a>01388         <span class="keywordflow">if</span> ( !dynamic_cast&lt;osg::MatrixTransform*&gt;( temp.get() ) )
<a name="l01389"></a>01389         {
<a name="l01390"></a>01390             <span class="keyword">const</span> osg::BoundingSphere&amp; bs = temp-&gt;getBound();
<a name="l01391"></a>01391             _center += bs.center();
<a name="l01392"></a>01392         }
<a name="l01393"></a>01393 
<a name="l01394"></a>01394         <span class="comment">//OE_INFO</span>
<a name="l01395"></a>01395         <span class="comment">//    &lt;&lt; std::fixed &lt;&lt; std::setprecision(3)</span>
<a name="l01396"></a>01396         <span class="comment">//    &lt;&lt; &quot;Tether center: (&quot; &lt;&lt; _center.x() &lt;&lt; &quot;,&quot; &lt;&lt; _center.y() &lt;&lt; &quot;,&quot; &lt;&lt; _center.z()</span>
<a name="l01397"></a>01397         <span class="comment">//    &lt;&lt; &quot;); bbox center: (&quot; &lt;&lt; bs.center().x() &lt;&lt; &quot;,&quot; &lt;&lt; bs.center().y() &lt;&lt; &quot;,&quot; &lt;&lt; bs.center().z() &lt;&lt; &quot;)&quot;</span>
<a name="l01398"></a>01398         <span class="comment">//    &lt;&lt; std::endl;</span>
<a name="l01399"></a>01399 
<a name="l01400"></a>01400                 osg::CoordinateFrame local_frame = getMyCoordinateFrame( _center ); <span class="comment">//getCoordinateFrame( _center );</span>
<a name="l01401"></a>01401             _previousUp = getUpVector( local_frame );
<a name="l01402"></a>01402 
<a name="l01403"></a>01403 <span class="comment">//                      osg::Matrixd localToWorld = osg::computeLocalToWorld( path );</span>
<a name="l01404"></a>01404                 <span class="keywordtype">double</span> sx = 1.0/sqrt(localToWorld(0,0)*localToWorld(0,0) + localToWorld(1,0)*localToWorld(1,0) + localToWorld(2,0)*localToWorld(2,0));
<a name="l01405"></a>01405                 <span class="keywordtype">double</span> sy = 1.0/sqrt(localToWorld(0,1)*localToWorld(0,1) + localToWorld(1,1)*localToWorld(1,1) + localToWorld(2,1)*localToWorld(2,1));
<a name="l01406"></a>01406                 <span class="keywordtype">double</span> sz = 1.0/sqrt(localToWorld(0,2)*localToWorld(0,2) + localToWorld(1,2)*localToWorld(1,2) + localToWorld(2,2)*localToWorld(2,2));
<a name="l01407"></a>01407                 localToWorld = localToWorld*osg::Matrixd::scale(sx,sy,sz);
<a name="l01408"></a>01408 
<a name="l01409"></a>01409         <span class="comment">// didn&#39;t we just call this a few lines ago?</span>
<a name="l01410"></a>01410             <span class="comment">//osg::CoordinateFrame coordinateFrame = getMyCoordinateFrame( _center ); //getCoordinateFrame(_center);</span>
<a name="l01411"></a>01411 
<a name="l01412"></a>01412                 <span class="comment">//Just track the center</span>
<a name="l01413"></a>01413                 <span class="keywordflow">if</span> (_settings-&gt;getTetherMode() == TETHER_CENTER)
<a name="l01414"></a>01414                 {
<a name="l01415"></a>01415                         _centerRotation = local_frame.getRotate(); <span class="comment">//coordinateFrame.getRotate();</span>
<a name="l01416"></a>01416                 }
<a name="l01417"></a>01417                 <span class="comment">//Track all rotations</span>
<a name="l01418"></a>01418                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_settings-&gt;getTetherMode() == TETHER_CENTER_AND_ROTATION)
<a name="l01419"></a>01419                 {
<a name="l01420"></a>01420                   _centerRotation = localToWorld.getRotate();
<a name="l01421"></a>01421                 }
<a name="l01422"></a>01422                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_settings-&gt;getTetherMode() == TETHER_CENTER_AND_HEADING)
<a name="l01423"></a>01423                 {
<a name="l01424"></a>01424                         <span class="comment">//Track just the heading</span>
<a name="l01425"></a>01425                         osg::Matrixd localToFrame(localToWorld*osg::Matrixd::inverse( local_frame )); <span class="comment">//coordinateFrame));</span>
<a name="l01426"></a>01426                         <span class="keywordtype">double</span> azim = atan2(-localToFrame(0,1),localToFrame(0,0));
<a name="l01427"></a>01427                         osg::Quat nodeRotationRelToFrame, rotationOfFrame;
<a name="l01428"></a>01428                         nodeRotationRelToFrame.makeRotate(-azim,0.0,0.0,1.0);
<a name="l01429"></a>01429                         rotationOfFrame = local_frame.getRotate(); <span class="comment">//coordinateFrame.getRotate();</span>
<a name="l01430"></a>01430                         _centerRotation = nodeRotationRelToFrame*rotationOfFrame;
<a name="l01431"></a>01431                 }
<a name="l01432"></a>01432     }
<a name="l01433"></a>01433 }
<a name="l01434"></a>01434 
<a name="l01435"></a>01435 <span class="keywordtype">bool</span>
<a name="l01436"></a>01436 EarthManipulator::serviceTask()
<a name="l01437"></a>01437 {
<a name="l01438"></a>01438     <span class="keywordtype">bool</span> result;
<a name="l01439"></a>01439 
<a name="l01440"></a>01440     <span class="keywordflow">if</span> ( _task.valid() &amp;&amp; _task-&gt;_type != TASK_NONE )
<a name="l01441"></a>01441     {
<a name="l01442"></a>01442         <span class="keywordflow">switch</span>( _task-&gt;_type )
<a name="l01443"></a>01443         {
<a name="l01444"></a>01444             <span class="keywordflow">case</span> TASK_PAN:
<a name="l01445"></a>01445                 pan( _delta_t * _task-&gt;_dx, _delta_t * _task-&gt;_dy );
<a name="l01446"></a>01446                 <span class="keywordflow">break</span>;
<a name="l01447"></a>01447             <span class="keywordflow">case</span> TASK_ROTATE:
<a name="l01448"></a>01448                 rotate( _delta_t * _task-&gt;_dx, _delta_t * _task-&gt;_dy );
<a name="l01449"></a>01449                 <span class="keywordflow">break</span>;
<a name="l01450"></a>01450             <span class="keywordflow">case</span> TASK_ZOOM:
<a name="l01451"></a>01451                 zoom( _delta_t * _task-&gt;_dx, _delta_t * _task-&gt;_dy );
<a name="l01452"></a>01452                 <span class="keywordflow">break</span>;
<a name="l01453"></a>01453             <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
<a name="l01454"></a>01454         }
<a name="l01455"></a>01455 
<a name="l01456"></a>01456         _task-&gt;_duration_s -= _delta_t;
<a name="l01457"></a>01457         <span class="keywordflow">if</span> ( _task-&gt;_duration_s &lt;= 0.0 )
<a name="l01458"></a>01458             _task-&gt;_type = TASK_NONE;
<a name="l01459"></a>01459 
<a name="l01460"></a>01460         result = <span class="keyword">true</span>;
<a name="l01461"></a>01461     }
<a name="l01462"></a>01462     <span class="keywordflow">else</span>
<a name="l01463"></a>01463     {
<a name="l01464"></a>01464         result = <span class="keyword">false</span>;
<a name="l01465"></a>01465     }
<a name="l01466"></a>01466 
<a name="l01467"></a>01467     <span class="comment">//_time_last_frame = now;</span>
<a name="l01468"></a>01468     <span class="keywordflow">return</span> result;
<a name="l01469"></a>01469 }
<a name="l01470"></a>01470 
<a name="l01471"></a>01471 <span class="keywordtype">bool</span>
<a name="l01472"></a>01472 EarthManipulator::isMouseMoving()
<a name="l01473"></a>01473 {
<a name="l01474"></a>01474     <span class="keywordflow">if</span> (_ga_t0.get()==NULL || _ga_t1.get()==NULL) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01475"></a>01475 
<a name="l01476"></a>01476     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">float</span> velocity = 0.1f;
<a name="l01477"></a>01477 
<a name="l01478"></a>01478     <span class="keywordtype">float</span> dx = _ga_t0-&gt;getXnormalized()-_ga_t1-&gt;getXnormalized();
<a name="l01479"></a>01479     <span class="keywordtype">float</span> dy = _ga_t0-&gt;getYnormalized()-_ga_t1-&gt;getYnormalized();
<a name="l01480"></a>01480     <span class="keywordtype">float</span> len = sqrtf(dx*dx+dy*dy);
<a name="l01481"></a>01481     <span class="comment">//float dt = _ga_t0-&gt;getTime()-_ga_t1-&gt;getTime();</span>
<a name="l01482"></a>01482 
<a name="l01483"></a>01483     <span class="keywordflow">return</span> len &gt; _delta_t * velocity;
<a name="l01484"></a>01484 }
<a name="l01485"></a>01485 
<a name="l01486"></a>01486 <span class="keywordtype">bool</span>
<a name="l01487"></a>01487 EarthManipulator::isMouseClick( <span class="keyword">const</span> osgGA::GUIEventAdapter* mouse_up_event )<span class="keyword"> const</span>
<a name="l01488"></a>01488 <span class="keyword"></span>{
<a name="l01489"></a>01489     <span class="keywordflow">if</span> ( mouse_up_event == NULL || _mouse_down_event == NULL ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01490"></a>01490 
<a name="l01491"></a>01491     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">float</span> velocity = 0.1f;
<a name="l01492"></a>01492 
<a name="l01493"></a>01493     <span class="keywordtype">float</span> dx = mouse_up_event-&gt;getXnormalized() - _mouse_down_event-&gt;getXnormalized();
<a name="l01494"></a>01494     <span class="keywordtype">float</span> dy = mouse_up_event-&gt;getYnormalized() - _mouse_down_event-&gt;getYnormalized();
<a name="l01495"></a>01495     <span class="keywordtype">float</span> len = sqrtf( dx*dx + dy*dy );
<a name="l01496"></a>01496     <span class="keywordtype">float</span> dt = mouse_up_event-&gt;getTime( ) - _mouse_down_event-&gt;getTime();
<a name="l01497"></a>01497 
<a name="l01498"></a>01498     <span class="keywordflow">return</span> len &lt; dt * velocity;
<a name="l01499"></a>01499 }
<a name="l01500"></a>01500 
<a name="l01501"></a>01501 <span class="keywordtype">void</span>
<a name="l01502"></a>01502 EarthManipulator::flushMouseEventStack()
<a name="l01503"></a>01503 {
<a name="l01504"></a>01504     _ga_t1 = NULL;
<a name="l01505"></a>01505     _ga_t0 = NULL;
<a name="l01506"></a>01506 }
<a name="l01507"></a>01507 
<a name="l01508"></a>01508 
<a name="l01509"></a>01509 <span class="keywordtype">void</span>
<a name="l01510"></a>01510 EarthManipulator::addMouseEvent(<span class="keyword">const</span> osgGA::GUIEventAdapter&amp; ea)
<a name="l01511"></a>01511 {
<a name="l01512"></a>01512     _ga_t1 = _ga_t0;
<a name="l01513"></a>01513     _ga_t0 = &amp;ea;
<a name="l01514"></a>01514 }
<a name="l01515"></a>01515 
<a name="l01516"></a>01516 <span class="keywordtype">void</span>
<a name="l01517"></a>01517 EarthManipulator::setByMatrix(<span class="keyword">const</span> osg::Matrixd&amp; matrix)
<a name="l01518"></a>01518 {
<a name="l01519"></a>01519     osg::Vec3d lookVector(- matrix(2,0),-matrix(2,1),-matrix(2,2));
<a name="l01520"></a>01520     osg::Vec3d eye(matrix(3,0),matrix(3,1),matrix(3,2));
<a name="l01521"></a>01521 
<a name="l01522"></a>01522     _centerRotation = makeCenterRotation(_center);
<a name="l01523"></a>01523 
<a name="l01524"></a>01524     osg::ref_ptr&lt;osg::Node&gt; safeNode = _node.get();
<a name="l01525"></a>01525 
<a name="l01526"></a>01526     <span class="keywordflow">if</span> ( !safeNode.valid() )
<a name="l01527"></a>01527     {
<a name="l01528"></a>01528         _center = eye + lookVector;
<a name="l01529"></a>01529         setDistance( lookVector.length() );
<a name="l01530"></a>01530         _rotation = matrix.getRotate().inverse() * _centerRotation.inverse();   
<a name="l01531"></a>01531         <span class="keywordflow">return</span>;
<a name="l01532"></a>01532     }
<a name="l01533"></a>01533 
<a name="l01534"></a>01534     <span class="comment">// need to reintersect with the terrain</span>
<a name="l01535"></a>01535     <span class="keyword">const</span> osg::BoundingSphere&amp; bs = safeNode-&gt;getBound();
<a name="l01536"></a>01536     <span class="keywordtype">float</span> distance = (eye-bs.center()).length() + safeNode-&gt;getBound().radius();
<a name="l01537"></a>01537     osg::Vec3d start_segment = eye;
<a name="l01538"></a>01538     osg::Vec3d end_segment = eye + lookVector*distance;
<a name="l01539"></a>01539     
<a name="l01540"></a>01540     osg::Vec3d ip;
<a name="l01541"></a>01541     <span class="keywordtype">bool</span> hitFound = <span class="keyword">false</span>;
<a name="l01542"></a>01542     <span class="keywordflow">if</span> (intersect(start_segment, end_segment, ip))
<a name="l01543"></a>01543     {
<a name="l01544"></a>01544         _center = ip;
<a name="l01545"></a>01545         _centerRotation = makeCenterRotation(_center);
<a name="l01546"></a>01546         setDistance( (eye-ip).length());
<a name="l01547"></a>01547 
<a name="l01548"></a>01548         osg::Matrixd rotation_matrix = osg::Matrixd::translate(0.0,0.0,-_distance)*
<a name="l01549"></a>01549                                        matrix*
<a name="l01550"></a>01550                                        osg::Matrixd::translate(-_center);
<a name="l01551"></a>01551         _rotation = rotation_matrix.getRotate() * _centerRotation.inverse();
<a name="l01552"></a>01552         hitFound = <span class="keyword">true</span>;
<a name="l01553"></a>01553     }
<a name="l01554"></a>01554 
<a name="l01555"></a>01555     <span class="keywordflow">if</span> (!hitFound)
<a name="l01556"></a>01556     {
<a name="l01557"></a>01557         osg::CoordinateFrame eyePointCoordFrame = getMyCoordinateFrame( eye ); <span class="comment">//getCoordinateFrame( eye );</span>
<a name="l01558"></a>01558 
<a name="l01559"></a>01559         <span class="keywordflow">if</span> (intersect(eye+getUpVector(eyePointCoordFrame)*distance,
<a name="l01560"></a>01560                       eye-getUpVector(eyePointCoordFrame)*distance,
<a name="l01561"></a>01561                       ip))
<a name="l01562"></a>01562         {
<a name="l01563"></a>01563             _center = ip;
<a name="l01564"></a>01564             _centerRotation = makeCenterRotation(_center);
<a name="l01565"></a>01565             setDistance((eye-ip).length());
<a name="l01566"></a>01566                         _rotation.set(0,0,0,1);
<a name="l01567"></a>01567             hitFound = <span class="keyword">true</span>;
<a name="l01568"></a>01568         }
<a name="l01569"></a>01569     }
<a name="l01570"></a>01570 
<a name="l01571"></a>01571     osg::CoordinateFrame coordinateFrame = getMyCoordinateFrame( _center ); <span class="comment">//getCoordinateFrame( _center );</span>
<a name="l01572"></a>01572     _previousUp = getUpVector(coordinateFrame);
<a name="l01573"></a>01573 
<a name="l01574"></a>01574     recalculateRoll();
<a name="l01575"></a>01575     recalculateLocalPitchAndAzimuth();
<a name="l01576"></a>01576 }
<a name="l01577"></a>01577 
<a name="l01578"></a>01578 osg::Matrixd
<a name="l01579"></a>01579 EarthManipulator::getMatrix()<span class="keyword"> const</span>
<a name="l01580"></a>01580 <span class="keyword"></span>{
<a name="l01581"></a>01581     <span class="keywordflow">return</span> osg::Matrixd::translate(-_offset_x,-_offset_y,_distance)*
<a name="l01582"></a>01582                    osg::Matrixd::rotate(_rotation)*
<a name="l01583"></a>01583                    osg::Matrixd::rotate(_centerRotation)*
<a name="l01584"></a>01584                    osg::Matrixd::translate(_center);
<a name="l01585"></a>01585 }
<a name="l01586"></a>01586 
<a name="l01587"></a>01587 osg::Matrixd
<a name="l01588"></a>01588 EarthManipulator::getInverseMatrix()<span class="keyword"> const</span>
<a name="l01589"></a>01589 <span class="keyword"></span>{
<a name="l01590"></a>01590     <span class="keywordflow">return</span> osg::Matrixd::translate(-_center)*
<a name="l01591"></a>01591                    osg::Matrixd::rotate(_centerRotation.inverse() ) *
<a name="l01592"></a>01592                    osg::Matrixd::rotate(_rotation.inverse())*
<a name="l01593"></a>01593                    osg::Matrixd::translate(_offset_x,_offset_y,-_distance);
<a name="l01594"></a>01594 }
<a name="l01595"></a>01595 
<a name="l01596"></a>01596 <span class="keywordtype">void</span>
<a name="l01597"></a>01597 EarthManipulator::setByLookAt(<span class="keyword">const</span> osg::Vec3d&amp; eye,<span class="keyword">const</span> osg::Vec3d&amp; center,<span class="keyword">const</span> osg::Vec3d&amp; up)
<a name="l01598"></a>01598 {
<a name="l01599"></a>01599     osg::ref_ptr&lt;osg::Node&gt; safeNode = _node.get();
<a name="l01600"></a>01600 
<a name="l01601"></a>01601     <span class="keywordflow">if</span> ( !safeNode.valid() ) <span class="keywordflow">return</span>;
<a name="l01602"></a>01602 
<a name="l01603"></a>01603     <span class="comment">// compute rotation matrix</span>
<a name="l01604"></a>01604     osg::Vec3d lv(center-eye);
<a name="l01605"></a>01605     setDistance( lv.length() );
<a name="l01606"></a>01606     _center = center;
<a name="l01607"></a>01607 
<a name="l01608"></a>01608     <span class="keywordflow">if</span> (_node.valid())
<a name="l01609"></a>01609     {
<a name="l01610"></a>01610         <span class="keywordtype">bool</span> hitFound = <span class="keyword">false</span>;
<a name="l01611"></a>01611 
<a name="l01612"></a>01612         <span class="keywordtype">double</span> distance = lv.length();
<a name="l01613"></a>01613         <span class="keywordtype">double</span> maxDistance = distance+2*(eye-safeNode-&gt;getBound().center()).length();
<a name="l01614"></a>01614         osg::Vec3d farPosition = eye+lv*(maxDistance/distance);
<a name="l01615"></a>01615         osg::Vec3d endPoint = center;
<a name="l01616"></a>01616         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;
<a name="l01617"></a>01617             !hitFound &amp;&amp; i&lt;2;
<a name="l01618"></a>01618             ++i, endPoint = farPosition)
<a name="l01619"></a>01619         {
<a name="l01620"></a>01620             <span class="comment">// compute the intersection with the scene.s</span>
<a name="l01621"></a>01621             
<a name="l01622"></a>01622             osg::Vec3d ip;
<a name="l01623"></a>01623             <span class="keywordflow">if</span> (intersect(eye, endPoint, ip))
<a name="l01624"></a>01624             {
<a name="l01625"></a>01625                 _center = ip;
<a name="l01626"></a>01626                 setDistance( (ip-eye).length() );
<a name="l01627"></a>01627                 hitFound = <span class="keyword">true</span>;
<a name="l01628"></a>01628             }
<a name="l01629"></a>01629         }
<a name="l01630"></a>01630     }
<a name="l01631"></a>01631 
<a name="l01632"></a>01632     <span class="comment">// note LookAt = inv(CF)*inv(RM)*inv(T) which is equivalent to:</span>
<a name="l01633"></a>01633     <span class="comment">// inv(R) = CF*LookAt.</span>
<a name="l01634"></a>01634 
<a name="l01635"></a>01635     osg::Matrixd rotation_matrix = osg::Matrixd::lookAt(eye,center,up);
<a name="l01636"></a>01636 
<a name="l01637"></a>01637     _centerRotation = getRotation( _center ).getRotate().inverse();
<a name="l01638"></a>01638         _rotation = rotation_matrix.getRotate().inverse() * _centerRotation.inverse();  
<a name="l01639"></a>01639         
<a name="l01640"></a>01640 
<a name="l01641"></a>01641     osg::CoordinateFrame coordinateFrame = getMyCoordinateFrame( _center ); <span class="comment">//getCoordinateFrame(_center);</span>
<a name="l01642"></a>01642     _previousUp = getUpVector(coordinateFrame);
<a name="l01643"></a>01643 
<a name="l01644"></a>01644     recalculateRoll();
<a name="l01645"></a>01645     recalculateLocalPitchAndAzimuth();
<a name="l01646"></a>01646 }
<a name="l01647"></a>01647 
<a name="l01648"></a>01648 
<a name="l01649"></a>01649 <span class="keywordtype">void</span>
<a name="l01650"></a>01650 EarthManipulator::recalculateCenter( <span class="keyword">const</span> osg::CoordinateFrame&amp; coordinateFrame )
<a name="l01651"></a>01651 {
<a name="l01652"></a>01652     osg::ref_ptr&lt;osg::Node&gt; safeNode = _node.get();
<a name="l01653"></a>01653     <span class="keywordflow">if</span> ( safeNode.valid() )
<a name="l01654"></a>01654     {
<a name="l01655"></a>01655         <span class="keywordtype">bool</span> hitFound = <span class="keyword">false</span>;
<a name="l01656"></a>01656 
<a name="l01657"></a>01657         <span class="comment">// need to reintersect with the terrain</span>
<a name="l01658"></a>01658         <span class="keywordtype">double</span> distance = safeNode-&gt;getBound().radius()*0.25f;
<a name="l01659"></a>01659 
<a name="l01660"></a>01660         <span class="comment">//OE_NOTICE</span>
<a name="l01661"></a>01661         <span class="comment">//    &lt;&lt; std::fixed</span>
<a name="l01662"></a>01662         <span class="comment">//    &lt;&lt; &quot;ISECT: center=(&quot; &lt;&lt; _center.x() &lt;&lt; &quot;,&quot; &lt;&lt; _center.y() &lt;&lt; &quot;,&quot; &lt;&lt; _center.y() &lt;&lt; &quot;)&quot;</span>
<a name="l01663"></a>01663         <span class="comment">//    &lt;&lt; &quot;, distnace=&quot; &lt;&lt; distance</span>
<a name="l01664"></a>01664         <span class="comment">//    &lt;&lt; std::endl;</span>
<a name="l01665"></a>01665 
<a name="l01666"></a>01666         <span class="comment">//osg::Vec3d ev = getUpVector(coordinateFrame);</span>
<a name="l01667"></a>01667         <span class="comment">//osg::Vec3d ip;</span>
<a name="l01668"></a>01668         <span class="comment">//if ( intersect( _center -ev * distance, _center + ev*distance, ip ) )</span>
<a name="l01669"></a>01669         <span class="comment">//{</span>
<a name="l01670"></a>01670         <span class="comment">//    _center = ip;</span>
<a name="l01671"></a>01671         <span class="comment">//    hitFound = true;</span>
<a name="l01672"></a>01672         <span class="comment">//}</span>
<a name="l01673"></a>01673 
<a name="l01674"></a>01674         osg::Vec3d ip1;
<a name="l01675"></a>01675         osg::Vec3d ip2;
<a name="l01676"></a>01676         <span class="comment">// extend coordonate to fall on the edge of the boundingbox see http://www.osgearth.org/ticket/113</span>
<a name="l01677"></a>01677         <span class="keywordtype">bool</span> hit_ip1 = intersect(_center - getUpVector(coordinateFrame) * distance * 0.1, _center + getUpVector(coordinateFrame) * distance, ip1);
<a name="l01678"></a>01678         <span class="keywordtype">bool</span> hit_ip2 = intersect(_center + getUpVector(coordinateFrame) * distance * 0.1, _center - getUpVector(coordinateFrame) * distance, ip2);
<a name="l01679"></a>01679         <span class="keywordflow">if</span> (hit_ip1)
<a name="l01680"></a>01680         {
<a name="l01681"></a>01681             <span class="keywordflow">if</span> (hit_ip2)
<a name="l01682"></a>01682             {
<a name="l01683"></a>01683                 _center = (_center-ip1).length2() &lt; (_center-ip2).length2() ? ip1 : ip2;
<a name="l01684"></a>01684                 hitFound = <span class="keyword">true</span>;
<a name="l01685"></a>01685             }
<a name="l01686"></a>01686             <span class="keywordflow">else</span>
<a name="l01687"></a>01687             {
<a name="l01688"></a>01688                 _center = ip1;
<a name="l01689"></a>01689                 hitFound = <span class="keyword">true</span>;
<a name="l01690"></a>01690             }
<a name="l01691"></a>01691         }
<a name="l01692"></a>01692         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hit_ip2)
<a name="l01693"></a>01693         {
<a name="l01694"></a>01694             _center = ip2;
<a name="l01695"></a>01695             hitFound = <span class="keyword">true</span>;
<a name="l01696"></a>01696         }
<a name="l01697"></a>01697 
<a name="l01698"></a>01698         <span class="keywordflow">if</span> (!hitFound)
<a name="l01699"></a>01699         {
<a name="l01700"></a>01700             <span class="comment">// ??</span>
<a name="l01701"></a>01701             <span class="comment">//OE_DEBUG&lt;&lt;&quot;EarthManipulator unable to intersect with terrain.&quot;&lt;&lt;std::endl;</span>
<a name="l01702"></a>01702         }
<a name="l01703"></a>01703     }
<a name="l01704"></a>01704 }
<a name="l01705"></a>01705 
<a name="l01706"></a>01706 
<a name="l01707"></a>01707 <span class="keywordtype">void</span>
<a name="l01708"></a>01708 EarthManipulator::pan( <span class="keywordtype">double</span> dx, <span class="keywordtype">double</span> dy )
<a name="l01709"></a>01709 {
<a name="l01710"></a>01710         <span class="comment">//OE_NOTICE &lt;&lt; &quot;pan &quot; &lt;&lt; dx &lt;&lt; &quot;,&quot; &lt;&lt; dy &lt;&lt;  std::endl;</span>
<a name="l01711"></a>01711         <span class="keywordflow">if</span> (!_tether_node.valid())
<a name="l01712"></a>01712         {
<a name="l01713"></a>01713                 <span class="keywordtype">double</span> scale = -0.3f*_distance;
<a name="l01714"></a>01714                 <span class="comment">//double old_azim = _local_azim;</span>
<a name="l01715"></a>01715                 <span class="keywordtype">double</span> old_azim = getAzimuth();
<a name="l01716"></a>01716 
<a name="l01717"></a>01717                 osg::Matrixd rotation_matrix;<span class="comment">// = getMatrix();</span>
<a name="l01718"></a>01718                 rotation_matrix.makeRotate( _rotation * _centerRotation  );
<a name="l01719"></a>01719 
<a name="l01720"></a>01720                 <span class="comment">// compute look vector.</span>
<a name="l01721"></a>01721                 osg::Vec3d lookVector = -getUpVector(rotation_matrix);
<a name="l01722"></a>01722                 osg::Vec3d sideVector = getSideVector(rotation_matrix);
<a name="l01723"></a>01723                 osg::Vec3d upVector = getFrontVector(rotation_matrix);
<a name="l01724"></a>01724 
<a name="l01725"></a>01725                 osg::Vec3d localUp = _previousUp;
<a name="l01726"></a>01726 
<a name="l01727"></a>01727                 osg::Vec3d forwardVector =localUp^sideVector;
<a name="l01728"></a>01728                 sideVector = forwardVector^localUp;
<a name="l01729"></a>01729 
<a name="l01730"></a>01730                 forwardVector.normalize();
<a name="l01731"></a>01731                 sideVector.normalize();
<a name="l01732"></a>01732 
<a name="l01733"></a>01733                 osg::Vec3d dv = forwardVector * (dy*scale) + sideVector * (dx*scale);
<a name="l01734"></a>01734 
<a name="l01735"></a>01735                 <span class="comment">// save the previous CF so we can do azimuth locking:</span>
<a name="l01736"></a>01736                 osg::CoordinateFrame old_frame = getMyCoordinateFrame( _center ); <span class="comment">//getCoordinateFrame( _center );</span>
<a name="l01737"></a>01737 
<a name="l01738"></a>01738                 _center += dv;
<a name="l01739"></a>01739 
<a name="l01740"></a>01740                 <span class="comment">// need to recompute the intersection point along the look vector.</span>
<a name="l01741"></a>01741 
<a name="l01742"></a>01742         osg::ref_ptr&lt;osg::Node&gt; safeNode = _node.get();
<a name="l01743"></a>01743                 <span class="keywordflow">if</span> (safeNode.valid())
<a name="l01744"></a>01744                 {
<a name="l01745"></a>01745                         <span class="comment">// now reorientate the coordinate frame to the frame coords.</span>
<a name="l01746"></a>01746                         osg::CoordinateFrame coordinateFrame = old_frame; <span class="comment">// getCoordinateFrame(_center);</span>
<a name="l01747"></a>01747 
<a name="l01748"></a>01748                         recalculateCenter( coordinateFrame );
<a name="l01749"></a>01749 
<a name="l01750"></a>01750                         coordinateFrame = getMyCoordinateFrame( _center ); <span class="comment">// getCoordinateFrame(_center);</span>
<a name="l01751"></a>01751                         osg::Vec3d new_localUp = getUpVector(coordinateFrame);
<a name="l01752"></a>01752 
<a name="l01753"></a>01753                         osg::Quat pan_rotation;
<a name="l01754"></a>01754                         pan_rotation.makeRotate( localUp, new_localUp );
<a name="l01755"></a>01755 
<a name="l01756"></a>01756                         <span class="keywordflow">if</span> ( !pan_rotation.zeroRotation() )
<a name="l01757"></a>01757                         {
<a name="l01758"></a>01758                                 _centerRotation = _centerRotation * pan_rotation;
<a name="l01759"></a>01759                                 _previousUp = new_localUp;
<a name="l01760"></a>01760                         }
<a name="l01761"></a>01761                         <span class="keywordflow">else</span>
<a name="l01762"></a>01762                         {
<a name="l01763"></a>01763                                 <span class="comment">//OE_DEBUG&lt;&lt;&quot;New up orientation nearly inline - no need to rotate&quot;&lt;&lt;std::endl;</span>
<a name="l01764"></a>01764                         }
<a name="l01765"></a>01765 
<a name="l01766"></a>01766                         <span class="keywordflow">if</span> ( _settings-&gt;getLockAzimuthWhilePanning() )
<a name="l01767"></a>01767                         {
<a name="l01768"></a>01768                                 <span class="keywordtype">double</span> new_azim = getAzimuth();
<a name="l01769"></a>01769                                 <span class="keywordtype">double</span> delta_azim = new_azim - old_azim;
<a name="l01770"></a>01770                                 <span class="comment">//OE_NOTICE &lt;&lt; &quot;DeltaAzim&quot; &lt;&lt; delta_azim &lt;&lt; std::endl;</span>
<a name="l01771"></a>01771 
<a name="l01772"></a>01772                                 osg::Quat q;
<a name="l01773"></a>01773                                 q.makeRotate( delta_azim, new_localUp );
<a name="l01774"></a>01774                                 <span class="keywordflow">if</span> ( !q.zeroRotation() )
<a name="l01775"></a>01775                                 {
<a name="l01776"></a>01776                                         _centerRotation = _centerRotation * q;
<a name="l01777"></a>01777                                 }
<a name="l01778"></a>01778                         }
<a name="l01779"></a>01779                 }
<a name="l01780"></a>01780 
<a name="l01781"></a>01781                 recalculateLocalPitchAndAzimuth();
<a name="l01782"></a>01782         }
<a name="l01783"></a>01783         <span class="keywordflow">else</span>
<a name="l01784"></a>01784         {
<a name="l01785"></a>01785                 <span class="keywordtype">double</span> scale = _distance;
<a name="l01786"></a>01786                 _offset_x += dx * scale;
<a name="l01787"></a>01787                 _offset_y += dy * scale;
<a name="l01788"></a>01788 
<a name="l01789"></a>01789                 <span class="comment">//Clamp values within range</span>
<a name="l01790"></a>01790                 <span class="keywordflow">if</span> (_offset_x &lt; -_settings-&gt;getMaxXOffset()) _offset_x = -_settings-&gt;getMaxXOffset();
<a name="l01791"></a>01791                 <span class="keywordflow">if</span> (_offset_y &lt; -_settings-&gt;getMaxYOffset()) _offset_y = -_settings-&gt;getMaxYOffset();
<a name="l01792"></a>01792                 <span class="keywordflow">if</span> (_offset_x &gt; _settings-&gt;getMaxXOffset()) _offset_x = _settings-&gt;getMaxXOffset();
<a name="l01793"></a>01793                 <span class="keywordflow">if</span> (_offset_y &gt; _settings-&gt;getMaxYOffset()) _offset_y = _settings-&gt;getMaxYOffset();
<a name="l01794"></a>01794         }
<a name="l01795"></a>01795 }
<a name="l01796"></a>01796 
<a name="l01797"></a>01797 <span class="keywordtype">void</span>
<a name="l01798"></a>01798 EarthManipulator::rotate( <span class="keywordtype">double</span> dx, <span class="keywordtype">double</span> dy )
<a name="l01799"></a>01799 {
<a name="l01800"></a>01800         <span class="comment">//OE_NOTICE &lt;&lt; &quot;rotate &quot; &lt;&lt; dx &lt;&lt;&quot;, &quot; &lt;&lt; dy &lt;&lt; std::endl;</span>
<a name="l01801"></a>01801     <span class="comment">// clamp the local pitch delta; never allow the pitch to hit -90.</span>
<a name="l01802"></a>01802     <span class="keywordtype">double</span> minp = osg::DegreesToRadians( osg::clampAbove( _settings-&gt;getMinPitch(), -89.9 ) );
<a name="l01803"></a>01803     <span class="keywordtype">double</span> maxp = osg::DegreesToRadians( _settings-&gt;getMaxPitch() );
<a name="l01804"></a>01804 
<a name="l01805"></a>01805     <span class="comment">//OE_NOTICE &lt;&lt; LC </span>
<a name="l01806"></a>01806     <span class="comment">//    &lt;&lt; &quot;LocalPitch=&quot; &lt;&lt; osg::RadiansToDegrees(_local_pitch)</span>
<a name="l01807"></a>01807     <span class="comment">//    &lt;&lt; &quot;, dy=&quot; &lt;&lt; osg::RadiansToDegrees(dy)</span>
<a name="l01808"></a>01808     <span class="comment">//    &lt;&lt; &quot;, dy+lp=&quot; &lt;&lt; osg::RadiansToDegrees(_local_pitch+dy)</span>
<a name="l01809"></a>01809     <span class="comment">//    &lt;&lt; &quot;, limits=&quot; &lt;&lt; osg::RadiansToDegrees(minp) &lt;&lt; &quot;,&quot; &lt;&lt; osg::RadiansToDegrees(maxp)</span>
<a name="l01810"></a>01810     <span class="comment">//    &lt;&lt; std::endl;</span>
<a name="l01811"></a>01811 
<a name="l01812"></a>01812     <span class="comment">// clamp pitch range:</span>
<a name="l01813"></a>01813     <span class="keywordflow">if</span> ( dy + _local_pitch &gt; maxp || dy + _local_pitch &lt; minp )
<a name="l01814"></a>01814         dy = 0;
<a name="l01815"></a>01815 
<a name="l01816"></a>01816         osg::Matrix rotation_matrix;
<a name="l01817"></a>01817         rotation_matrix.makeRotate(_rotation);
<a name="l01818"></a>01818 
<a name="l01819"></a>01819         osg::Vec3d lookVector = -getUpVector(rotation_matrix);
<a name="l01820"></a>01820         osg::Vec3d sideVector = getSideVector(rotation_matrix);
<a name="l01821"></a>01821         osg::Vec3d upVector = getFrontVector(rotation_matrix);
<a name="l01822"></a>01822 
<a name="l01823"></a>01823         osg::Vec3d localUp(0.0f,0.0f,1.0f);
<a name="l01824"></a>01824 
<a name="l01825"></a>01825         osg::Vec3d forwardVector = localUp^sideVector;
<a name="l01826"></a>01826         sideVector = forwardVector^localUp;
<a name="l01827"></a>01827 
<a name="l01828"></a>01828         forwardVector.normalize();
<a name="l01829"></a>01829         sideVector.normalize();
<a name="l01830"></a>01830 
<a name="l01831"></a>01831         osg::Quat rotate_elevation;
<a name="l01832"></a>01832         rotate_elevation.makeRotate(dy,sideVector);
<a name="l01833"></a>01833 
<a name="l01834"></a>01834         osg::Quat rotate_azim;
<a name="l01835"></a>01835         rotate_azim.makeRotate(-dx,localUp);
<a name="l01836"></a>01836 
<a name="l01837"></a>01837         _rotation = _rotation * rotate_elevation * rotate_azim;
<a name="l01838"></a>01838         recalculateLocalPitchAndAzimuth();
<a name="l01839"></a>01839 }
<a name="l01840"></a>01840 
<a name="l01841"></a>01841 <span class="keywordtype">void</span>
<a name="l01842"></a>01842 EarthManipulator::zoom( <span class="keywordtype">double</span> dx, <span class="keywordtype">double</span> dy )
<a name="l01843"></a>01843 {
<a name="l01844"></a>01844     <span class="keywordtype">double</span> fd = 1000;
<a name="l01845"></a>01845     <span class="keywordtype">double</span> scale = 1.0f + dy;
<a name="l01846"></a>01846 
<a name="l01847"></a>01847     <span class="keywordflow">if</span> ( fd * scale &gt; _settings-&gt;getMinDistance() )
<a name="l01848"></a>01848     {
<a name="l01849"></a>01849         setDistance( _distance * scale );
<a name="l01850"></a>01850     }
<a name="l01851"></a>01851     <span class="keywordflow">else</span>
<a name="l01852"></a>01852     {
<a name="l01853"></a>01853                 setDistance( _settings-&gt;getMinDistance() );
<a name="l01854"></a>01854     }
<a name="l01855"></a>01855 }
<a name="l01856"></a>01856 
<a name="l01857"></a>01857 <span class="keywordtype">bool</span>
<a name="l01858"></a>01858 EarthManipulator::screenToWorld(<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y, osg::View* theView, osg::Vec3d&amp; out_coords )<span class="keyword"> const</span>
<a name="l01859"></a>01859 <span class="keyword"></span>{
<a name="l01860"></a>01860     osgViewer::View* view = <span class="keyword">dynamic_cast&lt;</span>osgViewer::View*<span class="keyword">&gt;</span>( theView );
<a name="l01861"></a>01861     <span class="keywordflow">if</span> ( !view || !view-&gt;getCamera() )
<a name="l01862"></a>01862         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01863"></a>01863 
<a name="l01864"></a>01864     <span class="keywordtype">float</span> local_x, local_y = 0.0;    
<a name="l01865"></a>01865     <span class="keyword">const</span> osg::Camera* camera = view-&gt;getCameraContainingPosition(x, y, local_x, local_y);
<a name="l01866"></a>01866     <span class="keywordflow">if</span> ( !camera )
<a name="l01867"></a>01867         camera = view-&gt;getCamera();
<a name="l01868"></a>01868 
<a name="l01869"></a>01869     osgUtil::LineSegmentIntersector::CoordinateFrame cf = 
<a name="l01870"></a>01870         camera-&gt;getViewport() ? osgUtil::Intersector::WINDOW : osgUtil::Intersector::PROJECTION;
<a name="l01871"></a>01871 
<a name="l01872"></a>01872     osg::ref_ptr&lt; osgUtil::LineSegmentIntersector &gt; picker = <span class="keyword">new</span> osgUtil::LineSegmentIntersector(cf, local_x, local_y);
<a name="l01873"></a>01873 
<a name="l01874"></a>01874     osgUtil::IntersectionVisitor iv(picker.get());
<a name="l01875"></a>01875     iv.setTraversalMask(_intersectTraversalMask);
<a name="l01876"></a>01876 
<a name="l01877"></a>01877     <span class="keyword">const_cast&lt;</span>osg::Camera*<span class="keyword">&gt;</span>(camera)-&gt;accept(iv);
<a name="l01878"></a>01878 
<a name="l01879"></a>01879     <span class="keywordflow">if</span> ( picker-&gt;containsIntersections() )
<a name="l01880"></a>01880     {
<a name="l01881"></a>01881         osgUtil::LineSegmentIntersector::Intersections&amp; results = picker-&gt;getIntersections();
<a name="l01882"></a>01882         out_coords = results.begin()-&gt;getWorldIntersectPoint();
<a name="l01883"></a>01883         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01884"></a>01884     }
<a name="l01885"></a>01885 
<a name="l01886"></a>01886     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01887"></a>01887 }
<a name="l01888"></a>01888 
<a name="l01889"></a>01889 <span class="keywordtype">void</span>
<a name="l01890"></a>01890 EarthManipulator::setDistance( <span class="keywordtype">double</span> distance )
<a name="l01891"></a>01891 {
<a name="l01892"></a>01892         _distance = osg::clampBetween( distance, _settings-&gt;getMinDistance(), _settings-&gt;getMaxDistance() );
<a name="l01893"></a>01893 }
<a name="l01894"></a>01894 
<a name="l01895"></a>01895 <span class="keywordtype">void</span>
<a name="l01896"></a>01896 EarthManipulator::dumpActionInfo( <span class="keyword">const</span> EarthManipulator::Action&amp; action, osg::NotifySeverity level )<span class="keyword"> const</span>
<a name="l01897"></a>01897 <span class="keyword"></span>{
<a name="l01898"></a>01898     osgEarth::notify(level) &lt;&lt; <span class="stringliteral">&quot;action: &quot;</span> &lt;&lt; s_actionNames[action._type] &lt;&lt; <span class="stringliteral">&quot;; options: &quot;</span>;
<a name="l01899"></a>01899     <span class="keywordflow">for</span>( ActionOptions::const_iterator i = action._options.begin(); i != action._options.end(); ++i )
<a name="l01900"></a>01900     {
<a name="l01901"></a>01901         <span class="keyword">const</span> ActionOption&amp; option = *i;
<a name="l01902"></a>01902         std::string val;
<a name="l01903"></a>01903         <span class="keywordflow">if</span> ( s_actionOptionTypes[option.option()] == 0 )
<a name="l01904"></a>01904             val = option.boolValue() ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>;
<a name="l01905"></a>01905         <span class="keywordflow">else</span>
<a name="l01906"></a>01906             val = toString&lt;double&gt;(option.doubleValue());
<a name="l01907"></a>01907 
<a name="l01908"></a>01908         osgEarth::notify(level)
<a name="l01909"></a>01909             &lt;&lt; s_actionOptionNames[option.option()] &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; val &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
<a name="l01910"></a>01910     }
<a name="l01911"></a>01911     osgEarth::notify(level) &lt;&lt; std::endl;        
<a name="l01912"></a>01912 }
<a name="l01913"></a>01913 
<a name="l01914"></a>01914 <span class="keywordtype">void</span>
<a name="l01915"></a>01915 EarthManipulator::handleMovementAction( <span class="keyword">const</span> ActionType&amp; type, <span class="keywordtype">double</span> dx, <span class="keywordtype">double</span> dy, osg::View* view )
<a name="l01916"></a>01916 {
<a name="l01917"></a>01917     <span class="keywordflow">switch</span>( type )
<a name="l01918"></a>01918     {
<a name="l01919"></a>01919     <span class="keywordflow">case</span> ACTION_PAN:
<a name="l01920"></a>01920         pan( dx, dy );
<a name="l01921"></a>01921         <span class="keywordflow">break</span>;
<a name="l01922"></a>01922 
<a name="l01923"></a>01923     <span class="keywordflow">case</span> ACTION_ROTATE:
<a name="l01924"></a>01924         <span class="comment">// in &quot;single axis&quot; mode, zero out one of the deltas.</span>
<a name="l01925"></a>01925         <span class="keywordflow">if</span> ( _continuous &amp;&amp; _settings-&gt;getSingleAxisRotation() )
<a name="l01926"></a>01926         {
<a name="l01927"></a>01927             <span class="keywordflow">if</span> ( ::fabs(dx) &gt; ::fabs(dy) )
<a name="l01928"></a>01928                 dy = 0.0;
<a name="l01929"></a>01929             <span class="keywordflow">else</span>
<a name="l01930"></a>01930                 dx = 0.0;
<a name="l01931"></a>01931         }
<a name="l01932"></a>01932         rotate( dx, dy );
<a name="l01933"></a>01933         <span class="keywordflow">break</span>;
<a name="l01934"></a>01934 
<a name="l01935"></a>01935     <span class="keywordflow">case</span> ACTION_ZOOM:
<a name="l01936"></a>01936         zoom( dx, dy );
<a name="l01937"></a>01937         <span class="keywordflow">break</span>;
<a name="l01938"></a>01938 
<a name="l01939"></a>01939     <span class="keywordflow">case</span> ACTION_EARTH_DRAG:
<a name="l01940"></a>01940         drag( dx, dy, view );
<a name="l01941"></a>01941         <span class="keywordflow">break</span>;
<a name="l01942"></a>01942     }
<a name="l01943"></a>01943 }
<a name="l01944"></a>01944 
<a name="l01945"></a>01945 <span class="keywordtype">bool</span>
<a name="l01946"></a>01946 EarthManipulator::handlePointAction( <span class="keyword">const</span> Action&amp; action, <span class="keywordtype">float</span> mx, <span class="keywordtype">float</span> my, osg::View* view )
<a name="l01947"></a>01947 {
<a name="l01948"></a>01948     <span class="comment">//Exit early if the action is null</span>
<a name="l01949"></a>01949     <span class="keywordflow">if</span> (action._type == ACTION_NULL)
<a name="l01950"></a>01950         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01951"></a>01951 
<a name="l01952"></a>01952     osg::Vec3d point;
<a name="l01953"></a>01953     <span class="keywordflow">if</span> ( screenToWorld( mx, my, view, point ))
<a name="l01954"></a>01954     {
<a name="l01955"></a>01955         <span class="keywordflow">switch</span>( action._type )
<a name="l01956"></a>01956         {
<a name="l01957"></a>01957             <span class="keywordflow">case</span> ACTION_GOTO:
<a name="l01958"></a>01958                 Viewpoint here = getViewpoint();
<a name="l01959"></a>01959 
<a name="l01960"></a>01960                 <span class="keywordflow">if</span> ( getSRS() &amp;&amp; _is_geocentric )
<a name="l01961"></a>01961                 {
<a name="l01962"></a>01962                     <span class="keywordtype">double</span> lat_r, lon_r, h;
<a name="l01963"></a>01963                     getSRS()-&gt;getEllipsoid()-&gt;convertXYZToLatLongHeight(
<a name="l01964"></a>01964                         point.x(), point.y(), point.z(),
<a name="l01965"></a>01965                         lat_r, lon_r, h );
<a name="l01966"></a>01966                     point.set( osg::RadiansToDegrees(lon_r), osg::RadiansToDegrees(lat_r), h );
<a name="l01967"></a>01967                 }
<a name="l01968"></a>01968                 here.setFocalPoint( point );
<a name="l01969"></a>01969 
<a name="l01970"></a>01970                 <span class="keywordtype">double</span> duration_s = action.getDoubleOption(OPTION_DURATION, 1.0);
<a name="l01971"></a>01971                 <span class="keywordtype">double</span> range_factor = action.getDoubleOption(OPTION_GOTO_RANGE_FACTOR, 1.0);
<a name="l01972"></a>01972 
<a name="l01973"></a>01973                 here.setRange( here.getRange() * range_factor );
<a name="l01974"></a>01974 
<a name="l01975"></a>01975                 setViewpoint( here, duration_s );
<a name="l01976"></a>01976                 <span class="keywordflow">break</span>;
<a name="l01977"></a>01977         }
<a name="l01978"></a>01978     }
<a name="l01979"></a>01979     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01980"></a>01980 }
<a name="l01981"></a>01981 
<a name="l01982"></a>01982 <span class="keywordtype">void</span>
<a name="l01983"></a>01983 EarthManipulator::handleContinuousAction( <span class="keyword">const</span> Action&amp; action, osg::View* view )
<a name="l01984"></a>01984 {
<a name="l01985"></a>01985     handleMovementAction( action._type, _continuous_dx * _t_factor, _continuous_dy * _t_factor, view );
<a name="l01986"></a>01986 }
<a name="l01987"></a>01987 
<a name="l01988"></a>01988 <span class="keywordtype">void</span>
<a name="l01989"></a>01989 EarthManipulator::applyOptionsToDeltas( <span class="keyword">const</span> Action&amp; action, <span class="keywordtype">double</span>&amp; dx, <span class="keywordtype">double</span>&amp; dy )
<a name="l01990"></a>01990 {
<a name="l01991"></a>01991     dx *= action.getDoubleOption( OPTION_SCALE_X, 1.0 );
<a name="l01992"></a>01992     dy *= action.getDoubleOption( OPTION_SCALE_Y, 1.0 );
<a name="l01993"></a>01993 
<a name="l01994"></a>01994     <span class="keywordflow">if</span> ( action.getBoolOption( OPTION_SINGLE_AXIS, <span class="keyword">false</span> ) == true )
<a name="l01995"></a>01995     {
<a name="l01996"></a>01996         <span class="keywordflow">if</span> ( osg::absolute(dx) &gt; osg::absolute(dy) )
<a name="l01997"></a>01997             dy = 0.0;
<a name="l01998"></a>01998         <span class="keywordflow">else</span>
<a name="l01999"></a>01999             dx = 0.0;
<a name="l02000"></a>02000     }
<a name="l02001"></a>02001 }
<a name="l02002"></a>02002 
<a name="l02003"></a>02003 <span class="keywordtype">bool</span>
<a name="l02004"></a>02004 EarthManipulator::handleMouseAction( <span class="keyword">const</span> Action&amp; action, osg::View* view )
<a name="l02005"></a>02005 {
<a name="l02006"></a>02006     <span class="comment">// return if less then two events have been added.</span>
<a name="l02007"></a>02007     <span class="keywordflow">if</span> (_ga_t0.get()==NULL || _ga_t1.get()==NULL) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02008"></a>02008 
<a name="l02009"></a>02009     <span class="comment">//if ( osgEarth::getNotifyLevel() &gt; osg::INFO )</span>
<a name="l02010"></a>02010     <span class="comment">//    dumpActionInfo( action, osg::DEBUG_INFO );</span>
<a name="l02011"></a>02011 
<a name="l02012"></a>02012     <span class="keywordtype">double</span> dx = _ga_t0-&gt;getXnormalized()-_ga_t1-&gt;getXnormalized();
<a name="l02013"></a>02013     <span class="keywordtype">double</span> dy = _ga_t0-&gt;getYnormalized()-_ga_t1-&gt;getYnormalized();
<a name="l02014"></a>02014 
<a name="l02015"></a>02015     <span class="comment">// return if there is no movement.</span>
<a name="l02016"></a>02016     <span class="keywordflow">if</span> (dx==0 &amp;&amp; dy==0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02017"></a>02017 
<a name="l02018"></a>02018     <span class="comment">// here we adjust for action scale, global sensitivy</span>
<a name="l02019"></a>02019     dx *= _settings-&gt;getMouseSensitivity();
<a name="l02020"></a>02020     dy *= _settings-&gt;getMouseSensitivity();
<a name="l02021"></a>02021 
<a name="l02022"></a>02022     applyOptionsToDeltas( action, dx, dy );
<a name="l02023"></a>02023 
<a name="l02024"></a>02024     <span class="comment">// in &quot;continuous&quot; mode, we accumulate the deltas each frame - thus</span>
<a name="l02025"></a>02025     <span class="comment">// the deltas act more like speeds.</span>
<a name="l02026"></a>02026     <span class="keywordflow">if</span> ( _continuous )
<a name="l02027"></a>02027     {
<a name="l02028"></a>02028         _continuous_dx += dx * 0.01;
<a name="l02029"></a>02029         _continuous_dy += dy * 0.01;
<a name="l02030"></a>02030     }
<a name="l02031"></a>02031     <span class="keywordflow">else</span>
<a name="l02032"></a>02032     {
<a name="l02033"></a>02033         handleMovementAction( action._type, dx, dy, view );
<a name="l02034"></a>02034     }
<a name="l02035"></a>02035 
<a name="l02036"></a>02036     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02037"></a>02037 }
<a name="l02038"></a>02038 
<a name="l02039"></a>02039 <span class="keywordtype">bool</span>
<a name="l02040"></a>02040 EarthManipulator::handleMouseClickAction( <span class="keyword">const</span> Action&amp; action )
<a name="l02041"></a>02041 {
<a name="l02042"></a>02042     <span class="comment">//TODO.</span>
<a name="l02043"></a>02043     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02044"></a>02044 }
<a name="l02045"></a>02045 
<a name="l02046"></a>02046 <span class="keywordtype">bool</span>
<a name="l02047"></a>02047 EarthManipulator::handleKeyboardAction( <span class="keyword">const</span> Action&amp; action, <span class="keywordtype">double</span> duration )
<a name="l02048"></a>02048 {
<a name="l02049"></a>02049     <span class="keywordtype">double</span> dx = 0, dy = 0;
<a name="l02050"></a>02050 
<a name="l02051"></a>02051     <span class="keywordflow">switch</span>( action._dir )
<a name="l02052"></a>02052     {
<a name="l02053"></a>02053     <span class="keywordflow">case</span> DIR_LEFT:  dx =  1; <span class="keywordflow">break</span>;
<a name="l02054"></a>02054     <span class="keywordflow">case</span> DIR_RIGHT: dx = -1; <span class="keywordflow">break</span>;
<a name="l02055"></a>02055     <span class="keywordflow">case</span> DIR_UP:    dy = -1; <span class="keywordflow">break</span>;
<a name="l02056"></a>02056     <span class="keywordflow">case</span> DIR_DOWN:  dy =  1; <span class="keywordflow">break</span>;
<a name="l02057"></a>02057     }
<a name="l02058"></a>02058 
<a name="l02059"></a>02059     dx *= _settings-&gt;getKeyboardSensitivity();
<a name="l02060"></a>02060     dy *= _settings-&gt;getKeyboardSensitivity();
<a name="l02061"></a>02061 
<a name="l02062"></a>02062     applyOptionsToDeltas( action, dx, dy );
<a name="l02063"></a>02063 
<a name="l02064"></a>02064     <span class="keywordflow">return</span> handleAction( action, dx, dy, duration );
<a name="l02065"></a>02065 }
<a name="l02066"></a>02066 
<a name="l02067"></a>02067 <span class="keywordtype">bool</span>
<a name="l02068"></a>02068 EarthManipulator::handleScrollAction( <span class="keyword">const</span> Action&amp; action, <span class="keywordtype">double</span> duration )
<a name="l02069"></a>02069 {
<a name="l02070"></a>02070     <span class="keyword">const</span> <span class="keywordtype">double</span> scrollFactor = 1.5;
<a name="l02071"></a>02071 
<a name="l02072"></a>02072     <span class="keywordtype">double</span> dx = 0, dy = 0;
<a name="l02073"></a>02073 
<a name="l02074"></a>02074     <span class="keywordflow">switch</span>( action._dir )
<a name="l02075"></a>02075     {
<a name="l02076"></a>02076     <span class="keywordflow">case</span> DIR_LEFT:  dx =  1; <span class="keywordflow">break</span>;
<a name="l02077"></a>02077     <span class="keywordflow">case</span> DIR_RIGHT: dx = -1; <span class="keywordflow">break</span>;
<a name="l02078"></a>02078     <span class="keywordflow">case</span> DIR_UP:    dy = -1; <span class="keywordflow">break</span>;
<a name="l02079"></a>02079     <span class="keywordflow">case</span> DIR_DOWN:  dy =  1; <span class="keywordflow">break</span>;
<a name="l02080"></a>02080     }
<a name="l02081"></a>02081 
<a name="l02082"></a>02082     dx *= scrollFactor * _settings-&gt;getScrollSensitivity();
<a name="l02083"></a>02083     dy *= scrollFactor * _settings-&gt;getScrollSensitivity();
<a name="l02084"></a>02084 
<a name="l02085"></a>02085     applyOptionsToDeltas( action, dx, dy );
<a name="l02086"></a>02086 
<a name="l02087"></a>02087     <span class="keywordflow">return</span> handleAction( action, dx, dy, duration );
<a name="l02088"></a>02088 }
<a name="l02089"></a>02089 
<a name="l02090"></a>02090 <span class="keywordtype">bool</span>
<a name="l02091"></a>02091 EarthManipulator::handleAction( <span class="keyword">const</span> Action&amp; action, <span class="keywordtype">double</span> dx, <span class="keywordtype">double</span> dy, <span class="keywordtype">double</span> duration )
<a name="l02092"></a>02092 {
<a name="l02093"></a>02093     <span class="keywordtype">bool</span> handled = <span class="keyword">true</span>;
<a name="l02094"></a>02094 
<a name="l02095"></a>02095     <span class="comment">//if ( osgEarth::getNotifyLevel() &gt; osg::INFO )</span>
<a name="l02096"></a>02096     <span class="comment">//    dumpActionInfo( action, osg::DEBUG_INFO );</span>
<a name="l02097"></a>02097 
<a name="l02098"></a>02098     <span class="comment">//OE_NOTICE &lt;&lt; &quot;action=&quot; &lt;&lt; action &lt;&lt; &quot;, dx=&quot; &lt;&lt; dx &lt;&lt; &quot;, dy=&quot; &lt;&lt; dy &lt;&lt; std::endl;</span>
<a name="l02099"></a>02099 
<a name="l02100"></a>02100     <span class="keywordflow">switch</span>( action._type )
<a name="l02101"></a>02101     {
<a name="l02102"></a>02102     <span class="keywordflow">case</span> ACTION_HOME:
<a name="l02103"></a>02103         <span class="keywordflow">if</span> ( _homeViewpoint.isSet() )
<a name="l02104"></a>02104         {
<a name="l02105"></a>02105             setViewpoint( _homeViewpoint.value(), _homeViewpointDuration );
<a name="l02106"></a>02106         }
<a name="l02107"></a>02107         <span class="comment">//else</span>
<a name="l02108"></a>02108         <span class="comment">//{</span>
<a name="l02109"></a>02109         <span class="comment">//    if ( getAutoComputeHomePosition() )</span>
<a name="l02110"></a>02110         <span class="comment">//        computeHomePosition();</span>
<a name="l02111"></a>02111         <span class="comment">//    setByLookAt( _homeEye, _homeCenter, _homeUp );</span>
<a name="l02112"></a>02112         <span class="comment">//}</span>
<a name="l02113"></a>02113         <span class="keywordflow">break</span>;
<a name="l02114"></a>02114 
<a name="l02115"></a>02115 
<a name="l02116"></a>02116     <span class="keywordflow">case</span> ACTION_PAN:
<a name="l02117"></a>02117     <span class="keywordflow">case</span> ACTION_PAN_LEFT:
<a name="l02118"></a>02118     <span class="keywordflow">case</span> ACTION_PAN_RIGHT:
<a name="l02119"></a>02119     <span class="keywordflow">case</span> ACTION_PAN_UP:
<a name="l02120"></a>02120     <span class="keywordflow">case</span> ACTION_PAN_DOWN:
<a name="l02121"></a>02121         _task-&gt;set( TASK_PAN, dx, dy, duration );
<a name="l02122"></a>02122         <span class="keywordflow">break</span>;
<a name="l02123"></a>02123 
<a name="l02124"></a>02124     <span class="keywordflow">case</span> ACTION_ROTATE:
<a name="l02125"></a>02125     <span class="keywordflow">case</span> ACTION_ROTATE_LEFT:
<a name="l02126"></a>02126     <span class="keywordflow">case</span> ACTION_ROTATE_RIGHT:
<a name="l02127"></a>02127     <span class="keywordflow">case</span> ACTION_ROTATE_UP:
<a name="l02128"></a>02128     <span class="keywordflow">case</span> ACTION_ROTATE_DOWN:
<a name="l02129"></a>02129         _task-&gt;set( TASK_ROTATE, dx, dy, duration );
<a name="l02130"></a>02130         <span class="keywordflow">break</span>;
<a name="l02131"></a>02131 
<a name="l02132"></a>02132     <span class="keywordflow">case</span> ACTION_ZOOM:
<a name="l02133"></a>02133     <span class="keywordflow">case</span> ACTION_ZOOM_IN:
<a name="l02134"></a>02134     <span class="keywordflow">case</span> ACTION_ZOOM_OUT:
<a name="l02135"></a>02135         _task-&gt;set( TASK_ZOOM, dx, dy, duration );
<a name="l02136"></a>02136         <span class="keywordflow">break</span>;
<a name="l02137"></a>02137 
<a name="l02138"></a>02138     <span class="keywordflow">default</span>:
<a name="l02139"></a>02139         handled = <span class="keyword">false</span>;
<a name="l02140"></a>02140     }
<a name="l02141"></a>02141 
<a name="l02142"></a>02142     <span class="keywordflow">return</span> handled;
<a name="l02143"></a>02143 }
<a name="l02144"></a>02144 
<a name="l02145"></a>02145 <span class="keywordtype">void</span>
<a name="l02146"></a>02146 EarthManipulator::recalculateRoll()
<a name="l02147"></a>02147 {
<a name="l02148"></a>02148     osg::Matrixd rotation_matrix;
<a name="l02149"></a>02149     rotation_matrix.makeRotate(_centerRotation);
<a name="l02150"></a>02150 
<a name="l02151"></a>02151     osg::Vec3d lookVector = -getUpVector(rotation_matrix);
<a name="l02152"></a>02152     osg::Vec3d upVector = getFrontVector(rotation_matrix);
<a name="l02153"></a>02153 
<a name="l02154"></a>02154     osg::CoordinateFrame coordinateFrame = getMyCoordinateFrame( _center ); <span class="comment">//getCoordinateFrame(_center);</span>
<a name="l02155"></a>02155     osg::Vec3d localUp = getUpVector(coordinateFrame);
<a name="l02156"></a>02156 
<a name="l02157"></a>02157     osg::Vec3d sideVector = lookVector ^ localUp;
<a name="l02158"></a>02158 
<a name="l02159"></a>02159     <span class="keywordflow">if</span> (sideVector.length()&lt;0.1)
<a name="l02160"></a>02160     {
<a name="l02161"></a>02161         <span class="comment">//OE_INFO&lt;&lt;&quot;Side vector short &quot;&lt;&lt;sideVector.length()&lt;&lt;std::endl;</span>
<a name="l02162"></a>02162 
<a name="l02163"></a>02163         sideVector = upVector^localUp;
<a name="l02164"></a>02164         sideVector.normalize();
<a name="l02165"></a>02165 
<a name="l02166"></a>02166     }
<a name="l02167"></a>02167 
<a name="l02168"></a>02168     osg::Vec3d newUpVector = sideVector^lookVector;
<a name="l02169"></a>02169     newUpVector.normalize();
<a name="l02170"></a>02170 
<a name="l02171"></a>02171     osg::Quat rotate_roll;
<a name="l02172"></a>02172     rotate_roll.makeRotate(upVector,newUpVector);
<a name="l02173"></a>02173 
<a name="l02174"></a>02174     <span class="keywordflow">if</span> (!rotate_roll.zeroRotation())
<a name="l02175"></a>02175     {
<a name="l02176"></a>02176         _centerRotation = _centerRotation * rotate_roll;
<a name="l02177"></a>02177     }
<a name="l02178"></a>02178 }
<a name="l02179"></a>02179 
<a name="l02180"></a>02180 <span class="keywordtype">double</span>
<a name="l02181"></a>02181 EarthManipulator::getAzimuth()<span class="keyword"> const</span>
<a name="l02182"></a>02182 <span class="keyword"></span>{
<a name="l02183"></a>02183         osg::Matrix m = getMatrix() * osg::Matrixd::inverse( getMyCoordinateFrame( _center ) ); <span class="comment">//getCoordinateFrame( _center ) );</span>
<a name="l02184"></a>02184     osg::Vec3d look = -getUpVector( m ); <span class="comment">// -m(2,0), -m(2,1), -m(2,2)</span>
<a name="l02185"></a>02185     osg::Vec3d up   =  getFrontVector( m );
<a name="l02186"></a>02186     <span class="comment">//osg::Vec3d look( -m(2,0), -m(2,1), -m(2,2) );</span>
<a name="l02187"></a>02187     
<a name="l02188"></a>02188     look.normalize();
<a name="l02189"></a>02189     up.normalize();
<a name="l02190"></a>02190 
<a name="l02191"></a>02191     <span class="keywordtype">double</span> azim;    
<a name="l02192"></a>02192     <span class="keywordflow">if</span> ( look.z() &lt; -0.9 )
<a name="l02193"></a>02193         azim = atan2( up.x(), up.y() );
<a name="l02194"></a>02194     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( look.z() &gt; 0.9 )
<a name="l02195"></a>02195         azim = atan2( -up.x(), -up.y() );
<a name="l02196"></a>02196     <span class="keywordflow">else</span>
<a name="l02197"></a>02197         azim = atan2( look.x(), look.y() );
<a name="l02198"></a>02198 
<a name="l02199"></a>02199     <span class="keywordflow">return</span> normalizeAzimRad( azim );
<a name="l02200"></a>02200 }
<a name="l02201"></a>02201 
<a name="l02202"></a>02202 
<a name="l02203"></a>02203 <span class="keywordtype">void</span>
<a name="l02204"></a>02204 EarthManipulator::recalculateLocalPitchAndAzimuth()
<a name="l02205"></a>02205 {
<a name="l02206"></a>02206         <span class="keywordtype">double</span> r;
<a name="l02207"></a>02207         s_getHPRFromQuat( _rotation, _local_azim, _local_pitch, r);
<a name="l02208"></a>02208         _local_pitch -= osg::PI_2;
<a name="l02209"></a>02209         <span class="comment">//OE_NOTICE &lt;&lt; &quot;Azim=&quot; &lt;&lt; osg::RadiansToDegrees(_local_azim) &lt;&lt; &quot; Pitch=&quot; &lt;&lt; osg::RadiansToDegrees(_local_pitch) &lt;&lt; std::endl;</span>
<a name="l02210"></a>02210 }
<a name="l02211"></a>02211 
<a name="l02212"></a>02212 <span class="keywordtype">void</span>
<a name="l02213"></a>02213 EarthManipulator::setHomeViewpoint( <span class="keyword">const</span> Viewpoint&amp; vp, <span class="keywordtype">double</span> duration_s )
<a name="l02214"></a>02214 {
<a name="l02215"></a>02215     _homeViewpoint = vp;
<a name="l02216"></a>02216     _homeViewpointDuration = duration_s;
<a name="l02217"></a>02217 }
<a name="l02218"></a>02218 
<a name="l02219"></a>02219 <span class="comment">// Find the point on a line, specified by p1 and v, closest to another</span>
<a name="l02220"></a>02220 <span class="comment">// point.</span>
<a name="l02221"></a><a class="code" href="_earth_manipulator_8cpp.html#a8ee503dd8cc38565afce8b61f320c503">02221</a> osg::Vec3d <a class="code" href="_earth_manipulator_8cpp.html#a8ee503dd8cc38565afce8b61f320c503">closestPtOnLine</a>(<span class="keyword">const</span> osg::Vec3d&amp; p1, <span class="keyword">const</span> osg::Vec3d&amp; v,
<a name="l02222"></a>02222                            <span class="keyword">const</span> osg::Vec3d&amp; p)
<a name="l02223"></a>02223 {
<a name="l02224"></a>02224     <span class="keywordtype">double</span> u = (p - p1) * v / v.length2();
<a name="l02225"></a>02225     <span class="keywordflow">return</span> p1 + v * u;
<a name="l02226"></a>02226 }
<a name="l02227"></a>02227 
<a name="l02228"></a>02228 <span class="comment">// Intersection of line and plane</span>
<a name="l02229"></a><a class="code" href="_earth_manipulator_8cpp.html#ab49c273f957b8060aeb08d4a68fa93ae">02229</a> <span class="keywordtype">bool</span> <a class="code" href="_earth_manipulator_8cpp.html#ab49c273f957b8060aeb08d4a68fa93ae">findIntersectionWithPlane</a>(<span class="keyword">const</span> osg::Vec3d&amp; normal, <span class="keyword">const</span> osg::Vec3d&amp; pt,
<a name="l02230"></a>02230                                <span class="keyword">const</span> osg::Vec3d&amp; p1, <span class="keyword">const</span> osg::Vec3d&amp; v,
<a name="l02231"></a>02231                                osg::Vec3d&amp; result)
<a name="l02232"></a>02232 {
<a name="l02233"></a>02233     <span class="keywordtype">double</span> denom = normal * v;
<a name="l02234"></a>02234     <span class="keywordflow">if</span> (osg::equivalent(0, denom))
<a name="l02235"></a>02235         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02236"></a>02236     <span class="keywordtype">double</span> u = normal * (pt - p1) / denom;
<a name="l02237"></a>02237     result = p1 + v * u;
<a name="l02238"></a>02238     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02239"></a>02239 }
<a name="l02240"></a>02240 
<a name="l02241"></a>02241 <span class="comment">// Circle of intersection of two spheres. The circle is in the plane</span>
<a name="l02242"></a>02242 <span class="comment">// normal to the line between the centers.</span>
<a name="l02243"></a><a class="code" href="_earth_manipulator_8cpp.html#a4d2138863db355e43a9d0d9ea603e69a">02243</a> <span class="keywordtype">bool</span> <a class="code" href="_earth_manipulator_8cpp.html#a4d2138863db355e43a9d0d9ea603e69a">sphereInterection</a>(<span class="keyword">const</span> osg::Vec3d&amp; p0, <span class="keywordtype">double</span> r0,
<a name="l02244"></a>02244                        <span class="keyword">const</span> osg::Vec3d&amp; p1, <span class="keywordtype">double</span> r1,
<a name="l02245"></a>02245                        osg::Vec3d&amp; resultCenter, <span class="keywordtype">double</span>&amp; r)
<a name="l02246"></a>02246 {
<a name="l02247"></a>02247     <span class="keyword">using namespace </span>osg;
<a name="l02248"></a>02248     Vec3d ptvec = (p1 - p0);
<a name="l02249"></a>02249     <span class="keywordtype">double</span> d = ptvec.normalize();
<a name="l02250"></a>02250     <span class="keywordflow">if</span> (d &gt; r0 + r1)
<a name="l02251"></a>02251         <span class="keywordflow">return</span> <span class="keyword">false</span>;               <span class="comment">// spheres are too far apart</span>
<a name="l02252"></a>02252     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (d &lt; fabs(r0 - r1))
<a name="l02253"></a>02253         <span class="keywordflow">return</span> <span class="keyword">false</span>;               <span class="comment">// One sphere is contained in the other</span>
<a name="l02254"></a>02254     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (equivalent(0, d) &amp;&amp; equivalent(r0, r1))
<a name="l02255"></a>02255     {
<a name="l02256"></a>02256         resultCenter = p0;
<a name="l02257"></a>02257         r = r0;
<a name="l02258"></a>02258         <span class="keywordflow">return</span> <span class="keyword">true</span>;              <span class="comment">// circles are coincident.</span>
<a name="l02259"></a>02259     }
<a name="l02260"></a>02260     <span class="comment">// distance from p0 to the line through the interection points</span>
<a name="l02261"></a>02261     <span class="keywordtype">double</span> a = (r0 * r0 - r1 * r1 + d * d) / (2 * d);
<a name="l02262"></a>02262     <span class="comment">// distance from bisection of that line to the intersections</span>
<a name="l02263"></a>02263     resultCenter = p0 + ptvec * a;
<a name="l02264"></a>02264     r = sqrt(r0 * r0 - a * a);
<a name="l02265"></a>02265     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02266"></a>02266 }
<a name="l02267"></a>02267 
<a name="l02268"></a>02268 <span class="comment">// Find a point on the sphere (center, radius) through which the tangent</span>
<a name="l02269"></a>02269 <span class="comment">// through pt passes. The point lies in the plane defined by</span>
<a name="l02270"></a>02270 <span class="comment">//the line pt-&gt;center and ray.</span>
<a name="l02271"></a><a class="code" href="_earth_manipulator_8cpp.html#a0959f5ef4d02a7c323a6284c3ba87705">02271</a> osg::Vec3d <a class="code" href="_earth_manipulator_8cpp.html#a0959f5ef4d02a7c323a6284c3ba87705">calcTangentPoint</a>(<span class="keyword">const</span> osg::Vec3d&amp; pt, <span class="keyword">const</span> osg::Vec3d&amp; center,
<a name="l02272"></a>02272                             <span class="keywordtype">double</span> radius, <span class="keyword">const</span> osg::Vec3d&amp; ray)
<a name="l02273"></a>02273 {
<a name="l02274"></a>02274     <span class="keyword">using namespace </span>osg;
<a name="l02275"></a>02275     <span class="comment">// new sphere with center at midpoint between pt and input sphere</span>
<a name="l02276"></a>02276     Vec3d center2 = (pt + center) / 2.0;
<a name="l02277"></a>02277     <span class="keywordtype">double</span> rad2 = (pt - center2).length();
<a name="l02278"></a>02278     Vec3d resCtr;
<a name="l02279"></a>02279     <span class="keywordtype">double</span> resRad;
<a name="l02280"></a>02280     <span class="comment">// Use Thales&#39; theorem, which states that a triangle inscribed in</span>
<a name="l02281"></a>02281     <span class="comment">// a circle, with two points on a diameter of the circle and the</span>
<a name="l02282"></a>02282     <span class="comment">// third on the circle, is a right triangle. Since one endpoint is</span>
<a name="l02283"></a>02283     <span class="comment">// the center of the original sphere (the earth) and the other is</span>
<a name="l02284"></a>02284     <span class="comment">// pt, we can get our tangent from that.</span>
<a name="l02285"></a>02285     <span class="keywordtype">bool</span> valid = <a class="code" href="_earth_manipulator_8cpp.html#a4d2138863db355e43a9d0d9ea603e69a">sphereInterection</a>(center, radius, center2, rad2, resCtr,
<a name="l02286"></a>02286                                    resRad);
<a name="l02287"></a>02287     <span class="keywordflow">if</span> (!valid)
<a name="l02288"></a>02288         <span class="keywordflow">return</span> Vec3d(0.0, 0.0, 0.0);
<a name="l02289"></a>02289     <span class="comment">// Get the tangent point that lies in the plane of the ray and the</span>
<a name="l02290"></a>02290     <span class="comment">// center line. The sequence of cross products gives us the point</span>
<a name="l02291"></a>02291     <span class="comment">// that is closest to the ray, rather than the one on the other</span>
<a name="l02292"></a>02292     <span class="comment">// side of the sphere.</span>
<a name="l02293"></a>02293     Vec3d toCenter = center - pt;
<a name="l02294"></a>02294     toCenter.normalize();
<a name="l02295"></a>02295     Vec3d normal = ray ^ toCenter;
<a name="l02296"></a>02296     normal.normalize();
<a name="l02297"></a>02297     Vec3d radial = toCenter ^ normal;
<a name="l02298"></a>02298     radial = radial * resRad;
<a name="l02299"></a>02299     Vec3d result = resCtr + radial;
<a name="l02300"></a>02300     <span class="keywordflow">return</span> result;
<a name="l02301"></a>02301     
<a name="l02302"></a>02302 }
<a name="l02303"></a>02303 <span class="comment">// Calculate a pointer click in eye coordinates</span>
<a name="l02304"></a><a class="code" href="_earth_manipulator_8cpp.html#ab49b57131a36a799c1f59f5552959d2d">02304</a> osg::Vec3d <a class="code" href="_earth_manipulator_8cpp.html#ab49b57131a36a799c1f59f5552959d2d">getWindowPoint</a>(osgViewer::View* view, <span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y)
<a name="l02305"></a>02305 {
<a name="l02306"></a>02306     <span class="keywordtype">float</span> local_x, local_y;
<a name="l02307"></a>02307     <span class="keyword">const</span> osg::Camera* camera
<a name="l02308"></a>02308         = view-&gt;getCameraContainingPosition(x, y, local_x, local_y);
<a name="l02309"></a>02309     <span class="keywordflow">if</span> (!camera)
<a name="l02310"></a>02310         camera = view-&gt;getCamera();
<a name="l02311"></a>02311     osg::Matrix winMat;
<a name="l02312"></a>02312     <span class="keywordflow">if</span> (camera-&gt;getViewport())
<a name="l02313"></a>02313         winMat = camera-&gt;getViewport()-&gt;computeWindowMatrix();
<a name="l02314"></a>02314     osg::Matrix projMat = camera-&gt;getProjectionMatrix();
<a name="l02315"></a>02315     <span class="comment">// ray from eye through pointer in camera coordinate system goes</span>
<a name="l02316"></a>02316     <span class="comment">// from origin through transformed pointer coordinates</span>
<a name="l02317"></a>02317     osg::Matrix win2camera = projMat * winMat;
<a name="l02318"></a>02318     win2camera.invert(win2camera);
<a name="l02319"></a>02319     osg::Vec4d winpt4 = osg::Vec4d(x, y, 0.0, 1.0) * win2camera;
<a name="l02320"></a>02320     winpt4 = winpt4 / winpt4.w();
<a name="l02321"></a>02321     <span class="keywordflow">return</span> osg::Vec3d(winpt4.x(), winpt4.y(), winpt4.z());
<a name="l02322"></a>02322 }
<a name="l02323"></a>02323 
<a name="l02324"></a>02324 <span class="comment">// Decompose  _center and _centerRotation into a longitude rotation</span>
<a name="l02325"></a>02325 <span class="comment">// and a latitude rotation + translation in the longitudinal plane.</span>
<a name="l02326"></a>02326 
<a name="l02327"></a><a class="code" href="_earth_manipulator_8cpp.html#a034a2b08c63923bd6ef915c126d5df27">02327</a> <span class="keywordtype">void</span> <a class="code" href="_earth_manipulator_8cpp.html#a034a2b08c63923bd6ef915c126d5df27">decomposeCenter</a>(<span class="keyword">const</span> osg::Vec3d&amp; center, <span class="keyword">const</span> osg::Quat&amp; centerRotation,
<a name="l02328"></a>02328                      osg::Matrix&amp; Me, osg::Matrix&amp; Mlon)
<a name="l02329"></a>02329 {
<a name="l02330"></a>02330     <span class="keyword">using namespace </span>osg;
<a name="l02331"></a>02331     Mlon.makeIdentity();
<a name="l02332"></a>02332     Matrix Mtotal(centerRotation);
<a name="l02333"></a>02333     Mtotal.setTrans(center);
<a name="l02334"></a>02334     <span class="comment">// Use the X axis to determine longitude rotation. Due to the</span>
<a name="l02335"></a>02335     <span class="comment">// OpenGL camera rotation, this axis will be the Y axis of the</span>
<a name="l02336"></a>02336     <span class="comment">// longitude matrix.</span>
<a name="l02337"></a>02337     Mlon(1, 0) = Mtotal(0, 0);  Mlon(1, 1) = Mtotal(0, 1);
<a name="l02338"></a>02338     <span class="comment">// X axis is rotated 90 degrees, obviously</span>
<a name="l02339"></a>02339     Mlon(0, 0) = Mlon(1, 1);  Mlon(0, 1) = -Mlon(1, 0);
<a name="l02340"></a>02340     Matrix MlonInv = Matrixd::inverse(Mlon);
<a name="l02341"></a>02341     Me = Mtotal * MlonInv;
<a name="l02342"></a>02342 }
<a name="l02343"></a>02343 
<a name="l02344"></a><a class="code" href="_earth_manipulator_8cpp.html#a80c81c3e96d0a90015536ef49e221c15">02344</a> osg::Matrixd <a class="code" href="_earth_manipulator_8cpp.html#a80c81c3e96d0a90015536ef49e221c15">rotateAroundPoint</a>(<span class="keyword">const</span> osg::Vec3d&amp; pt, <span class="keywordtype">double</span> theta,
<a name="l02345"></a>02345                                <span class="keyword">const</span> osg::Vec3d&amp; axis)
<a name="l02346"></a>02346 {
<a name="l02347"></a>02347     <span class="keywordflow">return</span> (osg::Matrixd::translate(pt)
<a name="l02348"></a>02348             * osg::Matrixd::rotate(theta, axis)
<a name="l02349"></a>02349             * osg::Matrixd::translate(pt * -1.0));
<a name="l02350"></a>02350 }
<a name="l02351"></a>02351 
<a name="l02352"></a>02352 <span class="comment">// Theory of operation for the manipulator drag motion</span>
<a name="l02353"></a>02353 <span class="comment">//</span>
<a name="l02354"></a>02354 <span class="comment">// The mouse drag is transformed to a vector on the surface of the</span>
<a name="l02355"></a>02355 <span class="comment">// earth i.e., in the surface plane at the start of the drag. This is</span>
<a name="l02356"></a>02356 <span class="comment">// treated as a displacement along the arc of a great circle. The</span>
<a name="l02357"></a>02357 <span class="comment">// earth will be rotated by the equivalent rotation around the axis of</span>
<a name="l02358"></a>02358 <span class="comment">// the circle. However, the manipulator controls the camera, not the</span>
<a name="l02359"></a>02359 <span class="comment">// earth, so the camera&#39;s placement matrix (inverse view matrix)</span>
<a name="l02360"></a>02360 <span class="comment">// should be rotated by the inverse of the calculated</span>
<a name="l02361"></a>02361 <span class="comment">// rotation. EarthManipulator represents the placement matrix as the</span>
<a name="l02362"></a>02362 <span class="comment">// concatenation of 4 transformations: distance from focal point,</span>
<a name="l02363"></a>02363 <span class="comment">// local heading and pitch, rotation to frame of focal point, focal</span>
<a name="l02364"></a>02364 <span class="comment">// point. To change the camera placement we rotate the frame rotation</span>
<a name="l02365"></a>02365 <span class="comment">// (_centerRotation) and focal point (_center).</span>
<a name="l02366"></a>02366 <span class="comment">//</span>
<a name="l02367"></a>02367 <span class="comment">// When the start or end drag click is not on the earth, we choose the</span>
<a name="l02368"></a>02368 <span class="comment">// nearest tangent point on the earth to the ray from the eye and</span>
<a name="l02369"></a>02369 <span class="comment">// proceed.</span>
<a name="l02370"></a>02370 
<a name="l02371"></a>02371 <span class="keywordtype">void</span>
<a name="l02372"></a>02372 EarthManipulator::drag(<span class="keywordtype">double</span> dx, <span class="keywordtype">double</span> dy, osg::View* theView)
<a name="l02373"></a>02373 {
<a name="l02374"></a>02374     <span class="keyword">using namespace </span>osg;
<a name="l02375"></a>02375     <span class="keyword">const</span> osg::Vec3d zero(0.0, 0.0, 0.0);
<a name="l02376"></a>02376     <span class="keywordflow">if</span> (_last_action._type != ACTION_EARTH_DRAG)
<a name="l02377"></a>02377         _lastPointOnEarth = zero;
<a name="l02378"></a>02378 
<a name="l02379"></a>02379     ref_ptr&lt;osg::CoordinateSystemNode&gt; csnSafe = _csn.get();
<a name="l02380"></a>02380     <span class="keywordtype">double</span> radiusEquator = csnSafe.valid() ? csnSafe-&gt;getEllipsoidModel()-&gt;getRadiusEquator() : 6378137.0;
<a name="l02381"></a>02381 
<a name="l02382"></a>02382     osgViewer::View* view = <span class="keyword">dynamic_cast&lt;</span>osgViewer::View*<span class="keyword">&gt;</span>(theView);
<a name="l02383"></a>02383     <span class="keywordtype">float</span> x = _ga_t0-&gt;getX(), y = _ga_t0-&gt;getY();
<a name="l02384"></a>02384     <span class="keywordtype">float</span> local_x, local_y;
<a name="l02385"></a>02385     <span class="keyword">const</span> osg::Camera* camera
<a name="l02386"></a>02386         = view-&gt;getCameraContainingPosition(x, y, local_x, local_y);
<a name="l02387"></a>02387     <span class="keywordflow">if</span> (!camera)
<a name="l02388"></a>02388         camera = view-&gt;getCamera();
<a name="l02389"></a>02389     osg::Matrix viewMat = camera-&gt;getViewMatrix();
<a name="l02390"></a>02390     osg::Matrix viewMatInv = camera-&gt;getInverseViewMatrix();
<a name="l02391"></a>02391     <span class="keywordflow">if</span> (!_ga_t1.valid())
<a name="l02392"></a>02392         <span class="keywordflow">return</span>;
<a name="l02393"></a>02393     osg::Vec3d worldStartDrag;
<a name="l02394"></a>02394     <span class="comment">// drag start in camera coordinate system.</span>
<a name="l02395"></a>02395     <span class="keywordtype">bool</span> onEarth;
<a name="l02396"></a>02396     <span class="keywordflow">if</span> ((onEarth = screenToWorld(_ga_t1-&gt;getX(), _ga_t1-&gt;getY(),
<a name="l02397"></a>02397                                   view, worldStartDrag)))
<a name="l02398"></a>02398     {
<a name="l02399"></a>02399         <span class="keywordflow">if</span> (_lastPointOnEarth == zero)
<a name="l02400"></a>02400             _lastPointOnEarth = worldStartDrag;
<a name="l02401"></a>02401         <span class="keywordflow">else</span>
<a name="l02402"></a>02402             worldStartDrag = _lastPointOnEarth;
<a name="l02403"></a>02403     }
<a name="l02404"></a>02404     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_is_geocentric)
<a name="l02405"></a>02405     {
<a name="l02406"></a>02406         <span class="keywordflow">if</span> (_lastPointOnEarth != zero)
<a name="l02407"></a>02407         {
<a name="l02408"></a>02408             worldStartDrag =_lastPointOnEarth;
<a name="l02409"></a>02409         }
<a name="l02410"></a>02410         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (csnSafe.valid())
<a name="l02411"></a>02411         {
<a name="l02412"></a>02412             <span class="keyword">const</span> osg::Vec3d startWinPt = <a class="code" href="_earth_manipulator_8cpp.html#ab49b57131a36a799c1f59f5552959d2d">getWindowPoint</a>(view, _ga_t1-&gt;getX(),
<a name="l02413"></a>02413                                                          _ga_t1-&gt;getY());
<a name="l02414"></a>02414             <span class="keyword">const</span> osg::Vec3d startDrag = <a class="code" href="_earth_manipulator_8cpp.html#a0959f5ef4d02a7c323a6284c3ba87705">calcTangentPoint</a>(
<a name="l02415"></a>02415                 zero, zero * viewMat, radiusEquator,
<a name="l02416"></a>02416                 startWinPt);
<a name="l02417"></a>02417             worldStartDrag = startDrag * viewMatInv;
<a name="l02418"></a>02418         }
<a name="l02419"></a>02419     }
<a name="l02420"></a>02420     <span class="keywordflow">else</span>
<a name="l02421"></a>02421         <span class="keywordflow">return</span>;
<a name="l02422"></a>02422     <span class="comment">// ray from eye through pointer in camera coordinate system goes</span>
<a name="l02423"></a>02423     <span class="comment">// from origin through transformed pointer coordinates</span>
<a name="l02424"></a>02424     <span class="keyword">const</span> osg::Vec3d winpt = <a class="code" href="_earth_manipulator_8cpp.html#ab49b57131a36a799c1f59f5552959d2d">getWindowPoint</a>(view, x, y);
<a name="l02425"></a>02425     <span class="comment">// Find new point to which startDrag has been moved</span>
<a name="l02426"></a>02426     osg::Vec3d worldEndDrag;
<a name="l02427"></a>02427     osg::Quat worldRot;
<a name="l02428"></a>02428     <span class="keywordtype">bool</span> endOnEarth = screenToWorld(x, y, view, worldEndDrag);
<a name="l02429"></a>02429     <span class="keywordflow">if</span> (endOnEarth)
<a name="l02430"></a>02430     {
<a name="l02431"></a>02431         <span class="comment">// OE_WARN &lt;&lt; &quot;end drag: &quot; &lt;&lt; worldEndDrag &lt;&lt; &quot;\n&quot;;</span>
<a name="l02432"></a>02432     }
<a name="l02433"></a>02433     <span class="keywordflow">else</span>
<a name="l02434"></a>02434     {
<a name="l02435"></a>02435         Vec3d earthOrigin = zero * viewMat;
<a name="l02436"></a>02436         <span class="keyword">const</span> osg::Vec3d endDrag = <a class="code" href="_earth_manipulator_8cpp.html#a0959f5ef4d02a7c323a6284c3ba87705">calcTangentPoint</a>(
<a name="l02437"></a>02437             zero, earthOrigin, radiusEquator, winpt);
<a name="l02438"></a>02438         worldEndDrag = endDrag * viewMatInv;
<a name="l02439"></a>02439         OE_INFO &lt;&lt; <span class="stringliteral">&quot;tangent: &quot;</span> &lt;&lt; worldEndDrag &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l02440"></a>02440     }
<a name="l02441"></a>02441 
<a name="l02442"></a>02442 <span class="preprocessor">#if 0</span>
<a name="l02443"></a>02443 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (onEarth != endOnEarth)
<a name="l02444"></a>02444     {
<a name="l02445"></a>02445         std::streamsize oldPrecision = osgEarth::notify(INFO).precision(10);
<a name="l02446"></a>02446         OE_INFO &lt;&lt; (onEarth ? <span class="stringliteral">&quot;leaving earth\n&quot;</span> : <span class="stringliteral">&quot;entering earth\n&quot;</span>);
<a name="l02447"></a>02447         OE_INFO &lt;&lt; <span class="stringliteral">&quot;start drag: &quot;</span> &lt;&lt; worldStartDrag.x() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>
<a name="l02448"></a>02448                 &lt;&lt; worldStartDrag.y() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>
<a name="l02449"></a>02449                 &lt;&lt; worldStartDrag.z() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l02450"></a>02450         OE_INFO &lt;&lt; <span class="stringliteral">&quot;end drag: &quot;</span> &lt;&lt; worldEndDrag.x() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>
<a name="l02451"></a>02451                 &lt;&lt; worldEndDrag.y() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>
<a name="l02452"></a>02452                 &lt;&lt; worldEndDrag.z() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l02453"></a>02453         osgEarth::notify(INFO).precision(oldPrecision);
<a name="l02454"></a>02454     }
<a name="l02455"></a>02455 <span class="preprocessor">#endif</span>
<a name="l02456"></a>02456 <span class="preprocessor"></span>
<a name="l02457"></a>02457     <span class="keywordflow">if</span> (_is_geocentric)
<a name="l02458"></a>02458     {
<a name="l02459"></a>02459         worldRot.makeRotate(worldStartDrag, worldEndDrag);
<a name="l02460"></a>02460         <span class="comment">// Move the camera by the inverse rotation</span>
<a name="l02461"></a>02461         Quat cameraRot = worldRot.conj();
<a name="l02462"></a>02462         <span class="comment">// Derive manipulator parameters from the camera matrix. We</span>
<a name="l02463"></a>02463         <span class="comment">// can&#39;t use _center, _centerRotation, and _rotation directly</span>
<a name="l02464"></a>02464         <span class="comment">// from the manipulator because they may have been updated</span>
<a name="l02465"></a>02465         <span class="comment">// already this frame while the camera view matrix,</span>
<a name="l02466"></a>02466         <span class="comment">// used to do the terrain intersection, has not. This happens</span>
<a name="l02467"></a>02467         <span class="comment">// when several mouse movement events arrive in a frame. there</span>
<a name="l02468"></a>02468         <span class="comment">// will be bad stuttering artifacts if we use the updated</span>
<a name="l02469"></a>02469         <span class="comment">// manipulator parameters.</span>
<a name="l02470"></a>02470         Matrixd Mmanip = Matrixd::translate(_offset_x, _offset_y, -_distance)
<a name="l02471"></a>02471             * viewMatInv;
<a name="l02472"></a>02472         Vec3d center = Mmanip.getTrans();
<a name="l02473"></a>02473         Quat centerRotation = makeCenterRotation(center);
<a name="l02474"></a>02474         Matrixd Mrotation = (Mmanip * Matrixd::translate(center * -1)
<a name="l02475"></a>02475                              * Matrixd::rotate(centerRotation.inverse()));
<a name="l02476"></a>02476         Matrixd Me = Matrixd::rotate(centerRotation)
<a name="l02477"></a>02477             * Matrixd::translate(center) * Matrixd::rotate(cameraRot);
<a name="l02478"></a>02478         <span class="comment">// In order for the Viewpoint settings to make sense, the</span>
<a name="l02479"></a>02479         <span class="comment">// inverse camera matrix must not have a roll component, which</span>
<a name="l02480"></a>02480         <span class="comment">// implies that its x axis remains parallel to the</span>
<a name="l02481"></a>02481         <span class="comment">// z = 0 plane. The strategy for doing that is different if</span>
<a name="l02482"></a>02482         <span class="comment">// the azimuth is locked.</span>
<a name="l02483"></a>02483         <span class="comment">// Additionally, the part of the camera rotation defined by</span>
<a name="l02484"></a>02484         <span class="comment">// _centerRotation must be oriented with the local frame of</span>
<a name="l02485"></a>02485         <span class="comment">// _center on the ellipsoid. For the purposes of the drag</span>
<a name="l02486"></a>02486         <span class="comment">// motion this is nearly identical to the frame obtained by</span>
<a name="l02487"></a>02487         <span class="comment">// the trackball motion, so we just fix it up at the end.</span>
<a name="l02488"></a>02488         <span class="keywordflow">if</span> (_settings-&gt;getLockAzimuthWhilePanning())
<a name="l02489"></a>02489         {
<a name="l02490"></a>02490             <span class="comment">// The camera needs to be rotated that _centerRotation</span>
<a name="l02491"></a>02491             <span class="comment">// is a rotation only around the global Z axis and the</span>
<a name="l02492"></a>02492             <span class="comment">// camera frame X axis. We don&#39;t change _rotation, so that</span>
<a name="l02493"></a>02493             <span class="comment">// azimuth and pitch will stay constant, but the drag must</span>
<a name="l02494"></a>02494             <span class="comment">// still be correct i.e.,  the point dragged must remain</span>
<a name="l02495"></a>02495             <span class="comment">// under the cursor. Therefore the rotation must be around the</span>
<a name="l02496"></a>02496             <span class="comment">// point that was dragged, worldEndDrag.</span>
<a name="l02497"></a>02497             <span class="comment">//</span>
<a name="l02498"></a>02498             <span class="comment">// Rotate Me so that its x axis is parallel to the z=0</span>
<a name="l02499"></a>02499             <span class="comment">// plane. </span>
<a name="l02500"></a>02500             <span class="comment">// Find cone with worldEndDrag-&gt;center axis and x</span>
<a name="l02501"></a>02501             <span class="comment">// axis of coordinate frame as generator of the conical</span>
<a name="l02502"></a>02502             <span class="comment">// surface.</span>
<a name="l02503"></a>02503             Vec3d coneAxis = worldEndDrag * -1;
<a name="l02504"></a>02504             coneAxis.normalize();
<a name="l02505"></a>02505             Vec3d xAxis(Me(0, 0), Me(0, 1), Me(0, 2));
<a name="l02506"></a>02506             <span class="comment">// Center of disk: project xAxis onto coneAxis</span>
<a name="l02507"></a>02507             <span class="keywordtype">double</span> diskDist = xAxis * coneAxis;
<a name="l02508"></a>02508             Vec3d P1 = coneAxis * diskDist;
<a name="l02509"></a>02509             <span class="comment">// Basis of disk equation:</span>
<a name="l02510"></a>02510             <span class="comment">// p = P1 + R * r * cos(theta) + S * r * sin(theta)</span>
<a name="l02511"></a>02511             Vec3d R = xAxis - P1;
<a name="l02512"></a>02512             Vec3d S = R ^ coneAxis;
<a name="l02513"></a>02513             <span class="keywordtype">double</span> r = R.normalize();
<a name="l02514"></a>02514             S.normalize();
<a name="l02515"></a>02515             <span class="comment">// Solve for angle that rotates xAxis into z = 0 plane.</span>
<a name="l02516"></a>02516             <span class="comment">// soln to 0 = P1.z + r cos(theta) R.z + r sin(theta) S.z</span>
<a name="l02517"></a>02517             <span class="keywordtype">double</span> temp1 = r * (square(S.z()) + square(R.z()));
<a name="l02518"></a>02518             <span class="keywordflow">if</span> (equivalent(temp1, 0.0))
<a name="l02519"></a>02519                 <span class="keywordflow">return</span>;
<a name="l02520"></a>02520             <span class="keywordtype">double</span> radical = r * temp1 - square(P1.z());
<a name="l02521"></a>02521             <span class="keywordflow">if</span> (radical &lt; 0)
<a name="l02522"></a>02522                 <span class="keywordflow">return</span>;
<a name="l02523"></a>02523             <span class="keywordtype">double</span> temp2 = R.z() * sqrt(radical) / temp1;
<a name="l02524"></a>02524             <span class="keywordtype">double</span> temp3 = S.z() * P1.z() / temp1;
<a name="l02525"></a>02525             <span class="keywordtype">double</span> sin1 = temp2 + temp3;
<a name="l02526"></a>02526             <span class="keywordtype">double</span> sin2 = temp2 - temp3;
<a name="l02527"></a>02527             <span class="keywordtype">double</span> theta1 = DBL_MAX;
<a name="l02528"></a>02528             <span class="keywordtype">double</span> theta2 = DBL_MAX;
<a name="l02529"></a>02529             Matrixd cm1, cm2;
<a name="l02530"></a>02530             <span class="keywordflow">if</span> (fabs(sin1) &lt;= 1.0)
<a name="l02531"></a>02531             {
<a name="l02532"></a>02532                 theta1 = -asin(sin1);
<a name="l02533"></a>02533                 Matrixd m = <a class="code" href="_earth_manipulator_8cpp.html#a80c81c3e96d0a90015536ef49e221c15">rotateAroundPoint</a>(worldEndDrag, -theta1, coneAxis);
<a name="l02534"></a>02534                 cm1 = Me * m;
<a name="l02535"></a>02535             }
<a name="l02536"></a>02536             <span class="keywordflow">if</span> (fabs(sin2) &lt;= 1.0)
<a name="l02537"></a>02537             {
<a name="l02538"></a>02538                 theta2 = asin(sin2);
<a name="l02539"></a>02539                 Matrix m = <a class="code" href="_earth_manipulator_8cpp.html#a80c81c3e96d0a90015536ef49e221c15">rotateAroundPoint</a>(worldEndDrag, -theta2, coneAxis);
<a name="l02540"></a>02540                 cm2 = Me * m;
<a name="l02541"></a>02541             }
<a name="l02542"></a>02542             <span class="keywordflow">if</span> (theta1 == DBL_MAX &amp;&amp; theta2 == DBL_MAX)
<a name="l02543"></a>02543                 <span class="keywordflow">return</span>;
<a name="l02544"></a>02544             Matrixd* CameraMat = 0;
<a name="l02545"></a>02545             <span class="keywordflow">if</span> (theta1 != DBL_MAX &amp;&amp; cm1(1, 2) &gt;= 0.0)
<a name="l02546"></a>02546                 CameraMat = &amp;cm1;
<a name="l02547"></a>02547             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (theta2 != DBL_MAX &amp;&amp; cm2(1, 2) &gt;= 0.0)
<a name="l02548"></a>02548                 CameraMat = &amp;cm2;
<a name="l02549"></a>02549             <span class="keywordflow">else</span>
<a name="l02550"></a>02550                 <span class="keywordflow">return</span>;
<a name="l02551"></a>02551             _center = CameraMat-&gt;getTrans();
<a name="l02552"></a>02552         }
<a name="l02553"></a>02553         <span class="keywordflow">else</span>
<a name="l02554"></a>02554         {
<a name="l02555"></a>02555             <span class="comment">// The camera matrix must be rotated around the local Z axis so</span>
<a name="l02556"></a>02556             <span class="comment">// that the X axis is parallel to the global z = 0</span>
<a name="l02557"></a>02557             <span class="comment">// plane. Then, _rotation is rotated by the inverse</span>
<a name="l02558"></a>02558             <span class="comment">// rotation to preserve the total transformation.</span>
<a name="l02559"></a>02559             <span class="keywordtype">double</span> theta = atan2(-Me(0, 2), Me(1, 2));
<a name="l02560"></a>02560             <span class="keywordtype">double</span> s = sin(theta), c = cos(theta);
<a name="l02561"></a>02561             <span class="keywordflow">if</span> (c * Me(1, 2) - s * Me(0, 2) &lt; 0.0)
<a name="l02562"></a>02562             {
<a name="l02563"></a>02563                 s = -s;
<a name="l02564"></a>02564                 c = -c;
<a name="l02565"></a>02565             }
<a name="l02566"></a>02566             Matrixd m(c, s, 0, 0,
<a name="l02567"></a>02567                       -s, c, 0, 0,
<a name="l02568"></a>02568                       0, 0, 1, 0,
<a name="l02569"></a>02569                       0, 0, 0, 1);
<a name="l02570"></a>02570             Matrixd CameraMat = m * Me;
<a name="l02571"></a>02571             _center = CameraMat.getTrans();
<a name="l02572"></a>02572             <span class="comment">// It&#39;s not necessary to include the translation</span>
<a name="l02573"></a>02573             <span class="comment">// component, but it&#39;s useful for debugging.</span>
<a name="l02574"></a>02574             Matrixd headMat
<a name="l02575"></a>02575                 = (Matrixd::translate(-_offset_x, -_offset_y, _distance)
<a name="l02576"></a>02576                    * Mrotation);
<a name="l02577"></a>02577             headMat = headMat * Matrixd::inverse(m);
<a name="l02578"></a>02578             _rotation = headMat.getRotate();
<a name="l02579"></a>02579             recalculateLocalPitchAndAzimuth();
<a name="l02580"></a>02580         }
<a name="l02581"></a>02581         _centerRotation = makeCenterRotation(_center);
<a name="l02582"></a>02582         CoordinateFrame local_frame = getMyCoordinateFrame(_center);
<a name="l02583"></a>02583         _previousUp = getUpVector(local_frame);
<a name="l02584"></a>02584     }
<a name="l02585"></a>02585     <span class="keywordflow">else</span>
<a name="l02586"></a>02586     {
<a name="l02587"></a>02587         <span class="comment">// This is obviously not correct.</span>
<a name="l02588"></a>02588         _center = _center + (worldStartDrag - worldEndDrag);
<a name="l02589"></a>02589     }
<a name="l02590"></a>02590 }
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="_earth_manipulator_8cpp.html">EarthManipulator.cpp</a>      </li>
      <li class="footer">Generated on Tue Jan 17 2012 18:35:19 for osgEarth by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
