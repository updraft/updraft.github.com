<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>osgEarth: /home/cube/sources/osgearth/src/osgEarthDrivers/engine_seamless/Euler.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">osgEarth&#160;<span id="projectnumber">2.1.1</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>/home/cube/sources/osgearth/src/osgEarthDrivers/engine_seamless/Euler.cpp</h1>  </div>
</div>
<div class="contents">
<a href="Euler_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright 2010 Pelican Ventures, Inc.</span>
<a name="l00003"></a>00003 <span class="comment"> * http://osgearth.org</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * osgEarth is free software; you can redistribute it and/or modify</span>
<a name="l00006"></a>00006 <span class="comment"> * it under the terms of the GNU Lesser General Public License as published by</span>
<a name="l00007"></a>00007 <span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00008"></a>00008 <span class="comment"> * (at your option) any later version.</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
<a name="l00011"></a>00011 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00013"></a>00013 <span class="comment"> * GNU Lesser General Public License for more details.</span>
<a name="l00014"></a>00014 <span class="comment"> *</span>
<a name="l00015"></a>00015 <span class="comment"> * You should have received a copy of the GNU Lesser General Public License</span>
<a name="l00016"></a>00016 <span class="comment"> * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;</span>
<a name="l00017"></a>00017 <span class="comment"> */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;<a class="code" href="Euler.html">Euler</a>&quot;</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;osg/Math&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;osg/CoordinateSystemNode&gt;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;osgEarth/Registry&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;ogr_api.h&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;ogr_spatialref.h&gt;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="AutoBuffer.html">AutoBuffer</a>&quot;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a><a class="code" href="Euler_8cpp.html#aa499bb75bb504909cd0a72baf48c4653">00033</a> <span class="preprocessor">#define LC &quot;[seamless::EULER] &quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span>
<a name="l00035"></a>00035 <span class="keyword">namespace </span>seamless
<a name="l00036"></a>00036 {
<a name="l00037"></a>00037 <span class="keyword">using namespace </span>std;
<a name="l00038"></a>00038 <span class="keyword">using namespace </span>osg;
<a name="l00039"></a>00039 <span class="keyword">using namespace </span>osgEarth;
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="comment">// Constants used througout</span>
<a name="l00042"></a>00042 
<a name="l00043"></a><a class="code" href="namespaceseamless.html#adeb1b09a86ef39d7cc091bd36e03cafd">00043</a> <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceseamless.html#adeb1b09a86ef39d7cc091bd36e03cafd">PiOver12</a> = PI / 12.0;
<a name="l00044"></a><a class="code" href="namespaceseamless.html#ad63d946792a53e7c7d57115cca4663e1">00044</a> <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceseamless.html#ad63d946792a53e7c7d57115cca4663e1">PiOver12Inv</a> = 12.0 / PI;
<a name="l00045"></a><a class="code" href="namespaceseamless.html#a9521be90c7ad12f9a2d1a94f856f5951">00045</a> <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceseamless.html#a9521be90c7ad12f9a2d1a94f856f5951">sqrt2</a> = 1.41421356237309504880; <span class="comment">// sqrt(2)</span>
<a name="l00046"></a><a class="code" href="namespaceseamless.html#a4bffe8b9e4f59c91a8f7725ae0558d93">00046</a> <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceseamless.html#a4bffe8b9e4f59c91a8f7725ae0558d93">sqrt33</a> = .5773502691896258; <span class="comment">// sqrt(3) / 3</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="keyword">namespace </span>euler
<a name="l00049"></a>00049 {
<a name="l00050"></a>00050 <span class="keywordtype">bool</span> <a class="code" href="namespaceseamless_1_1euler.html#ae370edb27fca30b8656dc8140a305801">lineLineIntersect</a>(
<a name="l00051"></a>00051     <span class="keyword">const</span> Vec3d&amp; p1, <span class="keyword">const</span> Vec3d&amp; p2, <span class="keyword">const</span> Vec3d&amp; p3, <span class="keyword">const</span> Vec3d&amp; p4,
<a name="l00052"></a>00052     Vec3d&amp; pa,Vec3d&amp; pb, <span class="keywordtype">double</span>&amp; mua, <span class="keywordtype">double</span>&amp; mub);
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="comment">// Convert lat, lon to a unit vector on a sphere (direction cosine)</span>
<a name="l00055"></a>00055 
<a name="l00056"></a><a class="code" href="namespaceseamless_1_1euler.html#ad86ebc92d393f0d4dc72ab45c99f6591">00056</a> <span class="keyword">inline</span> Vec3d <a class="code" href="namespaceseamless_1_1euler.html#ad86ebc92d393f0d4dc72ab45c99f6591">latLon2xyz</a>(<span class="keywordtype">double</span> lat_deg, <span class="keywordtype">double</span> lon_deg)
<a name="l00057"></a>00057 {
<a name="l00058"></a>00058     Vec3d result;
<a name="l00059"></a>00059     result.z() = sin(DegreesToRadians(lat_deg));
<a name="l00060"></a>00060     <span class="keywordtype">double</span> hyp = sqrt(1 - result.z() * result.z());
<a name="l00061"></a>00061     <span class="keywordtype">double</span> long_rad = DegreesToRadians(lon_deg);
<a name="l00062"></a>00062     result.x() = hyp * cos(long_rad);
<a name="l00063"></a>00063     result.y() = hyp * sin(long_rad);
<a name="l00064"></a>00064     <span class="keywordflow">return</span> result;
<a name="l00065"></a>00065 }
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 <span class="comment">// On a boundary, return the lower-numbered face.</span>
<a name="l00068"></a><a class="code" href="namespaceseamless_1_1euler.html#a9403dbf2c337e40a4e305884258540ac">00068</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="namespaceseamless_1_1euler.html#a9403dbf2c337e40a4e305884258540ac">getFace</a>(<span class="keyword">const</span> Vec3d&amp; vec)
<a name="l00069"></a>00069 {
<a name="l00070"></a>00070     <span class="keywordtype">double</span> absx = fabs(vec.x());
<a name="l00071"></a>00071     <span class="keywordtype">double</span> absy = fabs(vec.y());
<a name="l00072"></a>00072     <span class="keywordtype">double</span> absz = fabs(vec.z());
<a name="l00073"></a>00073     <span class="comment">// pole faces</span>
<a name="l00074"></a>00074     <span class="keywordflow">if</span> (absz &gt; (absx + 1e-11) &amp;&amp; absz &gt; (absy + 1e-11))
<a name="l00075"></a>00075     {
<a name="l00076"></a>00076         <span class="keywordflow">if</span> (vec.z() &gt; 0.0)
<a name="l00077"></a>00077             <span class="keywordflow">return</span> 4;
<a name="l00078"></a>00078         <span class="keywordflow">else</span>
<a name="l00079"></a>00079             <span class="keywordflow">return</span> 5;
<a name="l00080"></a>00080     }
<a name="l00081"></a>00081     <span class="comment">// One of the X faces, unless on a border</span>
<a name="l00082"></a>00082     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (absx &gt; absy || equivalent(absx, absy, 1e-11))
<a name="l00083"></a>00083     {
<a name="l00084"></a>00084         <span class="keywordflow">if</span> (vec.x() &gt; 0.0)
<a name="l00085"></a>00085             <span class="keywordflow">return</span> 0;
<a name="l00086"></a>00086         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (equivalent(vec.x(), -vec.y(), 1e-11))
<a name="l00087"></a>00087             <span class="keywordflow">return</span> 1;           <span class="comment">// Boundary between 1 and 2</span>
<a name="l00088"></a>00088         <span class="keywordflow">else</span>
<a name="l00089"></a>00089             <span class="keywordflow">return</span> 2;
<a name="l00090"></a>00090     }
<a name="l00091"></a>00091     <span class="comment">// One of the Y faces</span>
<a name="l00092"></a>00092     <span class="keywordflow">else</span>
<a name="l00093"></a>00093     {
<a name="l00094"></a>00094         <span class="keywordflow">if</span> (vec.y() &gt; 0.0)
<a name="l00095"></a>00095             <span class="keywordflow">return</span> 1;
<a name="l00096"></a>00096         <span class="keywordflow">else</span>
<a name="l00097"></a>00097             <span class="keywordflow">return</span> 3;
<a name="l00098"></a>00098     }
<a name="l00099"></a>00099 }
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="comment">// Convert unit vector to coordinates on a face. q is normal to the</span>
<a name="l00102"></a>00102 <span class="comment">// face. r and s correspond to x and y face coordinates. q is stored</span>
<a name="l00103"></a>00103 <span class="comment">// in the z member of Vec3d so that the r,s,q form a nice orthogonal</span>
<a name="l00104"></a>00104 <span class="comment">// coordinate system.</span>
<a name="l00105"></a>00105 
<a name="l00106"></a><a class="code" href="namespaceseamless_1_1euler.html#afc0929cc01450dd3fccd982a7a45ef19">00106</a> Vec3d <a class="code" href="namespaceseamless_1_1euler.html#afc0929cc01450dd3fccd982a7a45ef19">xyz2qrs</a>(<span class="keyword">const</span> Vec3d&amp; xyz, <span class="keywordtype">int</span> face)
<a name="l00107"></a>00107 {
<a name="l00108"></a>00108     <span class="keywordflow">switch</span> (face)
<a name="l00109"></a>00109     {
<a name="l00110"></a>00110     <span class="keywordflow">case</span> 0:
<a name="l00111"></a>00111         <span class="keywordflow">return</span> Vec3d(xyz.y(), xyz.z(), xyz.x());
<a name="l00112"></a>00112     <span class="keywordflow">case</span> 1:
<a name="l00113"></a>00113         <span class="keywordflow">return</span> Vec3d(-xyz.x(), xyz.z(), xyz.y());
<a name="l00114"></a>00114     <span class="keywordflow">case</span> 2:
<a name="l00115"></a>00115         <span class="keywordflow">return</span> Vec3d(-xyz.y(), xyz.z(), -xyz.x());
<a name="l00116"></a>00116     <span class="keywordflow">case</span> 3:
<a name="l00117"></a>00117         <span class="keywordflow">return</span> Vec3d(xyz.x(), xyz.z(), -xyz.y());
<a name="l00118"></a>00118     <span class="keywordflow">case</span> 4:
<a name="l00119"></a>00119         <span class="keywordflow">return</span> Vec3d(xyz.y(), -xyz.x(), xyz.z());
<a name="l00120"></a>00120     <span class="keywordflow">case</span> 5:
<a name="l00121"></a>00121         <span class="keywordflow">return</span> Vec3d(xyz.y(), xyz.x(), -xyz.z());
<a name="l00122"></a>00122     <span class="keywordflow">default</span>:
<a name="l00123"></a>00123         <span class="keywordflow">return</span> Vec3d(0, 0, 0);
<a name="l00124"></a>00124     }
<a name="l00125"></a>00125 }
<a name="l00126"></a>00126 
<a name="l00127"></a><a class="code" href="namespaceseamless_1_1euler.html#a68a059dd37e98c13091a4399ee9b8f59">00127</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceseamless_1_1euler.html#a68a059dd37e98c13091a4399ee9b8f59">latLonToFaceCoords</a>(<span class="keywordtype">double</span> lat_deg, <span class="keywordtype">double</span> lon_deg,
<a name="l00128"></a>00128                         <span class="keywordtype">double</span>&amp; out_x, <span class="keywordtype">double</span>&amp; out_y, <span class="keywordtype">int</span>&amp; out_face,
<a name="l00129"></a>00129                         <span class="keywordtype">int</span> faceHint)
<a name="l00130"></a>00130 {
<a name="l00131"></a>00131     <span class="keywordflow">if</span> (lat_deg &gt; 90.0 || lat_deg &lt; -90.0
<a name="l00132"></a>00132         || lon_deg &lt; -180.0 || lon_deg &gt; 180.0)
<a name="l00133"></a>00133         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00134"></a>00134     Vec3d xyz = <a class="code" href="namespaceseamless_1_1euler.html#ad86ebc92d393f0d4dc72ab45c99f6591">latLon2xyz</a>(lat_deg, lon_deg);
<a name="l00135"></a>00135     out_face = faceHint &gt;= 0 ? faceHint : <a class="code" href="namespaceseamless_1_1euler.html#a9403dbf2c337e40a4e305884258540ac">getFace</a>(xyz);
<a name="l00136"></a>00136     Vec3d qrs = <a class="code" href="namespaceseamless_1_1euler.html#afc0929cc01450dd3fccd982a7a45ef19">xyz2qrs</a>(xyz, out_face);
<a name="l00137"></a>00137 
<a name="l00138"></a>00138     <span class="keywordtype">double</span> xang = atan2(qrs[0], qrs[2]);
<a name="l00139"></a>00139     <span class="keywordtype">double</span> yang = atan2(qrs[1], qrs[2]);
<a name="l00140"></a>00140     out_x = xang / osg::PI_4;
<a name="l00141"></a>00141     out_y = yang / osg::PI_4;
<a name="l00142"></a>00142     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00143"></a>00143 }
<a name="l00144"></a>00144 
<a name="l00145"></a><a class="code" href="namespaceseamless_1_1euler.html#a8dff64a39588634c97fca018b82a6f64">00145</a> Vec3d <a class="code" href="namespaceseamless_1_1euler.html#a8dff64a39588634c97fca018b82a6f64">face2qrs</a>(<span class="keyword">const</span> Vec2d&amp; face)
<a name="l00146"></a>00146 {
<a name="l00147"></a>00147     <span class="keywordtype">double</span> xang = face[0] * osg::PI_4;
<a name="l00148"></a>00148     <span class="keywordtype">double</span> yang = face[1] * osg::PI_4;
<a name="l00149"></a>00149     <span class="keywordtype">double</span> sx = sin(xang), cx = cos(xang);
<a name="l00150"></a>00150     <span class="keywordtype">double</span> ty = tan(yang);
<a name="l00151"></a>00151     <span class="comment">// phi is a latitude measure, in the longitudinal plane</span>
<a name="l00152"></a>00152     <span class="keywordtype">double</span> tanPhi = cx * ty;
<a name="l00153"></a>00153     <span class="keywordtype">double</span> radical = sqrt(1 + tanPhi * tanPhi);
<a name="l00154"></a>00154     <span class="keywordtype">double</span> c = 1.0 / radical;
<a name="l00155"></a>00155     Vec3d result;
<a name="l00156"></a>00156     <span class="keywordtype">double</span> b = tanPhi * c;      <span class="comment">// b gets the right sign</span>
<a name="l00157"></a>00157     result.x() = c * sx;
<a name="l00158"></a>00158     result.y() = b;
<a name="l00159"></a>00159     result.z() = c * cx;
<a name="l00160"></a>00160     <span class="keywordflow">return</span> result;
<a name="l00161"></a>00161 }
<a name="l00162"></a>00162 
<a name="l00163"></a><a class="code" href="namespaceseamless_1_1euler.html#ad45539f7356a2122ec2ba16126f0ba88">00163</a> Vec3d <a class="code" href="namespaceseamless_1_1euler.html#ad45539f7356a2122ec2ba16126f0ba88">qrs2xyz</a>(<span class="keyword">const</span> Vec3d&amp; local, <span class="keywordtype">int</span> face)
<a name="l00164"></a>00164 {
<a name="l00165"></a>00165     <span class="keywordflow">switch</span> (face)
<a name="l00166"></a>00166     {
<a name="l00167"></a>00167     <span class="keywordflow">case</span> 0:
<a name="l00168"></a>00168         <span class="keywordflow">return</span> Vec3d(local.z(), local.x(), local.y());
<a name="l00169"></a>00169         <span class="keywordflow">break</span>;
<a name="l00170"></a>00170     <span class="keywordflow">case</span> 1:
<a name="l00171"></a>00171         <span class="keywordflow">return</span> Vec3d(-local.x(), local.z(), local.y());
<a name="l00172"></a>00172         <span class="keywordflow">break</span>;
<a name="l00173"></a>00173     <span class="keywordflow">case</span> 2:
<a name="l00174"></a>00174         <span class="keywordflow">return</span> Vec3d(-local.z(), -local.x(), local.y());
<a name="l00175"></a>00175     <span class="keywordflow">case</span> 3:
<a name="l00176"></a>00176         <span class="keywordflow">return</span> Vec3d(local.x(), -local.z(), local.y());
<a name="l00177"></a>00177     <span class="keywordflow">case</span> 4:
<a name="l00178"></a>00178         <span class="keywordflow">return</span> Vec3d(-local.y(),local.x(), local.z());
<a name="l00179"></a>00179     <span class="keywordflow">case</span> 5:
<a name="l00180"></a>00180         <span class="keywordflow">return</span> Vec3d(local.y(), local.x(), -local.z());
<a name="l00181"></a>00181     <span class="keywordflow">default</span>:
<a name="l00182"></a>00182         <span class="keywordflow">return</span> Vec3d(0,0,0);
<a name="l00183"></a>00183     }
<a name="l00184"></a>00184 }
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 <span class="comment">// Face 0 is centered at 0, 0 lat long or 0,0,0. faces 1-3 follow</span>
<a name="l00187"></a>00187 <span class="comment">// around the equator in direction of increasing longitude</span>
<a name="l00188"></a>00188 <span class="comment">// (east). Face 4 is the North Pole, Face 5 the South.</span>
<a name="l00189"></a>00189 
<a name="l00190"></a><a class="code" href="namespaceseamless_1_1euler.html#a714f62a3ca6d24c5bcac37eaf492cc3b">00190</a> Vec3d <a class="code" href="namespaceseamless_1_1euler.html#a238fa5ad0ac6a08259f782a6de623d79">face2dc</a>(<span class="keywordtype">int</span> faceNum, <span class="keyword">const</span> Vec2d&amp; faceCoord)
<a name="l00191"></a>00191 {
<a name="l00192"></a>00192     Vec3d local = <a class="code" href="namespaceseamless_1_1euler.html#a8dff64a39588634c97fca018b82a6f64">face2qrs</a>(faceCoord);
<a name="l00193"></a>00193     <span class="keywordflow">return</span> <a class="code" href="namespaceseamless_1_1euler.html#ad45539f7356a2122ec2ba16126f0ba88">qrs2xyz</a>(local, faceNum);
<a name="l00194"></a>00194 }
<a name="l00195"></a>00195 
<a name="l00196"></a><a class="code" href="namespaceseamless_1_1euler.html#a716d5725e48c780ee396bed196a903bc">00196</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceseamless_1_1euler.html#a716d5725e48c780ee396bed196a903bc">faceCoordsToLatLon</a>(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, <span class="keywordtype">int</span> face,
<a name="l00197"></a>00197                         <span class="keywordtype">double</span>&amp; out_lat_deg, <span class="keywordtype">double</span>&amp; out_lon_deg)
<a name="l00198"></a>00198 {
<a name="l00199"></a>00199     <span class="keywordtype">double</span> lat, lon;
<a name="l00200"></a>00200     <span class="keyword">const</span> <span class="keywordtype">double</span> l = x * osg::PI_4;
<a name="l00201"></a>00201     <span class="keyword">const</span> <span class="keywordtype">double</span> ty = tan(y * osg::PI_4);
<a name="l00202"></a>00202     <span class="keywordflow">if</span> (face &lt; 4)
<a name="l00203"></a>00203     {
<a name="l00204"></a>00204         lon = face * osg::PI_2 + l;
<a name="l00205"></a>00205         lon = fmod(lon + osg::PI, 2.0 * osg::PI) - osg::PI;
<a name="l00206"></a>00206         lat = atan(cos(l) * ty);
<a name="l00207"></a>00207     }
<a name="l00208"></a>00208     <span class="keywordflow">else</span>
<a name="l00209"></a>00209     {
<a name="l00210"></a>00210         <span class="keyword">const</span> <span class="keywordtype">double</span> tx = tan(x * osg::PI_4);
<a name="l00211"></a>00211         lat = osg::PI_2 - atan(sqrt(tx * tx + ty * ty));
<a name="l00212"></a>00212         <span class="keywordflow">if</span> (face == 5)
<a name="l00213"></a>00213         {
<a name="l00214"></a>00214             lon = atan2(tx, ty);
<a name="l00215"></a>00215             lat = -lat;
<a name="l00216"></a>00216         }
<a name="l00217"></a>00217         <span class="keywordflow">else</span>
<a name="l00218"></a>00218         {
<a name="l00219"></a>00219             lon = atan2(tx, -ty);
<a name="l00220"></a>00220         }
<a name="l00221"></a>00221     }
<a name="l00222"></a>00222     out_lon_deg = RadiansToDegrees(lon);
<a name="l00223"></a>00223     out_lat_deg = RadiansToDegrees(lat);
<a name="l00224"></a>00224     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00225"></a>00225 }
<a name="l00226"></a>00226 
<a name="l00227"></a><a class="code" href="namespaceseamless_1_1euler.html#ac308eca82b121ca0e15a1835d0137421">00227</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceseamless_1_1euler.html#ac308eca82b121ca0e15a1835d0137421">cubeToFace</a>(<span class="keywordtype">double</span>&amp; in_out_x, <span class="keywordtype">double</span>&amp; in_out_y, <span class="keywordtype">int</span>&amp; out_face )
<a name="l00228"></a>00228 {
<a name="l00229"></a>00229     <span class="keywordtype">double</span> x, y;
<a name="l00230"></a>00230     <span class="keywordflow">if</span> (in_out_x &gt; 1.0 + 1e-11)
<a name="l00231"></a>00231     {
<a name="l00232"></a>00232         <span class="keywordtype">double</span> face = floor(in_out_x);
<a name="l00233"></a>00233         x = in_out_x - face;
<a name="l00234"></a>00234         <span class="keywordflow">if</span> (x &lt; 1e-11)
<a name="l00235"></a>00235         {
<a name="l00236"></a>00236             face += -1.0;
<a name="l00237"></a>00237             x += 1.0;
<a name="l00238"></a>00238         }
<a name="l00239"></a>00239         y = in_out_y - 1.0;
<a name="l00240"></a>00240         out_face = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(face);
<a name="l00241"></a>00241     }
<a name="l00242"></a>00242     <span class="keywordflow">else</span>
<a name="l00243"></a>00243     {
<a name="l00244"></a>00244         <span class="keywordflow">if</span> (in_out_y &gt; 2.0 + 1e-11)
<a name="l00245"></a>00245         {
<a name="l00246"></a>00246             out_face = 4;
<a name="l00247"></a>00247             y = in_out_y - 2.0;
<a name="l00248"></a>00248         }
<a name="l00249"></a>00249         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (in_out_y &lt; 1.0 + 1e-11)
<a name="l00250"></a>00250         {
<a name="l00251"></a>00251             out_face = 5;
<a name="l00252"></a>00252             y = in_out_y;
<a name="l00253"></a>00253         }
<a name="l00254"></a>00254         <span class="keywordflow">else</span>
<a name="l00255"></a>00255         {
<a name="l00256"></a>00256             out_face = 0;
<a name="l00257"></a>00257             y = in_out_y - 1.0;
<a name="l00258"></a>00258         }
<a name="l00259"></a>00259         x = in_out_x;
<a name="l00260"></a>00260     }
<a name="l00261"></a>00261     in_out_x = x * 2.0 - 1.0;
<a name="l00262"></a>00262     in_out_y = y * 2.0 - 1.0;
<a name="l00263"></a>00263     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00264"></a>00264 }
<a name="l00265"></a>00265 
<a name="l00266"></a><a class="code" href="namespaceseamless_1_1euler.html#a217aa6bed12a59621855479ca03401e1">00266</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceseamless_1_1euler.html#ac308eca82b121ca0e15a1835d0137421">cubeToFace</a>(<span class="keywordtype">double</span>&amp; in_out_xmin, <span class="keywordtype">double</span>&amp; in_out_ymin,
<a name="l00267"></a>00267                 <span class="keywordtype">double</span>&amp; in_out_xmax, <span class="keywordtype">double</span>&amp; in_out_ymax,
<a name="l00268"></a>00268                 <span class="keywordtype">int</span>&amp; out_face)
<a name="l00269"></a>00269 {
<a name="l00270"></a>00270     <span class="keywordtype">double</span> xmin, xmax, ymin, ymax;
<a name="l00271"></a>00271     <span class="keywordflow">if</span> (in_out_ymin &gt; 1.0 - 1e-11 &amp;&amp; in_out_ymax &lt; 2.0 + 1e-11)
<a name="l00272"></a>00272     {
<a name="l00273"></a>00273         <span class="keywordtype">double</span> faceMin = floor(in_out_xmin + 1e-11);
<a name="l00274"></a>00274         <span class="keywordtype">double</span> faceMax = floor(in_out_xmax - 1e-11);
<a name="l00275"></a>00275         <span class="keywordflow">if</span> (faceMin != faceMax)
<a name="l00276"></a>00276         {
<a name="l00277"></a>00277             <a class="code" href="Notify.html#a13b79c6470fc74594070bd2098afc9de">OE_WARN</a> &lt;&lt; <a class="code" href="Euler_8cpp.html#aa499bb75bb504909cd0a72baf48c4653">LC</a> &lt;&lt; <span class="stringliteral">&quot;Min face &lt;&gt; Max face!\n&quot;</span>;
<a name="l00278"></a>00278             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00279"></a>00279         }
<a name="l00280"></a>00280         xmin = in_out_xmin - faceMin;
<a name="l00281"></a>00281         xmax = in_out_xmax - faceMin;
<a name="l00282"></a>00282         ymin = in_out_ymin - 1.0;
<a name="l00283"></a>00283         ymax = in_out_ymax - 1.0;
<a name="l00284"></a>00284         out_face = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(faceMin);
<a name="l00285"></a>00285     }
<a name="l00286"></a>00286     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (in_out_ymin &gt; 2.0 - 1e-11 &amp;&amp; in_out_ymax &gt; 2.0 + 1e-11)
<a name="l00287"></a>00287     {
<a name="l00288"></a>00288         out_face = 4;
<a name="l00289"></a>00289         ymin = in_out_ymin - 2.0;
<a name="l00290"></a>00290         ymax = in_out_ymax - 2.0;
<a name="l00291"></a>00291         xmin = in_out_xmin;
<a name="l00292"></a>00292         xmax = in_out_xmax;
<a name="l00293"></a>00293     }
<a name="l00294"></a>00294     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (in_out_ymax &lt; 1.0 + 1e-11)
<a name="l00295"></a>00295     {
<a name="l00296"></a>00296         out_face = 5;
<a name="l00297"></a>00297         ymin = in_out_ymin;
<a name="l00298"></a>00298         ymax = in_out_ymax;
<a name="l00299"></a>00299         xmin = in_out_xmin;
<a name="l00300"></a>00300         xmax = in_out_xmax;
<a name="l00301"></a>00301     }
<a name="l00302"></a>00302     <span class="keywordflow">else</span>
<a name="l00303"></a>00303     {
<a name="l00304"></a>00304         <a class="code" href="Notify.html#a13b79c6470fc74594070bd2098afc9de">OE_WARN</a> &lt;&lt; <a class="code" href="Euler_8cpp.html#aa499bb75bb504909cd0a72baf48c4653">LC</a> &lt;&lt; <span class="stringliteral">&quot;can&#39;t determine face for (&quot;</span>
<a name="l00305"></a>00305                 &lt;&lt; in_out_xmin &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; in_out_ymin &lt;&lt; <span class="stringliteral">&quot;), (&quot;</span>
<a name="l00306"></a>00306                 &lt;&lt; in_out_xmax &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; in_out_ymax &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;
<a name="l00307"></a>00307         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00308"></a>00308     }
<a name="l00309"></a>00309     in_out_xmin = xmin * 2.0 - 1.0;
<a name="l00310"></a>00310     in_out_xmax = xmax * 2.0 - 1.0;
<a name="l00311"></a>00311     in_out_ymin = ymin * 2.0 - 1.0;
<a name="l00312"></a>00312     in_out_ymax = ymax * 2.0 - 1.0;
<a name="l00313"></a>00313     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00314"></a>00314 }
<a name="l00315"></a>00315 
<a name="l00316"></a><a class="code" href="namespaceseamless_1_1euler.html#ab775c339277610569ca3187fd6bb62e6">00316</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceseamless_1_1euler.html#ab775c339277610569ca3187fd6bb62e6">faceToCube</a>(<span class="keywordtype">double</span>&amp; in_out_x, <span class="keywordtype">double</span>&amp; in_out_y, <span class="keywordtype">int</span> face)
<a name="l00317"></a>00317 {
<a name="l00318"></a>00318     <span class="keywordtype">double</span> x = (in_out_x + 1.0) * .5;
<a name="l00319"></a>00319     <span class="keywordtype">double</span> y = (in_out_y + 1.0) * .5;
<a name="l00320"></a>00320     <span class="keywordflow">if</span> (face &lt; 4)
<a name="l00321"></a>00321     {
<a name="l00322"></a>00322         in_out_x = x + face;
<a name="l00323"></a>00323         in_out_y = y + 1.0;
<a name="l00324"></a>00324     }
<a name="l00325"></a>00325     <span class="keywordflow">else</span>
<a name="l00326"></a>00326     {
<a name="l00327"></a>00327         in_out_x = x;
<a name="l00328"></a>00328         <span class="keywordflow">if</span> (face == 4)
<a name="l00329"></a>00329             in_out_y = y + 2.0;
<a name="l00330"></a>00330         <span class="keywordflow">else</span>
<a name="l00331"></a>00331             in_out_y = y;
<a name="l00332"></a>00332     }
<a name="l00333"></a>00333     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00334"></a>00334 }
<a name="l00335"></a>00335 
<a name="l00336"></a><a class="code" href="namespaceseamless_1_1euler.html#a7e6eca33ab2ffa67a7cb666476f28d1d">00336</a> <span class="keywordtype">double</span> <a class="code" href="namespaceseamless_1_1euler.html#a14bd23b024439771d2bd29d6a23a0b3b">arcLength</a>(<span class="keyword">const</span> Vec2d&amp; coord1, <span class="keyword">const</span> Vec2d&amp; coord2, <span class="keywordtype">int</span> face)
<a name="l00337"></a>00337 {
<a name="l00338"></a>00338     <span class="keywordflow">if</span> (coord1.x() != coord2.x() &amp;&amp; coord1.y() != coord2.y())
<a name="l00339"></a>00339     {
<a name="l00340"></a>00340         Vec3d geo1 = <a class="code" href="namespaceseamless_1_1euler.html#a238fa5ad0ac6a08259f782a6de623d79">face2dc</a>(face, coord1);
<a name="l00341"></a>00341         Vec3d geo2 = <a class="code" href="namespaceseamless_1_1euler.html#a238fa5ad0ac6a08259f782a6de623d79">face2dc</a>(face, coord2);
<a name="l00342"></a>00342         Vec3d norm = geo1 ^ geo2;
<a name="l00343"></a>00343         <span class="keywordflow">return</span> atan2(norm.length(), geo1 * geo2) * WGS_84_RADIUS_EQUATOR;
<a name="l00344"></a>00344     }
<a name="l00345"></a>00345     <span class="keywordtype">double</span> x1, y1, x2, y2;
<a name="l00346"></a>00346     <span class="keywordflow">if</span> (coord1.x() == coord2.x())
<a name="l00347"></a>00347     {
<a name="l00348"></a>00348         x1 = coord1.x() * PI_4;  y1 = coord1.y() * PI_4;
<a name="l00349"></a>00349         x2 = coord2.x() * PI_4;  y2 = coord2.y() * PI_4;
<a name="l00350"></a>00350     }
<a name="l00351"></a>00351     <span class="keywordflow">else</span>
<a name="l00352"></a>00352     {
<a name="l00353"></a>00353         x1 = coord1.y() * PI_4;  y1 = coord1.x() * PI_4;
<a name="l00354"></a>00354         x2 = coord2.y() * PI_4;  y2 = coord2.x() * PI_4;
<a name="l00355"></a>00355     }
<a name="l00356"></a>00356     <span class="keywordtype">double</span> tanPhi1 = cos(x1) * tan(y1);
<a name="l00357"></a>00357     <span class="keywordtype">double</span> tanPhi2 = cos(x2) * tan(y2);
<a name="l00358"></a>00358     <span class="comment">// tan(phi2 - phi1) = (tan(phi2) - tan(hi1)) / (1 + tan(phi2) * tan(phi1))</span>
<a name="l00359"></a>00359     <span class="keywordflow">return</span> fabs(atan2(tanPhi2 - tanPhi1, 1 + tanPhi2 * tanPhi1))
<a name="l00360"></a>00360         * WGS_84_RADIUS_EQUATOR;
<a name="l00361"></a>00361 
<a name="l00362"></a>00362 }
<a name="l00363"></a>00363 
<a name="l00364"></a>00364 <span class="comment">// For debugging</span>
<a name="l00365"></a>00365 <span class="comment">// Find the point closest to P3 on the line segment from P1 to P2</span>
<a name="l00366"></a><a class="code" href="namespaceseamless_1_1euler.html#a5fc91ccba584b1c62e880a93e19b16bd">00366</a> <span class="keyword">static</span> osg::Vec3d <a class="code" href="namespaceseamless_1_1euler.html#a5fc91ccba584b1c62e880a93e19b16bd">closestPointOnLine</a>(<span class="keyword">const</span> osg::Vec3d &amp;p1,
<a name="l00367"></a>00367                                      <span class="keyword">const</span> osg::Vec3d&amp; p2,
<a name="l00368"></a>00368                                      <span class="keyword">const</span> osg::Vec3d&amp; p3)
<a name="l00369"></a>00369 {
<a name="l00370"></a>00370     Vec3d vec = p2 - p1;
<a name="l00371"></a>00371     <span class="keywordtype">double</span> len2 = vec.length2();
<a name="l00372"></a>00372     <span class="keywordflow">if</span> (equivalent(len2, 0))
<a name="l00373"></a>00373         <span class="keywordflow">return</span> p1;
<a name="l00374"></a>00374     <span class="keywordtype">double</span> u = ((p3 - p1) * vec) / len2;
<a name="l00375"></a>00375     <span class="keywordflow">if</span> (u &lt;= 0.0)
<a name="l00376"></a>00376         <span class="keywordflow">return</span> p1;
<a name="l00377"></a>00377     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (u &gt;= 1.0)
<a name="l00378"></a>00378         <span class="keywordflow">return</span> p2;
<a name="l00379"></a>00379     <span class="keywordflow">else</span>
<a name="l00380"></a>00380         <span class="keywordflow">return</span> p1 + vec * u;
<a name="l00381"></a>00381 }
<a name="l00382"></a>00382 
<a name="l00383"></a><a class="code" href="namespaceseamless_1_1euler.html#a27f5ab6ee083d42089e24004a7d51116">00383</a> <span class="keywordtype">double</span> <a class="code" href="namespaceseamless_1_1euler.html#a27f5ab6ee083d42089e24004a7d51116">distanceToLine</a>(<span class="keyword">const</span> Vec3d&amp; p1, <span class="keyword">const</span> Vec3d&amp; p2, <span class="keyword">const</span> Vec3d&amp; p3)
<a name="l00384"></a>00384 {
<a name="l00385"></a>00385     Vec3d pt = <a class="code" href="namespaceseamless_1_1euler.html#a5fc91ccba584b1c62e880a93e19b16bd">closestPointOnLine</a>(p1, p2, p3);
<a name="l00386"></a>00386     <span class="keywordflow">return</span> (p3 - pt).length();
<a name="l00387"></a>00387 }
<a name="l00388"></a>00388 
<a name="l00389"></a><a class="code" href="namespaceseamless_1_1euler.html#a490d1d9484f78cba830848d5ba2d9cd2">00389</a> <span class="keywordtype">double</span> <a class="code" href="namespaceseamless.html#a6fd338140a630b8faf0315f110528aa8">distanceToSegment</a>(<span class="keyword">const</span> Vec3d&amp; p,
<a name="l00390"></a>00390                          <span class="keyword">const</span> Vec3d&amp; geo1, <span class="keyword">const</span> Vec3d&amp; geo2,
<a name="l00391"></a>00391                          <span class="keyword">const</span> Vec3d&amp; norm)
<a name="l00392"></a>00392 {
<a name="l00393"></a>00393     <span class="comment">// Find the distance to the closet point on the circle that</span>
<a name="l00394"></a>00394     <span class="comment">// contains the segment. If that point lies on the segment, that&#39;s</span>
<a name="l00395"></a>00395     <span class="comment">// the shortest distance; otherwise, the distance to one of the</span>
<a name="l00396"></a>00396     <span class="comment">// end points is the shortest.</span>
<a name="l00397"></a>00397 
<a name="l00398"></a>00398     <span class="comment">// Project p into plane of circle</span>
<a name="l00399"></a>00399     Vec3d q = p - norm * (norm * p);
<a name="l00400"></a>00400     <span class="comment">// If q = (0, 0, 0) -- the center of the circle -- then all points</span>
<a name="l00401"></a>00401     <span class="comment">// on the circle are equidistant.</span>
<a name="l00402"></a>00402     <span class="comment">// qnorm will be on unit circle</span>
<a name="l00403"></a>00403     <span class="keyword">const</span> <span class="keywordtype">double</span> r = WGS_84_RADIUS_EQUATOR;
<a name="l00404"></a>00404     <span class="keywordflow">if</span> (equivalent(q.length2(), 0))
<a name="l00405"></a>00405     {
<a name="l00406"></a>00406         <span class="keywordflow">return</span> sqrt(r * r + p.length2());
<a name="l00407"></a>00407     }
<a name="l00408"></a>00408     Vec3d qnorm = q / q.length();
<a name="l00409"></a>00409 
<a name="l00410"></a>00410     <span class="comment">// Vec3d x = q * r / q.length();</span>
<a name="l00411"></a>00411     <span class="keyword">const</span> Vec3d zero;
<a name="l00412"></a>00412     Vec3d end1, end2;
<a name="l00413"></a>00413     <span class="keywordtype">double</span> mua, mub;
<a name="l00414"></a>00414     <span class="keywordflow">if</span> (<a class="code" href="namespaceseamless_1_1euler.html#ae370edb27fca30b8656dc8140a305801">lineLineIntersect</a>(zero, qnorm, geo1, geo2, end1, end2, mua, mub)
<a name="l00415"></a>00415         &amp;&amp; mub &gt;= 0.0 &amp;&amp; mub &lt;= 1.0)
<a name="l00416"></a>00416     {
<a name="l00417"></a>00417         <span class="keywordflow">return</span> (p - qnorm * r).length();
<a name="l00418"></a>00418     }
<a name="l00419"></a>00419     <span class="keywordflow">else</span>
<a name="l00420"></a>00420     {
<a name="l00421"></a>00421         <span class="keywordflow">return</span> minimum((p - geo1 * r).length(), (p - geo2 * r).length());
<a name="l00422"></a>00422     }
<a name="l00423"></a>00423 }
<a name="l00424"></a>00424 
<a name="l00425"></a>00425 <span class="comment">// The normal will point towards +s or +r</span>
<a name="l00426"></a>00426 
<a name="l00427"></a><a class="code" href="namespaceseamless_1_1euler.html#a11cf2e867ce4fba0fe8f2bde7b257a00">00427</a> Vec3d <a class="code" href="namespaceseamless_1_1euler.html#a11cf2e867ce4fba0fe8f2bde7b257a00">getNormalToSegment</a>(<span class="keyword">const</span> Vec2d&amp; coord1, <span class="keyword">const</span> Vec2d&amp; coord2, <span class="keywordtype">int</span> face)
<a name="l00428"></a>00428 {
<a name="l00429"></a>00429     <span class="keywordflow">if</span> (coord1.x() == coord2.x())
<a name="l00430"></a>00430     {
<a name="l00431"></a>00431         <span class="keywordtype">double</span> xang = coord1.x() * PI_4;
<a name="l00432"></a>00432         <span class="keywordtype">double</span> sx = sin(xang), cx = cos(xang);
<a name="l00433"></a>00433         Vec3d qrsNormal(cx, 0.0, -sx);
<a name="l00434"></a>00434         <span class="keywordflow">return</span> <a class="code" href="namespaceseamless_1_1euler.html#ad45539f7356a2122ec2ba16126f0ba88">qrs2xyz</a>(qrsNormal, face);
<a name="l00435"></a>00435     }
<a name="l00436"></a>00436     <span class="keywordflow">else</span>
<a name="l00437"></a>00437     {
<a name="l00438"></a>00438         <span class="keywordtype">double</span> yang = coord1.y() * PI_4;
<a name="l00439"></a>00439         <span class="keywordtype">double</span> sy = sin(yang), cy = cos(yang);
<a name="l00440"></a>00440         Vec3d qrsNormal(0.0, cy, -sy);
<a name="l00441"></a>00441         <span class="keywordflow">return</span> <a class="code" href="namespaceseamless_1_1euler.html#ad45539f7356a2122ec2ba16126f0ba88">qrs2xyz</a>(qrsNormal, face);
<a name="l00442"></a>00442     }
<a name="l00443"></a>00443 }
<a name="l00444"></a>00444 
<a name="l00445"></a><a class="code" href="namespaceseamless_1_1euler.html#afc225961c75e47549a258be502e156ec">00445</a> <span class="keywordtype">double</span> <a class="code" href="namespaceseamless.html#a6fd338140a630b8faf0315f110528aa8">distanceToSegment</a>(<span class="keyword">const</span> Vec3d&amp; p,
<a name="l00446"></a>00446                          <span class="keyword">const</span> Vec2d&amp; coord1, <span class="keyword">const</span> Vec2d&amp; coord2, <span class="keywordtype">int</span> face)
<a name="l00447"></a>00447 {
<a name="l00448"></a>00448     Vec3d norm = <a class="code" href="namespaceseamless_1_1euler.html#a11cf2e867ce4fba0fe8f2bde7b257a00">getNormalToSegment</a>(coord1, coord2, face);
<a name="l00449"></a>00449     Vec3d geo1 = <a class="code" href="namespaceseamless_1_1euler.html#a238fa5ad0ac6a08259f782a6de623d79">face2dc</a>(face, coord1);
<a name="l00450"></a>00450     Vec3d geo2 = <a class="code" href="namespaceseamless_1_1euler.html#a238fa5ad0ac6a08259f782a6de623d79">face2dc</a>(face, coord2);
<a name="l00451"></a>00451     <span class="keywordflow">return</span> <a class="code" href="namespaceseamless.html#a6fd338140a630b8faf0315f110528aa8">distanceToSegment</a>(p, geo1, geo2, norm);
<a name="l00452"></a>00452 }
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 <span class="comment">/*</span>
<a name="l00455"></a>00455 <span class="comment">   Calculate the line segment PaPb that is the shortest route between</span>
<a name="l00456"></a>00456 <span class="comment">   two lines P1P2 and P3P4. Calculate also the values of mua and mub where</span>
<a name="l00457"></a>00457 <span class="comment">      Pa = P1 + mua (P2 - P1)</span>
<a name="l00458"></a>00458 <span class="comment">      Pb = P3 + mub (P4 - P3)</span>
<a name="l00459"></a>00459 <span class="comment">   Return FALSE if no solution exists.</span>
<a name="l00460"></a>00460 <span class="comment"></span>
<a name="l00461"></a>00461 <span class="comment">   Ripped off from http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline3d/</span>
<a name="l00462"></a>00462 <span class="comment">*/</span>
<a name="l00463"></a><a class="code" href="namespaceseamless_1_1euler.html#ae370edb27fca30b8656dc8140a305801">00463</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceseamless_1_1euler.html#ae370edb27fca30b8656dc8140a305801">lineLineIntersect</a>(
<a name="l00464"></a>00464    <span class="keyword">const</span> Vec3d&amp; p1, <span class="keyword">const</span> Vec3d&amp; p2, <span class="keyword">const</span> Vec3d&amp; p3, <span class="keyword">const</span> Vec3d&amp; p4,
<a name="l00465"></a>00465    Vec3d&amp; pa,Vec3d&amp; pb, <span class="keywordtype">double</span>&amp; mua, <span class="keywordtype">double</span>&amp; mub)
<a name="l00466"></a>00466 {
<a name="l00467"></a>00467     Vec3d p13, p43, p21;
<a name="l00468"></a>00468     <span class="keywordtype">double</span> d1343, d4321, d1321, d4343, d2121;
<a name="l00469"></a>00469     <span class="keywordtype">double</span> numer, denom;
<a name="l00470"></a>00470 
<a name="l00471"></a>00471     p13 = p1 - p3;
<a name="l00472"></a>00472     p43 = p4 - p3;
<a name="l00473"></a>00473     <span class="keywordflow">if</span> (equivalent(p43.length2(), 0.0, 1e-11))
<a name="l00474"></a>00474         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00475"></a>00475     p21 = p2 - p1;
<a name="l00476"></a>00476     <span class="keywordflow">if</span> (equivalent(p21.length2(), 0.0, 1e-11))
<a name="l00477"></a>00477         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00478"></a>00478 
<a name="l00479"></a>00479     d1343 = p13.x() * p43.x() + p13.y() * p43.y() + p13.z() * p43.z();
<a name="l00480"></a>00480     d4321 = p43.x() * p21.x() + p43.y() * p21.y() + p43.z() * p21.z();
<a name="l00481"></a>00481     d1321 = p13.x() * p21.x() + p13.y() * p21.y() + p13.z() * p21.z();
<a name="l00482"></a>00482     d4343 = p43.x() * p43.x() + p43.y() * p43.y() + p43.z() * p43.z();
<a name="l00483"></a>00483     d2121 = p21.x() * p21.x() + p21.y() * p21.y() + p21.z() * p21.z();
<a name="l00484"></a>00484 
<a name="l00485"></a>00485     denom = d2121 * d4343 - d4321 * d4321;
<a name="l00486"></a>00486     <span class="keywordflow">if</span> (equivalent(denom, 0.0, 1e-11))
<a name="l00487"></a>00487         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00488"></a>00488     numer = d1343 * d4321 - d1321 * d4343;
<a name="l00489"></a>00489 
<a name="l00490"></a>00490     mua = numer / denom;
<a name="l00491"></a>00491     mub = (d1343 + d4321 * (mua)) / d4343;
<a name="l00492"></a>00492 
<a name="l00493"></a>00493     pa = p1 + p21 * mua;
<a name="l00494"></a>00494     pb = p3 + p43 * mub;
<a name="l00495"></a>00495 
<a name="l00496"></a>00496     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00497"></a>00497 }
<a name="l00498"></a>00498 
<a name="l00499"></a>00499 }
<a name="l00500"></a>00500 
<a name="l00501"></a>00501 <span class="keyword">using namespace </span>euler;
<a name="l00502"></a>00502 
<a name="l00503"></a><a class="code" href="classseamless_1_1QscFaceLocator.html#a9b9da6fa15e1850fcf2b630e39da791f">00503</a> <span class="keywordtype">bool</span> <a class="code" href="classseamless_1_1EulerFaceLocator.html#afd6e1919eb451c195cc953cfcade0150">EulerFaceLocator::convertLocalToModel</a>(<span class="keyword">const</span> Vec3d&amp; local, Vec3d&amp; world)<span class="keyword"> const</span>
<a name="l00504"></a>00504 <span class="keyword"></span>{
<a name="l00505"></a>00505 <span class="preprocessor">#if ((OPENSCENEGRAPH_MAJOR_VERSION &lt;= 2) &amp;&amp; (OPENSCENEGRAPH_MINOR_VERSION &lt; 8))</span>
<a name="l00506"></a>00506 <span class="preprocessor"></span>    <span class="comment">// OSG 2.7 bug workaround: bug fix in Locator submitted by GW</span>
<a name="l00507"></a>00507     <span class="keyword">const_cast&lt;</span><a class="code" href="classseamless_1_1EulerFaceLocator.html">EulerFaceLocator</a>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;_inverse.invert( _transform );
<a name="l00508"></a>00508 <span class="preprocessor">#endif</span>
<a name="l00509"></a>00509 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ( _coordinateSystemType == GEOCENTRIC )
<a name="l00510"></a>00510     {
<a name="l00511"></a>00511         <span class="comment">//Convert the NDC coordinate into face space</span>
<a name="l00512"></a>00512         osg::Vec3d faceCoord = local * _transform;
<a name="l00513"></a>00513 
<a name="l00514"></a>00514         <span class="keywordtype">double</span> lat_deg, lon_deg;
<a name="l00515"></a>00515         <a class="code" href="namespaceseamless_1_1euler.html#a716d5725e48c780ee396bed196a903bc">faceCoordsToLatLon</a>(faceCoord.x(), faceCoord.y(), _face,
<a name="l00516"></a>00516                            lat_deg, lon_deg);
<a name="l00517"></a>00517 
<a name="l00518"></a>00518         <span class="comment">//OE_NOTICE &lt;&lt; &quot;LatLon=&quot; &lt;&lt; latLon &lt;&lt;  std::endl;</span>
<a name="l00519"></a>00519 
<a name="l00520"></a>00520         <span class="comment">// convert to geocentric:</span>
<a name="l00521"></a>00521         _ellipsoidModel-&gt;convertLatLongHeightToXYZ(
<a name="l00522"></a>00522             DegreesToRadians(lat_deg),
<a name="l00523"></a>00523             DegreesToRadians(lon_deg),
<a name="l00524"></a>00524             local.z(),
<a name="l00525"></a>00525             world.x(), world.y(), world.z());
<a name="l00526"></a>00526 
<a name="l00527"></a>00527         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00528"></a>00528     }
<a name="l00529"></a>00529     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00530"></a>00530 }
<a name="l00531"></a>00531 
<a name="l00532"></a><a class="code" href="classseamless_1_1QscFaceLocator.html#a9347485cfcb8906597ebfa1d7e21cac5">00532</a> <span class="keywordtype">bool</span> <a class="code" href="classseamless_1_1EulerFaceLocator.html#a30dc1a5dc94a66f67166816b33eed846">EulerFaceLocator::convertModelToLocal</a>(<span class="keyword">const</span> Vec3d&amp; world, Vec3d&amp; local)<span class="keyword"> const</span>
<a name="l00533"></a>00533 <span class="keyword"></span>{
<a name="l00534"></a>00534 <span class="preprocessor">#if ((OPENSCENEGRAPH_MAJOR_VERSION &lt;= 2) &amp;&amp; (OPENSCENEGRAPH_MINOR_VERSION &lt; 8))</span>
<a name="l00535"></a>00535 <span class="preprocessor"></span>    <span class="comment">// OSG 2.7 bug workaround: bug fix in Locator submitted by GW</span>
<a name="l00536"></a>00536     <span class="keyword">const_cast&lt;</span><a class="code" href="classseamless_1_1EulerFaceLocator.html">EulerFaceLocator</a>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;_inverse.invert( _transform );
<a name="l00537"></a>00537 <span class="preprocessor">#endif</span>
<a name="l00538"></a>00538 <span class="preprocessor"></span>
<a name="l00539"></a>00539     <span class="keywordflow">switch</span>(_coordinateSystemType)
<a name="l00540"></a>00540     {
<a name="l00541"></a>00541     <span class="keywordflow">case</span>(GEOCENTRIC):
<a name="l00542"></a>00542         {
<a name="l00543"></a>00543             <span class="keywordtype">double</span> longitude, latitude, height;
<a name="l00544"></a>00544 
<a name="l00545"></a>00545             _ellipsoidModel-&gt;convertXYZToLatLongHeight
<a name="l00546"></a>00546                 (world.x(), world.y(), world.z(), latitude, longitude, height );
<a name="l00547"></a>00547 
<a name="l00548"></a>00548             <span class="keywordtype">int</span> face=-1;
<a name="l00549"></a>00549             <span class="keywordtype">double</span> x, y;
<a name="l00550"></a>00550 
<a name="l00551"></a>00551             <span class="keywordtype">double</span> lat_deg = RadiansToDegrees(latitude);
<a name="l00552"></a>00552             <span class="keywordtype">double</span> lon_deg = RadiansToDegrees(longitude);
<a name="l00553"></a>00553 
<a name="l00554"></a>00554             <span class="keywordtype">bool</span> success = <a class="code" href="namespaceseamless_1_1euler.html#a68a059dd37e98c13091a4399ee9b8f59">latLonToFaceCoords</a>(lat_deg, lon_deg, x, y, face,
<a name="l00555"></a>00555                                               _face);
<a name="l00556"></a>00556 
<a name="l00557"></a>00557             <span class="keywordflow">if</span> (!success)
<a name="l00558"></a>00558             {
<a name="l00559"></a>00559                 <a class="code" href="Notify.html#a29c29c62ae325bf5871ce5b1695c1720">OE_NOTICE</a> &lt;&lt; <a class="code" href="Euler_8cpp.html#aa499bb75bb504909cd0a72baf48c4653">LC</a> &lt;&lt; <span class="stringliteral">&quot;Couldn&#39;t convert to face coords\n&quot;</span>;
<a name="l00560"></a>00560             }
<a name="l00561"></a>00561             <span class="keywordflow">if</span> (face != static_cast&lt;int&gt;(_face))
<a name="l00562"></a>00562             {
<a name="l00563"></a>00563                 <a class="code" href="Notify.html#a29c29c62ae325bf5871ce5b1695c1720">OE_NOTICE</a> &lt;&lt; <a class="code" href="Euler_8cpp.html#aa499bb75bb504909cd0a72baf48c4653">LC</a>
<a name="l00564"></a>00564                     &lt;&lt; <span class="stringliteral">&quot;Face should be &quot;</span> &lt;&lt; _face &lt;&lt; <span class="stringliteral">&quot; but is &quot;</span> &lt;&lt; face
<a name="l00565"></a>00565                     &lt;&lt; <span class="stringliteral">&quot;, lat = &quot;</span> &lt;&lt; lat_deg
<a name="l00566"></a>00566                     &lt;&lt; <span class="stringliteral">&quot;, lon = &quot;</span> &lt;&lt; lon_deg
<a name="l00567"></a>00567                     &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00568"></a>00568             }
<a name="l00569"></a>00569 
<a name="l00570"></a>00570             local = Vec3d(x, y, height) * _inverse;
<a name="l00571"></a>00571             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00572"></a>00572         }
<a name="l00573"></a>00573 
<a name="l00574"></a>00574 
<a name="l00575"></a>00575     <span class="keywordflow">case</span>(GEOGRAPHIC):
<a name="l00576"></a>00576     <span class="keywordflow">case</span>(PROJECTED):
<a name="l00577"></a>00577         <span class="comment">// Neither of these is supported for this locator..</span>
<a name="l00578"></a>00578         {
<a name="l00579"></a>00579             local = world * _inverse;
<a name="l00580"></a>00580             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00581"></a>00581         }
<a name="l00582"></a>00582     }
<a name="l00583"></a>00583 
<a name="l00584"></a>00584     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00585"></a>00585 }
<a name="l00586"></a>00586 
<a name="l00587"></a>00587 
<a name="l00588"></a><a class="code" href="classseamless_1_1EulerSpatialReference.html#a5c0fb0f1717c331d84d06ac12fde36b6">00588</a> <a class="code" href="classseamless_1_1EulerSpatialReference.html#a5c0fb0f1717c331d84d06ac12fde36b6">EulerSpatialReference::EulerSpatialReference</a>( <span class="keywordtype">void</span>* handle )
<a name="l00589"></a>00589     : <a class="code" href="classosgEarth_1_1SpatialReference.html">SpatialReference</a>(handle, <span class="stringliteral">&quot;OSGEARTH&quot;</span>, <span class="stringliteral">&quot;euler-cube&quot;</span>,
<a name="l00590"></a>00590                        <span class="stringliteral">&quot;Euler Cube&quot;</span>)
<a name="l00591"></a>00591 {
<a name="l00592"></a>00592     <span class="comment">//nop</span>
<a name="l00593"></a>00593 }
<a name="l00594"></a>00594 
<a name="l00595"></a>00595 <span class="keywordtype">void</span>
<a name="l00596"></a><a class="code" href="classseamless_1_1EulerSpatialReference.html#a7e11908a9c0c69edd711255a36d40cd3">00596</a> <a class="code" href="classseamless_1_1EulerSpatialReference.html#a7e11908a9c0c69edd711255a36d40cd3">EulerSpatialReference::_init</a>()
<a name="l00597"></a>00597 {
<a name="l00598"></a>00598     <a class="code" href="classseamless_1_1EulerSpatialReference.html#a7e11908a9c0c69edd711255a36d40cd3">SpatialReference::_init</a>();
<a name="l00599"></a>00599 
<a name="l00600"></a>00600     <a class="code" href="classosgEarth_1_1SpatialReference.html#a96a9f0b186844761501eae9ada3b98b7">_is_user_defined</a> = <span class="keyword">true</span>;
<a name="l00601"></a>00601     <a class="code" href="classosgEarth_1_1SpatialReference.html#a77855603c18b3023ff8c11dac4b0fe1d">_is_cube</a> = <span class="keyword">true</span>;
<a name="l00602"></a>00602     <a class="code" href="classosgEarth_1_1SpatialReference.html#acb183e6f02f1e934765ae6f2098fcd09">_is_contiguous</a> = <span class="keyword">false</span>;
<a name="l00603"></a>00603     <a class="code" href="classosgEarth_1_1SpatialReference.html#add0cb2eced719f0e323321b6c6aab90a">_is_geographic</a> = <span class="keyword">false</span>;
<a name="l00604"></a>00604     <a class="code" href="classosgEarth_1_1SpatialReference.html#a6d23484d2a36c4a3469faea79aa6b4fc">_name</a> = <span class="stringliteral">&quot;Euler Cube&quot;</span>;
<a name="l00605"></a>00605 }
<a name="l00606"></a>00606 
<a name="l00607"></a>00607 <a class="code" href="classosgEarth_1_1GeoLocator.html">GeoLocator</a>*
<a name="l00608"></a><a class="code" href="classseamless_1_1EulerSpatialReference.html#aa0466ae3fa03df14b1ecd7ca34598909">00608</a> <a class="code" href="classseamless_1_1EulerSpatialReference.html#aa0466ae3fa03df14b1ecd7ca34598909">EulerSpatialReference::createLocator</a>(<span class="keywordtype">double</span> xmin, <span class="keywordtype">double</span> ymin,
<a name="l00609"></a>00609                                    <span class="keywordtype">double</span> xmax, <span class="keywordtype">double</span> ymax,
<a name="l00610"></a>00610                                     <span class="keywordtype">bool</span> plate_carre)<span class="keyword"> const</span>
<a name="l00611"></a>00611 <span class="keyword"></span>{
<a name="l00612"></a>00612     <span class="keywordtype">int</span> face;
<a name="l00613"></a>00613     <a class="code" href="namespaceseamless_1_1euler.html#ac308eca82b121ca0e15a1835d0137421">cubeToFace</a>(xmin, ymin, xmax, ymax, face);
<a name="l00614"></a>00614 
<a name="l00615"></a>00615     <a class="code" href="classosgEarth_1_1GeoLocator.html">GeoLocator</a>* result = <span class="keyword">new</span> <a class="code" href="classseamless_1_1EulerFaceLocator.html">EulerFaceLocator</a>( face );
<a name="l00616"></a>00616 
<a name="l00617"></a>00617     osg::Matrixd <a class="code" href="classseamless_1_1EulerSpatialReference.html#aa6a2a563b63f9b3ce2fe8606b1ede863">transform</a>;
<a name="l00618"></a>00618     transform.set(
<a name="l00619"></a>00619         xmax-xmin, 0.0,       0.0, 0.0,
<a name="l00620"></a>00620         0.0,       ymax-ymin, 0.0, 0.0,
<a name="l00621"></a>00621         0.0,       0.0,       1.0, 0.0,
<a name="l00622"></a>00622         xmin,      ymin,      0.0, 1.0);
<a name="l00623"></a>00623     result-&gt;setTransform( transform );
<a name="l00624"></a>00624 
<a name="l00625"></a>00625     <span class="keywordflow">return</span> result;
<a name="l00626"></a>00626 }
<a name="l00627"></a>00627 
<a name="l00628"></a>00628 <span class="keywordtype">bool</span>
<a name="l00629"></a><a class="code" href="classseamless_1_1EulerSpatialReference.html#a2fe582b3bfe6faa7902b04e802423551">00629</a> <a class="code" href="classseamless_1_1EulerSpatialReference.html#a2fe582b3bfe6faa7902b04e802423551">EulerSpatialReference::preTransform</a>(<span class="keywordtype">double</span>&amp; x, <span class="keywordtype">double</span>&amp; y, <span class="keywordtype">void</span>* context)<span class="keyword"> const</span>
<a name="l00630"></a>00630 <span class="keyword"></span>{
<a name="l00631"></a>00631     <span class="comment">// Convert the incoming points from cube =&gt; face =&gt; lat/long.</span>
<a name="l00632"></a>00632     <span class="keywordtype">int</span> face;
<a name="l00633"></a>00633     <span class="keywordflow">if</span> ( !<a class="code" href="namespaceseamless_1_1euler.html#ac308eca82b121ca0e15a1835d0137421">cubeToFace</a>(x, y, face) )
<a name="l00634"></a>00634     {
<a name="l00635"></a>00635         <a class="code" href="Notify.html#a13b79c6470fc74594070bd2098afc9de">OE_WARN</a> &lt;&lt; <a class="code" href="Euler_8cpp.html#aa499bb75bb504909cd0a72baf48c4653">LC</a> &lt;&lt; <span class="stringliteral">&quot;Failed to convert (&quot;</span> &lt;&lt; x &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class="stringliteral">&quot;) into face coordinates.&quot;</span> &lt;&lt; std::endl;
<a name="l00636"></a>00636         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00637"></a>00637     }
<a name="l00638"></a>00638 
<a name="l00639"></a>00639     <span class="keywordtype">double</span> lat_deg, lon_deg;
<a name="l00640"></a>00640     <span class="keywordtype">bool</span> success = <a class="code" href="namespaceseamless_1_1euler.html#a716d5725e48c780ee396bed196a903bc">faceCoordsToLatLon</a>( x, y, face, lat_deg, lon_deg );
<a name="l00641"></a>00641     <span class="keywordflow">if</span> (!success)
<a name="l00642"></a>00642     {
<a name="l00643"></a>00643         <a class="code" href="Notify.html#a13b79c6470fc74594070bd2098afc9de">OE_WARN</a> &lt;&lt; <a class="code" href="Euler_8cpp.html#aa499bb75bb504909cd0a72baf48c4653">LC</a> &lt;&lt; <span class="stringliteral">&quot;Could not transform face coordinates to lat lon&quot;</span> &lt;&lt; std::endl;
<a name="l00644"></a>00644         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00645"></a>00645     }
<a name="l00646"></a>00646     x = lon_deg;
<a name="l00647"></a>00647     y = lat_deg;
<a name="l00648"></a>00648     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00649"></a>00649 }
<a name="l00650"></a>00650 
<a name="l00651"></a>00651 <span class="keywordtype">bool</span>
<a name="l00652"></a><a class="code" href="classseamless_1_1EulerSpatialReference.html#a4ce0fa8322657dad1ec3924724b7ab57">00652</a> <a class="code" href="classseamless_1_1EulerSpatialReference.html#a4ce0fa8322657dad1ec3924724b7ab57">EulerSpatialReference::postTransform</a>(<span class="keywordtype">double</span>&amp; x, <span class="keywordtype">double</span>&amp; y, <span class="keywordtype">void</span>* context)<span class="keyword"> const</span>
<a name="l00653"></a>00653 <span class="keyword"></span>{
<a name="l00654"></a>00654     <span class="comment">//Convert the incoming points from lat/lon back to face coordinates</span>
<a name="l00655"></a>00655     <span class="keywordtype">int</span> face;
<a name="l00656"></a>00656     <span class="keywordtype">double</span> out_x, out_y;
<a name="l00657"></a>00657 
<a name="l00658"></a>00658     <span class="comment">// convert from lat/long to x/y/face</span>
<a name="l00659"></a>00659     <span class="keywordtype">bool</span> success = <a class="code" href="namespaceseamless_1_1euler.html#a68a059dd37e98c13091a4399ee9b8f59">latLonToFaceCoords</a>(y, x, out_x, out_y, face);
<a name="l00660"></a>00660     <span class="keywordflow">if</span> (!success)
<a name="l00661"></a>00661     {
<a name="l00662"></a>00662         <a class="code" href="Notify.html#a13b79c6470fc74594070bd2098afc9de">OE_WARN</a> &lt;&lt; <a class="code" href="Euler_8cpp.html#aa499bb75bb504909cd0a72baf48c4653">LC</a> &lt;&lt; <span class="stringliteral">&quot;Could not transform face coordinates to lat lon&quot;</span> &lt;&lt; std::endl;
<a name="l00663"></a>00663         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00664"></a>00664     }
<a name="l00665"></a>00665 
<a name="l00666"></a>00666     <span class="comment">//TODO: what to do about boundary points?</span>
<a name="l00667"></a>00667 
<a name="l00668"></a>00668     <span class="keywordflow">if</span> ( !<a class="code" href="namespaceseamless_1_1euler.html#ab775c339277610569ca3187fd6bb62e6">faceToCube</a>(out_x, out_y, face))
<a name="l00669"></a>00669     {
<a name="l00670"></a>00670         <a class="code" href="Notify.html#a13b79c6470fc74594070bd2098afc9de">OE_WARN</a> &lt;&lt; <a class="code" href="Euler_8cpp.html#aa499bb75bb504909cd0a72baf48c4653">LC</a> &lt;&lt; <span class="stringliteral">&quot;fromFace(&quot;</span> &lt;&lt; out_x &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; out_y &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; face &lt;&lt; <span class="stringliteral">&quot;) failed&quot;</span> &lt;&lt; std::endl;
<a name="l00671"></a>00671         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00672"></a>00672     }
<a name="l00673"></a>00673 
<a name="l00674"></a>00674     x = out_x;
<a name="l00675"></a>00675     y = out_y;
<a name="l00676"></a>00676 
<a name="l00677"></a>00677     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00678"></a>00678 }
<a name="l00679"></a>00679 
<a name="l00680"></a>00680 <span class="keywordtype">bool</span>
<a name="l00681"></a><a class="code" href="classseamless_1_1EulerSpatialReference.html#aa6a2a563b63f9b3ce2fe8606b1ede863">00681</a> <a class="code" href="classseamless_1_1EulerSpatialReference.html#aa6a2a563b63f9b3ce2fe8606b1ede863">EulerSpatialReference::transform</a>(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y,
<a name="l00682"></a>00682                                  <span class="keyword">const</span> <a class="code" href="classosgEarth_1_1SpatialReference.html">SpatialReference</a>* to_srs,
<a name="l00683"></a>00683                                  <span class="keywordtype">double</span>&amp; out_x, <span class="keywordtype">double</span>&amp; out_y,
<a name="l00684"></a>00684                                  <span class="keywordtype">void</span>* context)<span class="keyword"> const</span>
<a name="l00685"></a>00685 <span class="keyword"></span>{
<a name="l00686"></a>00686     <span class="keywordflow">if</span> ( !<a class="code" href="classosgEarth_1_1SpatialReference.html#ab417ba457cf34b87ad65f77651b2dec8">_initialized</a> )
<a name="l00687"></a>00687         <span class="keyword">const_cast&lt;</span><a class="code" href="classseamless_1_1EulerSpatialReference.html">EulerSpatialReference</a>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;<a class="code" href="classosgEarth_1_1SpatialReference.html#ad4674227fe46613b3f5821109a509714">init</a>();
<a name="l00688"></a>00688     <span class="keywordflow">if</span> (!to_srs-&gt;<a class="code" href="classosgEarth_1_1SpatialReference.html#a398407559e7c170fc44cde6842511548">isEquivalentTo</a>(<a class="code" href="classosgEarth_1_1SpatialReference.html#a42fc6ea305be6b94340bf300d7b67dbe">getGeographicSRS</a>()))
<a name="l00689"></a>00689         <span class="keywordflow">return</span> <a class="code" href="classosgEarth_1_1SpatialReference.html#a28d916a87ed2653a5763bf8777cd9cbf">SpatialReference::transform</a>(x, y, to_srs, out_x, out_y, context);
<a name="l00690"></a>00690     <span class="keywordflow">if</span> (<a class="code" href="classseamless_1_1EulerSpatialReference.html#a2fe582b3bfe6faa7902b04e802423551">EulerSpatialReference::preTransform</a>(x, y, context))
<a name="l00691"></a>00691     {
<a name="l00692"></a>00692         out_x = x;
<a name="l00693"></a>00693         out_y = y;
<a name="l00694"></a>00694         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00695"></a>00695     }
<a name="l00696"></a>00696     <span class="keywordflow">else</span>
<a name="l00697"></a>00697     {
<a name="l00698"></a>00698         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00699"></a>00699     }
<a name="l00700"></a>00700 }
<a name="l00701"></a>00701 
<a name="l00702"></a><a class="code" href="classseamless_1_1EulerSpatialReference.html#a6a526ba843cecf5df2dbc1b087b80ac5">00702</a> <span class="keywordtype">bool</span> <a class="code" href="classseamless_1_1EulerSpatialReference.html#a6a526ba843cecf5df2dbc1b087b80ac5">EulerSpatialReference::transformPoints</a>(<span class="keyword">const</span> <a class="code" href="classosgEarth_1_1SpatialReference.html">SpatialReference</a>* to_srs, 
<a name="l00703"></a>00703                                             <span class="keywordtype">double</span>* x, <span class="keywordtype">double</span> *y,
<a name="l00704"></a>00704                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numPoints,
<a name="l00705"></a>00705                                             <span class="keywordtype">void</span>* context,
<a name="l00706"></a>00706                                             <span class="keywordtype">bool</span> ignore_errors)<span class="keyword"> const</span>
<a name="l00707"></a>00707 <span class="keyword"></span>{
<a name="l00708"></a>00708         <span class="keywordflow">if</span> ( !<a class="code" href="classosgEarth_1_1SpatialReference.html#ab417ba457cf34b87ad65f77651b2dec8">_initialized</a> )
<a name="l00709"></a>00709             <span class="keyword">const_cast&lt;</span><a class="code" href="classseamless_1_1EulerSpatialReference.html">EulerSpatialReference</a>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;<a class="code" href="classosgEarth_1_1SpatialReference.html#ad4674227fe46613b3f5821109a509714">init</a>();
<a name="l00710"></a>00710         <span class="keywordflow">if</span> (!to_srs-&gt;<a class="code" href="classosgEarth_1_1SpatialReference.html#a398407559e7c170fc44cde6842511548">isEquivalentTo</a>(<a class="code" href="classosgEarth_1_1SpatialReference.html#a42fc6ea305be6b94340bf300d7b67dbe">getGeographicSRS</a>()))
<a name="l00711"></a>00711             <span class="keywordflow">return</span> <a class="code" href="classosgEarth_1_1SpatialReference.html#a3c3d798015a48c93c5063182ac177688">SpatialReference::transformPoints</a>(to_srs, x, y, numPoints,
<a name="l00712"></a>00712                                                      context, ignore_errors);
<a name="l00713"></a>00713         <span class="keywordtype">bool</span> success = <span class="keyword">true</span>;
<a name="l00714"></a>00714         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numPoints; ++i)
<a name="l00715"></a>00715         {
<a name="l00716"></a>00716             <span class="keywordtype">bool</span> result
<a name="l00717"></a>00717                 = <a class="code" href="classseamless_1_1EulerSpatialReference.html#a2fe582b3bfe6faa7902b04e802423551">EulerSpatialReference::preTransform</a>(x[i], y[i], context);
<a name="l00718"></a>00718             success = success &amp;&amp; result;
<a name="l00719"></a>00719         }
<a name="l00720"></a>00720         <span class="keywordflow">return</span> success;
<a name="l00721"></a>00721 }
<a name="l00722"></a>00722 
<a name="l00723"></a>00723 <span class="keywordtype">bool</span>
<a name="l00724"></a><a class="code" href="classseamless_1_1EulerSpatialReference.html#a2c6c66f4c1d8ef866e14c9d1423a48b6">00724</a> <a class="code" href="classseamless_1_1EulerSpatialReference.html#a2c6c66f4c1d8ef866e14c9d1423a48b6">EulerSpatialReference::transformExtent</a>(<span class="keyword">const</span> <a class="code" href="classosgEarth_1_1SpatialReference.html">SpatialReference</a>* to_srs,
<a name="l00725"></a>00725                                      <span class="keywordtype">double</span>&amp; in_out_xmin,
<a name="l00726"></a>00726                                      <span class="keywordtype">double</span>&amp; in_out_ymin,
<a name="l00727"></a>00727                                      <span class="keywordtype">double</span>&amp; in_out_xmax,
<a name="l00728"></a>00728                                      <span class="keywordtype">double</span>&amp; in_out_ymax,
<a name="l00729"></a>00729                                      <span class="keywordtype">void</span>* context )<span class="keyword"> const</span>
<a name="l00730"></a>00730 <span class="keyword"></span>{
<a name="l00731"></a>00731     <span class="comment">// note: this method only works when the extent is isolated to one</span>
<a name="l00732"></a>00732     <span class="comment">// face of the cube. If you want to transform an arbitrary extent,</span>
<a name="l00733"></a>00733     <span class="comment">// you need to break it up into separate extents for each cube face.</span>
<a name="l00734"></a>00734     <span class="keywordtype">bool</span> ok = <span class="keyword">true</span>;
<a name="l00735"></a>00735 
<a name="l00736"></a>00736     <span class="keywordtype">double</span> face_xmin = in_out_xmin, face_ymin = in_out_ymin;
<a name="l00737"></a>00737     <span class="keywordtype">double</span> face_xmax = in_out_xmax, face_ymax = in_out_ymax;
<a name="l00738"></a>00738 
<a name="l00739"></a>00739     <span class="keywordtype">int</span> face;
<a name="l00740"></a>00740     <span class="keywordflow">if</span> (!<a class="code" href="namespaceseamless_1_1euler.html#ac308eca82b121ca0e15a1835d0137421">cubeToFace</a>(face_xmin, face_ymin, face_xmax, face_ymax, face))
<a name="l00741"></a>00741     {
<a name="l00742"></a>00742         <a class="code" href="Notify.html#a13b79c6470fc74594070bd2098afc9de">OE_WARN</a> &lt;&lt; <a class="code" href="Euler_8cpp.html#aa499bb75bb504909cd0a72baf48c4653">LC</a> &lt;&lt; <span class="stringliteral">&quot;extent (&quot;</span> &lt;&lt; in_out_xmin &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; in_out_ymin
<a name="l00743"></a>00743                 &lt;&lt; <span class="stringliteral">&quot;)=&gt;(&quot;</span> &lt;&lt; in_out_xmax &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; in_out_ymax &lt;&lt;
<a name="l00744"></a>00744             <span class="stringliteral">&quot;) crosses faces\n&quot;</span>;
<a name="l00745"></a>00745         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00746"></a>00746     }
<a name="l00747"></a>00747     <span class="comment">// The polar and equatorial faces behave the same way, except if</span>
<a name="l00748"></a>00748     <span class="comment">// an extent crosses the pole.</span>
<a name="l00749"></a>00749 
<a name="l00750"></a>00750     <span class="keywordtype">double</span> lonmin, lonmax, latmin, latmax;
<a name="l00751"></a>00751     <span class="comment">// if the extent crosses the center axes of the face, then,</span>
<a name="l00752"></a>00752     <span class="comment">// due to the curvy nature of the projection, the maximim /</span>
<a name="l00753"></a>00753     <span class="comment">// minimum will be at the crossing. So we may need to sample</span>
<a name="l00754"></a>00754     <span class="comment">// up to 8 points.</span>
<a name="l00755"></a>00755     <span class="keywordtype">double</span> lats[8], lons[8];
<a name="l00756"></a>00756     <span class="keywordtype">int</span> numSamples = 4;
<a name="l00757"></a>00757     <a class="code" href="namespaceseamless_1_1euler.html#a716d5725e48c780ee396bed196a903bc">faceCoordsToLatLon</a>(face_xmin, face_ymin, face, lats[0], lons[0]);
<a name="l00758"></a>00758     <a class="code" href="namespaceseamless_1_1euler.html#a716d5725e48c780ee396bed196a903bc">faceCoordsToLatLon</a>(face_xmax, face_ymin, face, lats[1], lons[1]);
<a name="l00759"></a>00759     <a class="code" href="namespaceseamless_1_1euler.html#a716d5725e48c780ee396bed196a903bc">faceCoordsToLatLon</a>(face_xmin, face_ymax, face, lats[2], lons[2]);
<a name="l00760"></a>00760     <a class="code" href="namespaceseamless_1_1euler.html#a716d5725e48c780ee396bed196a903bc">faceCoordsToLatLon</a>(face_xmax, face_ymax, face, lats[3], lons[3]);
<a name="l00761"></a>00761 
<a name="l00762"></a>00762     <span class="keywordflow">if</span> ((face_xmin &lt; 0 &amp;&amp; face_xmax &gt; 0))
<a name="l00763"></a>00763     {
<a name="l00764"></a>00764         <a class="code" href="namespaceseamless_1_1euler.html#a716d5725e48c780ee396bed196a903bc">faceCoordsToLatLon</a>(0.0, face_ymin, face,
<a name="l00765"></a>00765                            lats[numSamples], lons[numSamples]);
<a name="l00766"></a>00766         <a class="code" href="namespaceseamless_1_1euler.html#a716d5725e48c780ee396bed196a903bc">faceCoordsToLatLon</a>(0.0, face_ymax, face,
<a name="l00767"></a>00767                            lats[numSamples + 1], lons[numSamples + 1]);
<a name="l00768"></a>00768         numSamples += 2;
<a name="l00769"></a>00769 
<a name="l00770"></a>00770     }
<a name="l00771"></a>00771     <span class="keywordflow">if</span> ((face_ymin &lt; 0 &amp;&amp; face_ymax &gt; 0))
<a name="l00772"></a>00772     {
<a name="l00773"></a>00773         <a class="code" href="namespaceseamless_1_1euler.html#a716d5725e48c780ee396bed196a903bc">faceCoordsToLatLon</a>(face_xmin, 0.0, face,
<a name="l00774"></a>00774                            lats[numSamples], lons[numSamples]);
<a name="l00775"></a>00775         <a class="code" href="namespaceseamless_1_1euler.html#a716d5725e48c780ee396bed196a903bc">faceCoordsToLatLon</a>(face_xmax, 0.0, face,
<a name="l00776"></a>00776                            lats[numSamples + 1], lons[numSamples + 1]);
<a name="l00777"></a>00777         numSamples += 2;
<a name="l00778"></a>00778 
<a name="l00779"></a>00779     }
<a name="l00780"></a>00780     <span class="comment">// keep extent longitudes consistent. If the max latitude lies on</span>
<a name="l00781"></a>00781     <span class="comment">// the date line, its value should be 180, not -180. The poles are</span>
<a name="l00782"></a>00782     <span class="comment">// especially interesting...</span>
<a name="l00783"></a>00783     <span class="keywordflow">if</span> (face == 2 &amp;&amp; face_xmax == 0.0)
<a name="l00784"></a>00784     {
<a name="l00785"></a>00785         lons[1] = 180.0;
<a name="l00786"></a>00786         lons[3] = 180.0;
<a name="l00787"></a>00787     }
<a name="l00788"></a>00788     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((face == 4 &amp;&amp; face_ymax &gt; 0.0)
<a name="l00789"></a>00789              || (face == 5 &amp;&amp; face_ymax &lt;= 0.0))
<a name="l00790"></a>00790     {
<a name="l00791"></a>00791         <span class="keywordflow">if</span> (face_xmin == 0.0)
<a name="l00792"></a>00792         {
<a name="l00793"></a>00793             lons[0] = 180.0;
<a name="l00794"></a>00794             lons[2] = 180.0;
<a name="l00795"></a>00795         }
<a name="l00796"></a>00796         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face_xmax == 0.0)
<a name="l00797"></a>00797         {
<a name="l00798"></a>00798             lons[1] = -180.0;
<a name="l00799"></a>00799             lons[3] = -180.0;
<a name="l00800"></a>00800         }
<a name="l00801"></a>00801     }
<a name="l00802"></a>00802     <span class="keywordflow">if</span> ((face == 4 || face == 5) &amp;&amp; face_ymax == 0.0)
<a name="l00803"></a>00803     {
<a name="l00804"></a>00804         <span class="keywordflow">if</span>  (face_xmax == 0.0)
<a name="l00805"></a>00805             lons[3] = -90;
<a name="l00806"></a>00806         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face_xmin == 0.0)
<a name="l00807"></a>00807             lons[2] = 90;
<a name="l00808"></a>00808             
<a name="l00809"></a>00809     }
<a name="l00810"></a>00810     lonmin = *min_element(&amp;lons[0], &amp;lons[numSamples]);
<a name="l00811"></a>00811     latmin = *min_element(&amp;lats[0], &amp;lats[numSamples]);
<a name="l00812"></a>00812     lonmax = *max_element(&amp;lons[0], &amp;lons[numSamples]);
<a name="l00813"></a>00813     latmax = *max_element(&amp;lats[0], &amp;lats[numSamples]);
<a name="l00814"></a>00814     <span class="comment">// Does the extent cross one of the poles?</span>
<a name="l00815"></a>00815     <span class="keywordflow">if</span> ((face == 4 || face == 5) &amp;&amp; numSamples == 8)
<a name="l00816"></a>00816     {
<a name="l00817"></a>00817         lonmin = -180.0;
<a name="l00818"></a>00818         lonmax = 180.0;
<a name="l00819"></a>00819         <span class="keywordflow">if</span> (face == 4)
<a name="l00820"></a>00820             latmax = 90.0;
<a name="l00821"></a>00821         <span class="keywordflow">else</span>
<a name="l00822"></a>00822             latmin = -90.0;
<a name="l00823"></a>00823     }
<a name="l00824"></a>00824     <span class="comment">// Check for Date Line crossing</span>
<a name="l00825"></a>00825     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (face_xmin &lt; 0 &amp;&amp; face_xmax &gt; 0
<a name="l00826"></a>00826              &amp;&amp; (face == 2 || (face == 4 &amp;&amp; face_ymin &gt;= 0)
<a name="l00827"></a>00827                  || (face == 5 &amp;&amp; face_ymax &lt;= 0)))
<a name="l00828"></a>00828     {
<a name="l00829"></a>00829         std::swap(lonmin, lonmax);
<a name="l00830"></a>00830     }
<a name="l00831"></a>00831     <span class="keywordflow">if</span> (to_srs-&gt;<a class="code" href="classosgEarth_1_1SpatialReference.html#adfb00834f8d96146b119add7ec2c93a3">isGeographic</a>())
<a name="l00832"></a>00832     {
<a name="l00833"></a>00833         in_out_xmin = lonmin;
<a name="l00834"></a>00834         in_out_xmax = lonmax;
<a name="l00835"></a>00835         in_out_ymin = latmin;
<a name="l00836"></a>00836         in_out_ymax = latmax;
<a name="l00837"></a>00837     }
<a name="l00838"></a>00838     <span class="keywordflow">else</span>
<a name="l00839"></a>00839     {
<a name="l00840"></a>00840         <span class="keywordtype">bool</span> ok1 = <a class="code" href="classseamless_1_1EulerSpatialReference.html#aa6a2a563b63f9b3ce2fe8606b1ede863">transform</a>(lonmin, latmin, to_srs, in_out_xmin, in_out_ymin,
<a name="l00841"></a>00841                              context);
<a name="l00842"></a>00842         <span class="keywordtype">bool</span> ok2 = <a class="code" href="classseamless_1_1EulerSpatialReference.html#aa6a2a563b63f9b3ce2fe8606b1ede863">transform</a>(lonmax, latmax, to_srs, in_out_xmax, in_out_ymax,
<a name="l00843"></a>00843                              context);
<a name="l00844"></a>00844         ok = ok1 &amp;&amp; ok2;
<a name="l00845"></a>00845     }
<a name="l00846"></a>00846     <span class="keywordflow">return</span> ok;
<a name="l00847"></a>00847 }
<a name="l00848"></a>00848 
<a name="l00849"></a>00849 <span class="comment">// This has been written to minimize the number of transcendental</span>
<a name="l00850"></a>00850 <span class="comment">// function calls -- as well as other expensive operations -- in the</span>
<a name="l00851"></a>00851 <span class="comment">// inner loop.</span>
<a name="l00852"></a><a class="code" href="classseamless_1_1EulerSpatialReference.html#a719d93987f1733d65d0dca9c9b9763f6">00852</a> <span class="keywordtype">bool</span> <a class="code" href="classseamless_1_1EulerSpatialReference.html#a719d93987f1733d65d0dca9c9b9763f6">EulerSpatialReference::transformExtentPoints</a>(
<a name="l00853"></a>00853     <span class="keyword">const</span> <a class="code" href="classosgEarth_1_1SpatialReference.html">SpatialReference</a>* to_srs,
<a name="l00854"></a>00854     <span class="keywordtype">double</span> in_xmin, <span class="keywordtype">double</span> in_ymin,
<a name="l00855"></a>00855     <span class="keywordtype">double</span> in_xmax, <span class="keywordtype">double</span> in_ymax,
<a name="l00856"></a>00856     <span class="keywordtype">double</span>* x, <span class="keywordtype">double</span> *y,
<a name="l00857"></a>00857     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numx, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numy,
<a name="l00858"></a>00858     <span class="keywordtype">void</span>* context, <span class="keywordtype">bool</span> ignore_errors )<span class="keyword"> const</span>
<a name="l00859"></a>00859 <span class="keyword"></span>{
<a name="l00860"></a>00860     <span class="keywordflow">if</span> ( !<a class="code" href="classosgEarth_1_1SpatialReference.html#ab417ba457cf34b87ad65f77651b2dec8">_initialized</a> )
<a name="l00861"></a>00861         <span class="keyword">const_cast&lt;</span><a class="code" href="classseamless_1_1EulerSpatialReference.html">EulerSpatialReference</a>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;<a class="code" href="classosgEarth_1_1SpatialReference.html#ad4674227fe46613b3f5821109a509714">init</a>();
<a name="l00862"></a>00862     <span class="keywordtype">int</span> face;
<a name="l00863"></a>00863 
<a name="l00864"></a>00864     <span class="comment">// Punt if the extent covers more than one face (doesn&#39;t happen</span>
<a name="l00865"></a>00865     <span class="comment">// normally).</span>
<a name="l00866"></a>00866     <span class="keywordflow">if</span> (!(to_srs-&gt;<a class="code" href="classosgEarth_1_1SpatialReference.html#a398407559e7c170fc44cde6842511548">isEquivalentTo</a>(<a class="code" href="classosgEarth_1_1SpatialReference.html#a42fc6ea305be6b94340bf300d7b67dbe">getGeographicSRS</a>())
<a name="l00867"></a>00867           &amp;&amp; <a class="code" href="namespaceseamless_1_1euler.html#ac308eca82b121ca0e15a1835d0137421">cubeToFace</a>(in_xmin, in_ymin, in_xmax, in_ymax, face)))
<a name="l00868"></a>00868         <span class="keywordflow">return</span> <a class="code" href="classseamless_1_1EulerSpatialReference.html#a719d93987f1733d65d0dca9c9b9763f6">SpatialReference::transformExtentPoints</a>(
<a name="l00869"></a>00869             to_srs, in_xmin, in_ymin, in_xmax, in_ymax, x, y,
<a name="l00870"></a>00870             numx, numy, context, ignore_errors);
<a name="l00871"></a>00871     <span class="keyword">const</span> <span class="keywordtype">double</span> dx = (in_xmax - in_xmin) / (numx - 1);
<a name="l00872"></a>00872     <span class="keyword">const</span> <span class="keywordtype">double</span> dy = (in_ymax - in_ymin) / (numy - 1);
<a name="l00873"></a>00873     <span class="keywordtype">unsigned</span> pixel = 0;
<a name="l00874"></a>00874     <span class="comment">// Cache values for and tan(y)</span>
<a name="l00875"></a>00875     <a class="code" href="classseamless_1_1AutoBuffer.html">AutoBuffer&lt;double, 256&gt;</a> tany(numy);
<a name="l00876"></a>00876     <span class="comment">// induction variables for column and row counters</span>
<a name="l00877"></a>00877     <span class="keywordtype">double</span> fc = 0.0, fr = 0.0;
<a name="l00878"></a>00878     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> r = 0; r &lt; numy; ++r, ++fr)
<a name="l00879"></a>00879         tany[r] = tan((in_ymin + fr * dy) * osg::PI_4);
<a name="l00880"></a>00880     <span class="keywordflow">if</span> (face &lt; 4)
<a name="l00881"></a>00881     {
<a name="l00882"></a>00882         <span class="keywordtype">double</span> lonBase = face * osg::PI_2;
<a name="l00883"></a>00883         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> c = 0; c &lt; numx; ++c, ++fc)
<a name="l00884"></a>00884         {
<a name="l00885"></a>00885             <span class="keyword">const</span> <span class="keywordtype">double</span> l = (in_xmin + fc * dx) * osg::PI_4;
<a name="l00886"></a>00886             <span class="keywordtype">double</span> lon = lonBase + l;
<a name="l00887"></a>00887             lon = fmod(lon + osg::PI, 2.0 * osg::PI) - osg::PI;
<a name="l00888"></a>00888             <span class="keyword">const</span> <span class="keywordtype">double</span> rlon = RadiansToDegrees(lon);
<a name="l00889"></a>00889             <span class="keyword">const</span> <span class="keywordtype">double</span> cosl = cos(l);
<a name="l00890"></a>00890             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> r = 0; r &lt; numy; ++r)
<a name="l00891"></a>00891             {
<a name="l00892"></a>00892                 <span class="keyword">const</span> <span class="keywordtype">double</span> lat = atan(cosl * tany[r]);
<a name="l00893"></a>00893                 x[pixel] = rlon;
<a name="l00894"></a>00894                 y[pixel] = RadiansToDegrees(lat);
<a name="l00895"></a>00895                 pixel++;
<a name="l00896"></a>00896             }
<a name="l00897"></a>00897         }
<a name="l00898"></a>00898     }
<a name="l00899"></a>00899     <span class="keywordflow">else</span>
<a name="l00900"></a>00900     {
<a name="l00901"></a>00901         <span class="comment">// The pole faces are the same, except for a change of sign in</span>
<a name="l00902"></a>00902         <span class="comment">// the latitude and longitude calculations.</span>
<a name="l00903"></a>00903         <span class="keyword">const</span> <span class="keywordtype">double</span> sgn = face == 4 ? -1.0 : 1.0;
<a name="l00904"></a>00904         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> c = 0; c &lt; numx; ++c, ++fc)
<a name="l00905"></a>00905         {
<a name="l00906"></a>00906             <span class="keyword">const</span> <span class="keywordtype">double</span> l = (in_xmin + fc * dx) * osg::PI_4;
<a name="l00907"></a>00907             <span class="keyword">const</span> <span class="keywordtype">double</span> tx = tan(l);
<a name="l00908"></a>00908             <span class="keyword">const</span> <span class="keywordtype">double</span> tx2 = tx * tx;
<a name="l00909"></a>00909             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> r = 0; r &lt; numy; ++r)
<a name="l00910"></a>00910             {
<a name="l00911"></a>00911                 <span class="keyword">const</span> <span class="keywordtype">double</span> ty = tany[r];
<a name="l00912"></a>00912                 <span class="keyword">const</span> <span class="keywordtype">double</span> lon = atan2(tx, sgn * ty);
<a name="l00913"></a>00913                 <span class="keyword">const</span> <span class="keywordtype">double</span> lat = (atan(sqrt(tx2 + ty * ty)) - osg::PI_2)
<a name="l00914"></a>00914                     * sgn;
<a name="l00915"></a>00915                 x[pixel] = RadiansToDegrees(lon);
<a name="l00916"></a>00916                 y[pixel] = RadiansToDegrees(lat);
<a name="l00917"></a>00917                 pixel++;
<a name="l00918"></a>00918             }
<a name="l00919"></a>00919         }
<a name="l00920"></a>00920     }
<a name="l00921"></a>00921     <span class="keyword">const</span> <span class="keywordtype">int</span> numPixels = numx * numy;
<a name="l00922"></a>00922     <span class="comment">// Fixups for boundary lieing on date line</span>
<a name="l00923"></a>00923     <span class="keywordflow">if</span> (face == 2 &amp;&amp; in_xmax == 0.0)
<a name="l00924"></a>00924     {
<a name="l00925"></a>00925         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> pixel = numx - 1; pixel &lt; numPixels; pixel += numx)
<a name="l00926"></a>00926             x[pixel] = 180;
<a name="l00927"></a>00927     }
<a name="l00928"></a>00928     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((face == 4 &amp;&amp; in_ymax &gt; 0.0)
<a name="l00929"></a>00929              || (face == 5 &amp;&amp; in_ymax &lt;= 0.0))
<a name="l00930"></a>00930     {
<a name="l00931"></a>00931         <span class="keywordtype">double</span> val;
<a name="l00932"></a>00932         <span class="keywordtype">int</span> startPix = -1;
<a name="l00933"></a>00933         <span class="keywordflow">if</span> (in_xmin == 0.0)
<a name="l00934"></a>00934         {
<a name="l00935"></a>00935             val = 180.0;
<a name="l00936"></a>00936             startPix = 0;
<a name="l00937"></a>00937         }
<a name="l00938"></a>00938         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (in_xmax == 0.0)
<a name="l00939"></a>00939         {
<a name="l00940"></a>00940             val = -180.0;
<a name="l00941"></a>00941             startPix = numx - 1;
<a name="l00942"></a>00942         }
<a name="l00943"></a>00943         <span class="keywordflow">if</span> (startPix &gt; 0)
<a name="l00944"></a>00944             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> pixel = startPix; pixel &lt; numPixels; pixel += numx)
<a name="l00945"></a>00945                 x[pixel] = val;
<a name="l00946"></a>00946     }
<a name="l00947"></a>00947     <span class="comment">// pole case</span>
<a name="l00948"></a>00948     <span class="keywordflow">if</span> ((face == 4 || face == 5) &amp;&amp; in_ymax == 0.0)
<a name="l00949"></a>00949     {
<a name="l00950"></a>00950         <span class="keywordflow">if</span> (in_xmax == 0.0)
<a name="l00951"></a>00951             x[numPixels - 1] = -90.0;
<a name="l00952"></a>00952         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (in_xmin == 0.0)
<a name="l00953"></a>00953             x[numx * (numy - 1)] = 90;
<a name="l00954"></a>00954     }
<a name="l00955"></a>00955     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00956"></a>00956 }
<a name="l00957"></a>00957 
<a name="l00958"></a><a class="code" href="namespaceseamless_1_1anonymous__namespace_02Euler_8cpp_03.html">00958</a> <span class="keyword">namespace</span>
<a name="l00959"></a>00959 {
<a name="l00960"></a><a class="code" href="namespaceseamless_1_1anonymous__namespace_02Euler_8cpp_03.html#a49e7e4018e57c89b9c7b3726b9cbdeaa">00960</a> <a class="code" href="classosgEarth_1_1SpatialReference.html">SpatialReference</a>* <a class="code" href="namespaceseamless_1_1anonymous__namespace_02Euler_8cpp_03.html#a49e7e4018e57c89b9c7b3726b9cbdeaa">createEulerSRS</a>()
<a name="l00961"></a>00961 {
<a name="l00962"></a>00962     <span class="comment">// root the cube srs with a WGS84 intermediate ellipsoid.</span>
<a name="l00963"></a>00963     std::string init = <span class="stringliteral">&quot;+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs&quot;</span>;
<a name="l00964"></a>00964 
<a name="l00965"></a>00965     <a class="code" href="classosgEarth_1_1SpatialReference.html">SpatialReference</a>* result = 0;
<a name="l00966"></a>00966     <a class="code" href="Registry.html#af57173fda5dd7d12d263f1adfbc69d52">GDAL_SCOPED_LOCK</a>;
<a name="l00967"></a>00967     <span class="keywordtype">void</span>* handle = OSRNewSpatialReference(0);
<a name="l00968"></a>00968     <span class="keywordflow">if</span> ( OSRImportFromProj4( handle, init.c_str() ) == OGRERR_NONE )
<a name="l00969"></a>00969         {
<a name="l00970"></a>00970         result = <span class="keyword">new</span> <a class="code" href="classseamless_1_1EulerSpatialReference.html">EulerSpatialReference</a>( handle );
<a name="l00971"></a>00971         }
<a name="l00972"></a>00972         <span class="keywordflow">else</span>
<a name="l00973"></a>00973         {
<a name="l00974"></a>00974         <a class="code" href="Notify.html#a13b79c6470fc74594070bd2098afc9de">OE_WARN</a> &lt;&lt; <span class="stringliteral">&quot;[osgEarth::SRS] Unable to create SRS: &quot;</span> &lt;&lt; init &lt;&lt; std::endl;
<a name="l00975"></a>00975         OSRDestroySpatialReference( handle );
<a name="l00976"></a>00976         }
<a name="l00977"></a>00977     <span class="keywordflow">return</span> result;
<a name="l00978"></a>00978 }
<a name="l00979"></a>00979 }
<a name="l00980"></a>00980 
<a name="l00981"></a>00981 <span class="comment">// Hack to get euler-cube into the spatial reference cache</span>
<a name="l00982"></a><a class="code" href="classseamless_1_1CacheInitializer.html">00982</a> <span class="keyword">class </span><a class="code" href="classseamless_1_1CacheInitializer.html">CacheInitializer</a>
<a name="l00983"></a>00983 {
<a name="l00984"></a>00984 <span class="keyword">public</span>:
<a name="l00985"></a><a class="code" href="classseamless_1_1CacheInitializer.html#a1f203633f346ad740a8e43e6f62fb584">00985</a>     <a class="code" href="classseamless_1_1CacheInitializer.html#a1f203633f346ad740a8e43e6f62fb584">CacheInitializer</a>()
<a name="l00986"></a>00986     {
<a name="l00987"></a>00987         <a class="code" href="classosgEarth_1_1SpatialReference.html#a1ce7bab196098591946294d17771c355">EulerSpatialReference::getSpatialReferenceCache</a>()[<span class="stringliteral">&quot;euler-cube&quot;</span>]
<a name="l00988"></a>00988             = <a class="code" href="namespaceseamless_1_1anonymous__namespace_02Euler_8cpp_03.html#a49e7e4018e57c89b9c7b3726b9cbdeaa">createEulerSRS</a>();
<a name="l00989"></a>00989     }
<a name="l00990"></a>00990 };
<a name="l00991"></a>00991 
<a name="l00992"></a>00992 <span class="keyword">namespace</span>
<a name="l00993"></a>00993 {
<a name="l00994"></a><a class="code" href="namespaceseamless_1_1anonymous__namespace_02Euler_8cpp_03.html#aa9f05d80e9f1a9923f51f5a066b1ea77">00994</a> <a class="code" href="classseamless_1_1CacheInitializer.html">CacheInitializer</a> <a class="code" href="namespaceseamless_1_1anonymous__namespace_02Euler_8cpp_03.html#aa9f05d80e9f1a9923f51f5a066b1ea77">s_cacheInitializer</a>;
<a name="l00995"></a>00995 }
<a name="l00996"></a>00996 
<a name="l00997"></a><a class="code" href="classseamless_1_1EulerProfile.html#ad00d103320cabc222d0ba021f55308a1">00997</a> <a class="code" href="classseamless_1_1EulerProfile.html#ad00d103320cabc222d0ba021f55308a1">EulerProfile::EulerProfile</a>()
<a name="l00998"></a>00998     : <a class="code" href="classosgEarth_1_1Profile.html">Profile</a>(<a class="code" href="namespaceseamless_1_1anonymous__namespace_02Euler_8cpp_03.html#a49e7e4018e57c89b9c7b3726b9cbdeaa">createEulerSRS</a>(),
<a name="l00999"></a>00999               0.0, 0.0, 4.0, 4.0,
<a name="l01000"></a>01000               -180.0, -90.0, 180.0, 90.0,
<a name="l01001"></a>01001               0,
<a name="l01002"></a>01002               1, 1)
<a name="l01003"></a>01003 {
<a name="l01004"></a>01004 }
<a name="l01005"></a>01005 
<a name="l01006"></a><a class="code" href="classseamless_1_1EulerProfile.html#a28b2317a08521b3e477b86d7492454fa">01006</a> <span class="keywordtype">int</span> <a class="code" href="classseamless_1_1EulerProfile.html#a28b2317a08521b3e477b86d7492454fa">EulerProfile::getFace</a>(<span class="keyword">const</span> <a class="code" href="classosgEarth_1_1TileKey.html">TileKey</a>&amp; key)
<a name="l01007"></a>01007 {
<a name="l01008"></a>01008     <span class="keywordtype">int</span> shiftVal = key.<a class="code" href="classosgEarth_1_1TileKey.html#a0ee6b25bbae560dda11987ac1e9dc69d">getLevelOfDetail</a>() - 2;
<a name="l01009"></a>01009     <span class="keywordtype">int</span> faceX = key.<a class="code" href="classosgEarth_1_1TileKey.html#add6a3c7117d189c2d801bc77f0e7b697">getTileX</a>() &gt;&gt; shiftVal;
<a name="l01010"></a>01010     <span class="keywordtype">int</span> faceY = key.<a class="code" href="classosgEarth_1_1TileKey.html#ad1ff38fbd762c0faba5b03b326617628">getTileY</a>() &gt;&gt; shiftVal;
<a name="l01011"></a>01011     <span class="keywordflow">if</span> (faceY == 1)
<a name="l01012"></a>01012         <span class="keywordflow">return</span> 4;
<a name="l01013"></a>01013     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (faceY == 3)
<a name="l01014"></a>01014         <span class="keywordflow">return</span> 5;
<a name="l01015"></a>01015     <span class="keywordflow">else</span>
<a name="l01016"></a>01016         <span class="keywordflow">return</span> faceX;
<a name="l01017"></a>01017 }
<a name="l01018"></a>01018 
<a name="l01019"></a><a class="code" href="classseamless_1_1QscProfile.html#ae5b51e04455b2943d8637ccdee278c91">01019</a> <span class="keywordtype">void</span> <a class="code" href="classseamless_1_1EulerProfile.html#a15d4fe4c16af0901006f44e9d5519b6f">EulerProfile::getIntersectingTiles</a>(
<a name="l01020"></a>01020     <span class="keyword">const</span> <a class="code" href="classosgEarth_1_1GeoExtent.html">GeoExtent</a>&amp; remoteExtent,
<a name="l01021"></a>01021     std::vector&lt;TileKey&gt;&amp; out_intersectingKeys )<span class="keyword"> const</span>
<a name="l01022"></a>01022 <span class="keyword"></span>{
<a name="l01023"></a>01023     <a class="code" href="Notify.html#ada0e7cd149c9214a8c39659934d9c076">OE_FATAL</a> &lt;&lt; <span class="stringliteral">&quot;EulerProfile::getIntersectingTiles not implemented yet!\n&quot;</span>;
<a name="l01024"></a>01024 }
<a name="l01025"></a>01025 
<a name="l01026"></a>01026 }
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Jan 18 2012 15:02:39 for osgEarth by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
