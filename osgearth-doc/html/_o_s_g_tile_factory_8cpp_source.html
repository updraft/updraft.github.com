<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>osgEarth: /home/cube/sources/osgearth/src/osgEarthDrivers/engine_osgterrain/OSGTileFactory.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">osgEarth</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('_o_s_g_tile_factory_8cpp.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<h1>/home/cube/sources/osgearth/src/osgEarthDrivers/engine_osgterrain/OSGTileFactory.cpp</h1>  </div>
</div>
<div class="contents">
<a href="_o_s_g_tile_factory_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* -*-c++-*- */</span>
<a name="l00002"></a>00002 <span class="comment">/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph</span>
<a name="l00003"></a>00003 <span class="comment">* Copyright 2008-2010 Pelican Mapping</span>
<a name="l00004"></a>00004 <span class="comment">* http://osgearth.org</span>
<a name="l00005"></a>00005 <span class="comment">*</span>
<a name="l00006"></a>00006 <span class="comment">* osgEarth is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment">* it under the terms of the GNU Lesser General Public License as published by</span>
<a name="l00008"></a>00008 <span class="comment">* the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00009"></a>00009 <span class="comment">* (at your option) any later version.</span>
<a name="l00010"></a>00010 <span class="comment">*</span>
<a name="l00011"></a>00011 <span class="comment">* This program is distributed in the hope that it will be useful,</span>
<a name="l00012"></a>00012 <span class="comment">* but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00013"></a>00013 <span class="comment">* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00014"></a>00014 <span class="comment">* GNU Lesser General Public License for more details.</span>
<a name="l00015"></a>00015 <span class="comment">*</span>
<a name="l00016"></a>00016 <span class="comment">* You should have received a copy of the GNU Lesser General Public License</span>
<a name="l00017"></a>00017 <span class="comment">* along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;</span>
<a name="l00018"></a>00018 <span class="comment">*/</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;OSGTileFactory&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;Terrain&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;StreamingTerrain&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;FileLocationCallback&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;TransparentLayer&quot;</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;osgEarth/Map&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;osgEarth/Caching&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;osgEarth/HeightFieldUtils&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;osgEarth/Registry&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;osgEarth/ImageUtils&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;osgEarth/TileSource&gt;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;osg/Image&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;osg/Notify&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;osg/PagedLOD&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;osg/ClusterCullingCallback&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;osg/CoordinateSystemNode&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;osgFX/MultiTextureControl&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;osgDB/ReadFile&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;osgDB/WriteFile&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;osgTerrain/Locator&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;osgTerrain/GeometryTechnique&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;OpenThreads/ReentrantMutex&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="keyword">using namespace </span>OpenThreads;
<a name="l00047"></a>00047 <span class="keyword">using namespace </span>osgEarth;
<a name="l00048"></a>00048 <span class="keyword">using namespace </span>osgEarth::Drivers;
<a name="l00049"></a>00049 
<a name="l00050"></a><a class="code" href="_o_s_g_tile_factory_8cpp.html#aa499bb75bb504909cd0a72baf48c4653">00050</a> <span class="preprocessor">#define LC &quot;[OSGTileFactory] &quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>
<a name="l00052"></a>00052 <span class="comment">/*****************************************************************************/</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="keyword">namespace</span>
<a name="l00055"></a>00055 {
<a name="l00056"></a>00056     <span class="comment">//TODO: get rid of this, and move it to the CustomTerrain CULL traversal....?????</span>
<a name="l00057"></a>00057     <span class="keyword">struct </span>PopulateStreamingTileDataCallback : <span class="keyword">public</span> osg::NodeCallback
<a name="l00058"></a>00058     {
<a name="l00059"></a>00059         PopulateStreamingTileDataCallback( <span class="keyword">const</span> MapFrame&amp; mapf ) : <a class="code" href="_geographic_8cpp.html#a7d4f60c0596acd2cbc80900298a86953">_mapf</a>(mapf) { }
<a name="l00060"></a>00060 
<a name="l00061"></a>00061         <span class="keywordtype">void</span> operator()( osg::Node* node, osg::NodeVisitor* nv )
<a name="l00062"></a>00062         {
<a name="l00063"></a>00063             <span class="keywordflow">if</span> ( nv-&gt;getVisitorType() == osg::NodeVisitor::CULL_VISITOR )
<a name="l00064"></a>00064             {
<a name="l00065"></a>00065                 <span class="keywordflow">if</span> ( node-&gt;asGroup()-&gt;getNumChildren() &gt; 0 )
<a name="l00066"></a>00066                 {
<a name="l00067"></a>00067                     StreamingTile* tile = <span class="keyword">static_cast&lt;</span>StreamingTile*<span class="keyword">&gt;</span>( node-&gt;asGroup()-&gt;getChild(0) );
<a name="l00068"></a>00068                     tile-&gt;servicePendingImageRequests( <a class="code" href="_geographic_8cpp.html#a7d4f60c0596acd2cbc80900298a86953">_mapf</a>, nv-&gt;getFrameStamp()-&gt;getFrameNumber() );
<a name="l00069"></a>00069                 }
<a name="l00070"></a>00070             }
<a name="l00071"></a>00071             traverse( node, nv );
<a name="l00072"></a>00072         }
<a name="l00073"></a>00073 
<a name="l00074"></a>00074         <span class="keyword">const</span> MapFrame&amp; <a class="code" href="_geographic_8cpp.html#a7d4f60c0596acd2cbc80900298a86953">_mapf</a>;
<a name="l00075"></a>00075     };
<a name="l00076"></a>00076 }
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="comment">/*****************************************************************************/</span>
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 OSGTileFactory::OSGTileFactory(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> engineId,
<a name="l00081"></a>00081                                <span class="keyword">const</span> MapFrame&amp; cull_thread_mapf,
<a name="l00082"></a>00082                                <span class="keyword">const</span> OSGTerrainOptions&amp; props ) :
<a name="l00083"></a>00083 osg::Referenced( true ),
<a name="l00084"></a>00084 _engineId( engineId ),
<a name="l00085"></a>00085 _cull_thread_mapf( cull_thread_mapf ),
<a name="l00086"></a>00086 _terrainOptions( props )
<a name="l00087"></a>00087 {
<a name="l00088"></a>00088     LoadingPolicy::Mode mode = _terrainOptions.loadingPolicy()-&gt;mode().value();
<a name="l00089"></a>00089 }
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="keyword">const</span> OSGTerrainOptions&amp; 
<a name="l00092"></a>00092 OSGTileFactory::getTerrainOptions()<span class="keyword"> const</span>
<a name="l00093"></a>00093 <span class="keyword"></span>{
<a name="l00094"></a>00094     <span class="keywordflow">return</span> _terrainOptions;
<a name="l00095"></a>00095 }
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 std::string
<a name="l00098"></a>00098 OSGTileFactory::createURI( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span>, <span class="keyword">const</span> TileKey&amp; key )
<a name="l00099"></a>00099 {
<a name="l00100"></a>00100     std::stringstream ss;
<a name="l00101"></a>00101     ss &lt;&lt; key.str() &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt;<span class="keywordtype">id</span>&lt;&lt;<span class="stringliteral">&quot;.osgearth_osgterrain_tile&quot;</span>;
<a name="l00102"></a>00102     std::string ssStr;
<a name="l00103"></a>00103     ssStr = ss.str();
<a name="l00104"></a>00104     <span class="keywordflow">return</span> ssStr;
<a name="l00105"></a>00105 }
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="comment">// Make a MatrixTransform suitable for use with a Locator object based on the given extents.</span>
<a name="l00108"></a>00108 <span class="comment">// Calling Locator::setTransformAsExtents doesn&#39;t work with OSG 2.6 due to the fact that the</span>
<a name="l00109"></a>00109 <span class="comment">// _inverse member isn&#39;t updated properly.  Calling Locator::setTransform works correctly.</span>
<a name="l00110"></a>00110 osg::Matrixd
<a name="l00111"></a>00111 OSGTileFactory::getTransformFromExtents(<span class="keywordtype">double</span> minX, <span class="keywordtype">double</span> minY, <span class="keywordtype">double</span> maxX, <span class="keywordtype">double</span> maxY)<span class="keyword"> const</span>
<a name="l00112"></a>00112 <span class="keyword"></span>{
<a name="l00113"></a>00113     osg::Matrixd transform;
<a name="l00114"></a>00114     transform.set(
<a name="l00115"></a>00115         maxX-minX, 0.0,       0.0, 0.0,
<a name="l00116"></a>00116         0.0,       maxY-minY, 0.0, 0.0,
<a name="l00117"></a>00117         0.0,       0.0,       1.0, 0.0,
<a name="l00118"></a>00118         minX,      minY,      0.0, 1.0); 
<a name="l00119"></a>00119     <span class="keywordflow">return</span> transform;
<a name="l00120"></a>00120 }
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 osg::Node*
<a name="l00123"></a>00123 OSGTileFactory::createSubTiles( <span class="keyword">const</span> MapFrame&amp; mapf, Terrain* terrain, <span class="keyword">const</span> TileKey&amp; key, <span class="keywordtype">bool</span> populateLayers )
<a name="l00124"></a>00124 {
<a name="l00125"></a>00125     TileKey k0 = key.createChildKey(0);
<a name="l00126"></a>00126     TileKey k1 = key.createChildKey(1);
<a name="l00127"></a>00127     TileKey k2 = key.createChildKey(2);
<a name="l00128"></a>00128     TileKey k3 = key.createChildKey(3);
<a name="l00129"></a>00129 
<a name="l00130"></a>00130     <span class="keywordtype">bool</span> hasValidData = <span class="keyword">false</span>;
<a name="l00131"></a>00131     <span class="keywordtype">bool</span> validData;
<a name="l00132"></a>00132 
<a name="l00133"></a>00133     <span class="keywordtype">bool</span> fallback = <span class="keyword">false</span>;
<a name="l00134"></a>00134     osg::ref_ptr&lt;osg::Node&gt; q0 = createTile( mapf, terrain, k0, populateLayers, <span class="keyword">true</span>, fallback, validData);
<a name="l00135"></a>00135     <span class="keywordflow">if</span> (!hasValidData &amp;&amp; validData) hasValidData = <span class="keyword">true</span>;
<a name="l00136"></a>00136 
<a name="l00137"></a>00137     osg::ref_ptr&lt;osg::Node&gt; q1 = createTile( mapf, terrain, k1, populateLayers, <span class="keyword">true</span>, fallback, validData );
<a name="l00138"></a>00138     <span class="keywordflow">if</span> (!hasValidData &amp;&amp; validData) hasValidData = <span class="keyword">true</span>;
<a name="l00139"></a>00139 
<a name="l00140"></a>00140     osg::ref_ptr&lt;osg::Node&gt; q2 = createTile( mapf, terrain, k2, populateLayers, <span class="keyword">true</span>, fallback, validData );
<a name="l00141"></a>00141     <span class="keywordflow">if</span> (!hasValidData &amp;&amp; validData) hasValidData = <span class="keyword">true</span>;
<a name="l00142"></a>00142 
<a name="l00143"></a>00143     osg::ref_ptr&lt;osg::Node&gt; q3 = createTile( mapf, terrain, k3, populateLayers, <span class="keyword">true</span>, fallback, validData );
<a name="l00144"></a>00144     <span class="keywordflow">if</span> (!hasValidData &amp;&amp; validData) hasValidData = <span class="keyword">true</span>;
<a name="l00145"></a>00145 
<a name="l00146"></a>00146     <span class="keywordflow">if</span> (!hasValidData)
<a name="l00147"></a>00147     {
<a name="l00148"></a>00148         <a class="code" href="_h_t_t_p_client_8cpp.html#ac6600c2662696d8b43a4deb6877c8591">OE_DEBUG</a> &lt;&lt; <a class="code" href="_o_s_g_tile_factory_8cpp.html#aa499bb75bb504909cd0a72baf48c4653">LC</a> &lt;&lt; <span class="stringliteral">&quot;Couldn&#39;t create any quadrants for &quot;</span> &lt;&lt; key.str() &lt;&lt; <span class="stringliteral">&quot; time to stop subdividing!&quot;</span> &lt;&lt; std::endl;
<a name="l00149"></a>00149         <span class="keywordflow">return</span> NULL;
<a name="l00150"></a>00150     }
<a name="l00151"></a>00151 
<a name="l00152"></a>00152     osg::Group* tile_parent = <span class="keyword">new</span> osg::Group();
<a name="l00153"></a>00153 
<a name="l00154"></a>00154     fallback = <span class="keyword">true</span>;
<a name="l00155"></a>00155     <span class="comment">//Fallback on tiles if we couldn&#39;t create any</span>
<a name="l00156"></a>00156     <span class="keywordflow">if</span> (!q0.valid())
<a name="l00157"></a>00157     {
<a name="l00158"></a>00158         q0 = createTile( mapf, terrain, k0, populateLayers, <span class="keyword">true</span>, fallback, validData);
<a name="l00159"></a>00159     }
<a name="l00160"></a>00160 
<a name="l00161"></a>00161     <span class="keywordflow">if</span> (!q1.valid())
<a name="l00162"></a>00162     {
<a name="l00163"></a>00163         q1 = createTile( mapf, terrain, k1, populateLayers, <span class="keyword">true</span>, fallback, validData);
<a name="l00164"></a>00164     }
<a name="l00165"></a>00165 
<a name="l00166"></a>00166     <span class="keywordflow">if</span> (!q2.valid())
<a name="l00167"></a>00167     {
<a name="l00168"></a>00168         q2 = createTile( mapf, terrain, k2, populateLayers, <span class="keyword">true</span>, fallback, validData);
<a name="l00169"></a>00169     }
<a name="l00170"></a>00170 
<a name="l00171"></a>00171     <span class="keywordflow">if</span> (!q3.valid())
<a name="l00172"></a>00172     {        
<a name="l00173"></a>00173         q3 = createTile( mapf, terrain, k3, populateLayers, <span class="keyword">true</span>, fallback, validData);
<a name="l00174"></a>00174     }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176     tile_parent-&gt;addChild( q0.get() );
<a name="l00177"></a>00177     tile_parent-&gt;addChild( q1.get() );
<a name="l00178"></a>00178     tile_parent-&gt;addChild( q2.get() );
<a name="l00179"></a>00179     tile_parent-&gt;addChild( q3.get() );
<a name="l00180"></a>00180     <span class="keywordflow">return</span> tile_parent;
<a name="l00181"></a>00181 }
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 <span class="keywordtype">bool</span>
<a name="l00184"></a>00184 OSGTileFactory::createValidGeoImage(ImageLayer* layer,
<a name="l00185"></a>00185                                     <span class="keyword">const</span> TileKey&amp; key,
<a name="l00186"></a>00186                                     GeoImage&amp; out_image,
<a name="l00187"></a>00187                                     TileKey&amp;  out_actualTileKey,
<a name="l00188"></a>00188                                     ProgressCallback* progress)
<a name="l00189"></a>00189 {
<a name="l00190"></a>00190     <span class="comment">//TODO:  Redo this to just grab images from the parent TerrainTiles</span>
<a name="l00191"></a>00191     <span class="comment">//Try to create the image with the given key</span>
<a name="l00192"></a>00192     out_actualTileKey = key;
<a name="l00193"></a>00193 
<a name="l00194"></a>00194     <span class="keywordflow">while</span> (out_actualTileKey.valid())
<a name="l00195"></a>00195     {
<a name="l00196"></a>00196         <span class="keywordflow">if</span> ( layer-&gt;isKeyValid(out_actualTileKey) )
<a name="l00197"></a>00197         {
<a name="l00198"></a>00198             out_image = layer-&gt;createImage( out_actualTileKey, progress );
<a name="l00199"></a>00199             <span class="keywordflow">if</span> ( out_image.valid() )
<a name="l00200"></a>00200             {
<a name="l00201"></a>00201                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00202"></a>00202             }
<a name="l00203"></a>00203         }
<a name="l00204"></a>00204         out_actualTileKey = out_actualTileKey.createParentKey();
<a name="l00205"></a>00205     }
<a name="l00206"></a>00206     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00207"></a>00207 }
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="keywordtype">bool</span>
<a name="l00210"></a>00210 OSGTileFactory::hasMoreLevels( Map* map, <span class="keyword">const</span> TileKey&amp; key )
<a name="l00211"></a>00211 {
<a name="l00212"></a>00212     <span class="comment">//Threading::ScopedReadLock lock( map-&gt;getMapDataMutex() );</span>
<a name="l00213"></a>00213 
<a name="l00214"></a>00214     <span class="keywordtype">bool</span> more_levels = <span class="keyword">false</span>;
<a name="l00215"></a>00215 
<a name="l00216"></a>00216     ImageLayerVector imageLayers;
<a name="l00217"></a>00217     map-&gt;getImageLayers( imageLayers );
<a name="l00218"></a>00218 
<a name="l00219"></a>00219     <span class="keywordflow">for</span> ( ImageLayerVector::const_iterator i = imageLayers.begin(); i != imageLayers.end(); i++ )
<a name="l00220"></a>00220     {
<a name="l00221"></a>00221         <span class="keyword">const</span> ImageLayerOptions&amp; opt = i-&gt;get()-&gt;getImageLayerOptions();
<a name="l00222"></a>00222 
<a name="l00223"></a>00223         <span class="keywordflow">if</span> ( !opt.maxLevel().isSet() || key.getLevelOfDetail() &lt; (<span class="keywordtype">unsigned</span> int)*opt.maxLevel() )
<a name="l00224"></a>00224         {
<a name="l00225"></a>00225             more_levels = <span class="keyword">true</span>;
<a name="l00226"></a>00226             <span class="keywordflow">break</span>;
<a name="l00227"></a>00227         }
<a name="l00228"></a>00228     }
<a name="l00229"></a>00229     <span class="keywordflow">if</span> ( !more_levels )
<a name="l00230"></a>00230     {
<a name="l00231"></a>00231         ElevationLayerVector elevLayers;
<a name="l00232"></a>00232         map-&gt;getElevationLayers( elevLayers );
<a name="l00233"></a>00233 
<a name="l00234"></a>00234         <span class="keywordflow">for</span>( ElevationLayerVector::const_iterator j = elevLayers.begin(); j != elevLayers.end(); j++ )
<a name="l00235"></a>00235         {
<a name="l00236"></a>00236             <span class="keyword">const</span> ElevationLayerOptions&amp; opt = j-&gt;get()-&gt;getElevationLayerOptions();
<a name="l00237"></a>00237 
<a name="l00238"></a>00238             <span class="keywordflow">if</span> ( !opt.maxLevel().isSet() || key.getLevelOfDetail() &lt; (<span class="keywordtype">unsigned</span> int)*opt.maxLevel() )
<a name="l00239"></a>00239             <span class="comment">//if ( !j-&gt;get()-&gt;maxLevel().isSet() || key.getLevelOfDetail() &lt; j-&gt;get()-&gt;maxLevel().get() )</span>
<a name="l00240"></a>00240             {
<a name="l00241"></a>00241                 more_levels = <span class="keyword">true</span>;
<a name="l00242"></a>00242                 <span class="keywordflow">break</span>;
<a name="l00243"></a>00243             }
<a name="l00244"></a>00244         }
<a name="l00245"></a>00245     }
<a name="l00246"></a>00246 
<a name="l00247"></a>00247     <span class="keywordflow">return</span> more_levels;
<a name="l00248"></a>00248 }
<a name="l00249"></a>00249 
<a name="l00250"></a>00250 osg::HeightField*
<a name="l00251"></a>00251 OSGTileFactory::createEmptyHeightField( <span class="keyword">const</span> TileKey&amp; key, <span class="keywordtype">int</span> numCols, <span class="keywordtype">int</span> numRows )
<a name="l00252"></a>00252 {
<a name="l00253"></a>00253     osg::HeightField* hf = key.getProfile()-&gt;getVerticalSRS()-&gt;createReferenceHeightField(
<a name="l00254"></a>00254         key.getExtent(), numCols, numRows );
<a name="l00255"></a>00255 
<a name="l00256"></a>00256     <span class="keywordflow">return</span> hf;
<a name="l00257"></a>00257 }
<a name="l00258"></a>00258 
<a name="l00259"></a>00259 <span class="keywordtype">void</span>
<a name="l00260"></a>00260 OSGTileFactory::addPlaceholderImageLayers(Tile* tile, Tile* ancestorTile )
<a name="l00261"></a>00261 {
<a name="l00262"></a>00262     <span class="keywordflow">if</span> ( !ancestorTile )
<a name="l00263"></a>00263     {
<a name="l00264"></a>00264         <span class="comment">//OE_NOTICE &lt;&lt; &quot;No ancestorTile for key &quot; &lt;&lt; key.str() &lt;&lt; std::endl;</span>
<a name="l00265"></a>00265         <span class="keywordflow">return</span>;
<a name="l00266"></a>00266     }        
<a name="l00267"></a>00267 
<a name="l00268"></a>00268     <span class="comment">// Now if we have a valid ancestor tile, go through and make a temporary tile consisting only of</span>
<a name="l00269"></a>00269     <span class="comment">// layers that exist in the new map layer image list as well.</span>
<a name="l00270"></a>00270     <span class="comment">//int layer = 0;</span>
<a name="l00271"></a>00271     ColorLayersByUID colorLayers;
<a name="l00272"></a>00272     ancestorTile-&gt;getCustomColorLayers( colorLayers );
<a name="l00273"></a>00273     tile-&gt;setCustomColorLayers( colorLayers );
<a name="l00274"></a>00274 }
<a name="l00275"></a>00275 
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 <span class="keywordtype">void</span>
<a name="l00278"></a>00278 OSGTileFactory::addPlaceholderHeightfieldLayer(StreamingTile* tile,
<a name="l00279"></a>00279                                                StreamingTile* ancestorTile,
<a name="l00280"></a>00280                                                GeoLocator*    defaultLocator,
<a name="l00281"></a>00281                                                <span class="keyword">const</span> TileKey&amp; key,
<a name="l00282"></a>00282                                                <span class="keyword">const</span> TileKey&amp; ancestorKey)
<a name="l00283"></a>00283 {
<a name="l00284"></a>00284     osgTerrain::HeightFieldLayer* newHFLayer = 0L;
<a name="l00285"></a>00285 
<a name="l00286"></a>00286     <span class="keywordflow">if</span> ( ancestorTile &amp;&amp; ancestorKey.valid() )
<a name="l00287"></a>00287     {
<a name="l00288"></a>00288         osg::ref_ptr&lt;osgTerrain::HeightFieldLayer&gt; ancestorLayer;
<a name="l00289"></a>00289         {
<a name="l00290"></a>00290             Threading::ScopedReadLock sharedLock( ancestorTile-&gt;getTileLayersMutex() );
<a name="l00291"></a>00291             ancestorLayer = <span class="keyword">dynamic_cast&lt;</span>osgTerrain::HeightFieldLayer*<span class="keyword">&gt;</span>(ancestorTile-&gt;getElevationLayer());
<a name="l00292"></a>00292         }
<a name="l00293"></a>00293 
<a name="l00294"></a>00294         <span class="keywordflow">if</span> ( ancestorLayer.valid() )
<a name="l00295"></a>00295         {
<a name="l00296"></a>00296             osg::ref_ptr&lt;osg::HeightField&gt; ancestorHF = ancestorLayer-&gt;getHeightField();
<a name="l00297"></a>00297             <span class="keywordflow">if</span> ( ancestorHF.valid() )
<a name="l00298"></a>00298             {
<a name="l00299"></a>00299                 osg::HeightField* newHF = HeightFieldUtils::createSubSample(
<a name="l00300"></a>00300                     ancestorHF.get(),
<a name="l00301"></a>00301                     ancestorKey.getExtent(),
<a name="l00302"></a>00302                     key.getExtent());
<a name="l00303"></a>00303 
<a name="l00304"></a>00304                 newHFLayer = <span class="keyword">new</span> osgTerrain::HeightFieldLayer( newHF );
<a name="l00305"></a>00305                 newHFLayer-&gt;setLocator( defaultLocator );
<a name="l00306"></a>00306 
<a name="l00307"></a>00307                 <span class="comment">// lock to set the elevation layerdata:</span>
<a name="l00308"></a>00308                 {
<a name="l00309"></a>00309                     Threading::ScopedWriteLock exclusiveLock( tile-&gt;getTileLayersMutex() );
<a name="l00310"></a>00310                     tile-&gt;setElevationLayer( newHFLayer );                
<a name="l00311"></a>00311                     tile-&gt;setElevationLOD( ancestorTile-&gt;getElevationLOD() );
<a name="l00312"></a>00312                 }
<a name="l00313"></a>00313             }
<a name="l00314"></a>00314         }
<a name="l00315"></a>00315     }
<a name="l00316"></a>00316 
<a name="l00317"></a>00317     <span class="comment">// lock the tile to write the elevation data.</span>
<a name="l00318"></a>00318     {
<a name="l00319"></a>00319         Threading::ScopedWriteLock exclusiveLock( tile-&gt;getTileLayersMutex() );
<a name="l00320"></a>00320 
<a name="l00321"></a>00321         <span class="keywordflow">if</span> ( !newHFLayer )
<a name="l00322"></a>00322         {
<a name="l00323"></a>00323             newHFLayer = <span class="keyword">new</span> osgTerrain::HeightFieldLayer();
<a name="l00324"></a>00324             newHFLayer-&gt;setHeightField( createEmptyHeightField( key, 8, 8 ) );
<a name="l00325"></a>00325             newHFLayer-&gt;setLocator( defaultLocator );
<a name="l00326"></a>00326             tile-&gt;setElevationLOD( -1 );
<a name="l00327"></a>00327         }
<a name="l00328"></a>00328 
<a name="l00329"></a>00329         <span class="keywordflow">if</span> ( newHFLayer )
<a name="l00330"></a>00330         {
<a name="l00331"></a>00331             tile-&gt;setElevationLayer( newHFLayer );
<a name="l00332"></a>00332         }
<a name="l00333"></a>00333     }
<a name="l00334"></a>00334 }
<a name="l00335"></a>00335 
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 osgTerrain::HeightFieldLayer*
<a name="l00338"></a>00338 OSGTileFactory::createPlaceholderHeightfieldLayer(osg::HeightField* ancestorHF,
<a name="l00339"></a>00339                                                   <span class="keyword">const</span> TileKey&amp;    ancestorKey,
<a name="l00340"></a>00340                                                   <span class="keyword">const</span> TileKey&amp;    key,
<a name="l00341"></a>00341                                                   GeoLocator*       keyLocator )
<a name="l00342"></a>00342 {
<a name="l00343"></a>00343     osgTerrain::HeightFieldLayer* hfLayer = NULL;
<a name="l00344"></a>00344 
<a name="l00345"></a>00345     osg::HeightField* newHF = HeightFieldUtils::createSubSample(
<a name="l00346"></a>00346         ancestorHF,
<a name="l00347"></a>00347         ancestorKey.getExtent(),
<a name="l00348"></a>00348         key.getExtent() );
<a name="l00349"></a>00349 
<a name="l00350"></a>00350     newHF-&gt;setSkirtHeight( ancestorHF-&gt;getSkirtHeight() / 2.0 );
<a name="l00351"></a>00351 
<a name="l00352"></a>00352     hfLayer = <span class="keyword">new</span> osgTerrain::HeightFieldLayer( newHF );
<a name="l00353"></a>00353     hfLayer-&gt;setLocator( keyLocator );
<a name="l00354"></a>00354 
<a name="l00355"></a>00355     <span class="keywordflow">return</span> hfLayer;
<a name="l00356"></a>00356 }
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 osg::Node*
<a name="l00359"></a>00359 OSGTileFactory::createTile(<span class="keyword">const</span> MapFrame&amp;  mapf, 
<a name="l00360"></a>00360                            Terrain*         terrain, 
<a name="l00361"></a>00361                            <span class="keyword">const</span> TileKey&amp;   key, 
<a name="l00362"></a>00362                            <span class="keywordtype">bool</span>             populateLayers, 
<a name="l00363"></a>00363                            <span class="keywordtype">bool</span>             wrapInPagedLOD, 
<a name="l00364"></a>00364                            <span class="keywordtype">bool</span>             fallback,
<a name="l00365"></a>00365                            <span class="keywordtype">bool</span>&amp;            out_validData )
<a name="l00366"></a>00366 {
<a name="l00367"></a>00367     <span class="keywordflow">if</span> ( populateLayers )
<a name="l00368"></a>00368     {        
<a name="l00369"></a>00369         <span class="keywordflow">return</span> createPopulatedTile( mapf, terrain, key, wrapInPagedLOD, fallback, out_validData);
<a name="l00370"></a>00370     }
<a name="l00371"></a>00371     <span class="keywordflow">else</span>
<a name="l00372"></a>00372     {
<a name="l00373"></a>00373         <span class="comment">//Placeholders always contain valid data</span>
<a name="l00374"></a>00374         out_validData = <span class="keyword">true</span>;
<a name="l00375"></a>00375 
<a name="l00376"></a>00376         <span class="keywordflow">return</span> createPlaceholderTile(
<a name="l00377"></a>00377             mapf, 
<a name="l00378"></a>00378             static_cast&lt;StreamingTerrain*&gt;(terrain),
<a name="l00379"></a>00379             key );
<a name="l00380"></a>00380     }
<a name="l00381"></a>00381 }
<a name="l00382"></a>00382 
<a name="l00383"></a>00383 
<a name="l00384"></a>00384 
<a name="l00385"></a>00385 osg::Node*
<a name="l00386"></a>00386 OSGTileFactory::createPlaceholderTile(<span class="keyword">const</span> MapFrame&amp;   mapf,
<a name="l00387"></a>00387                                       StreamingTerrain* terrain,
<a name="l00388"></a>00388                                       <span class="keyword">const</span> TileKey&amp;    key )
<a name="l00389"></a>00389 {
<a name="l00390"></a>00390     <span class="comment">// Start out by finding the nearest registered ancestor tile, since the placeholder is</span>
<a name="l00391"></a>00391     <span class="comment">// going to be based on inherited data. Note- the ancestor may not be the immediate</span>
<a name="l00392"></a>00392     <span class="comment">// parent, b/c the parent may or may not be in the scene graph.</span>
<a name="l00393"></a>00393     TileKey ancestorKey = key.createParentKey();
<a name="l00394"></a>00394     osg::ref_ptr&lt;StreamingTile&gt; ancestorTile;
<a name="l00395"></a>00395     <span class="keywordflow">while</span>( !ancestorTile.valid() &amp;&amp; ancestorKey.valid() )
<a name="l00396"></a>00396     {
<a name="l00397"></a>00397         terrain-&gt;getTile( ancestorKey.getTileId(), ancestorTile );
<a name="l00398"></a>00398         <span class="keywordflow">if</span> ( !ancestorTile.valid() )
<a name="l00399"></a>00399             ancestorKey = ancestorKey.createParentKey();
<a name="l00400"></a>00400     }
<a name="l00401"></a>00401     <span class="keywordflow">if</span> ( !ancestorTile.valid() )
<a name="l00402"></a>00402     {
<a name="l00403"></a>00403         OE_WARN &lt;&lt; <a class="code" href="_o_s_g_tile_factory_8cpp.html#aa499bb75bb504909cd0a72baf48c4653">LC</a> &lt;&lt; <span class="stringliteral">&quot;cannot find ancestor tile for (&quot;</span> &lt;&lt; key.str() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt;std::endl;
<a name="l00404"></a>00404         <span class="keywordflow">return</span> 0L;
<a name="l00405"></a>00405     }
<a name="l00406"></a>00406 
<a name="l00407"></a>00407     <a class="code" href="_h_t_t_p_client_8cpp.html#ac6600c2662696d8b43a4deb6877c8591">OE_DEBUG</a> &lt;&lt; <a class="code" href="_o_s_g_tile_factory_8cpp.html#aa499bb75bb504909cd0a72baf48c4653">LC</a> &lt;&lt; <span class="stringliteral">&quot;Creating placeholder for &quot;</span> &lt;&lt; key.str() &lt;&lt; std::endl;
<a name="l00408"></a>00408 
<a name="l00409"></a>00409     <span class="keyword">const</span> MapInfo&amp; mapInfo = mapf.getMapInfo();
<a name="l00410"></a>00410 
<a name="l00411"></a>00411     <span class="keywordtype">bool</span> hasElevation = mapf.elevationLayers().size() &gt; 0;
<a name="l00412"></a>00412 
<a name="l00413"></a>00413     <span class="comment">// Build a &quot;placeholder&quot; tile.</span>
<a name="l00414"></a>00414     <span class="keywordtype">double</span> xmin, ymin, xmax, ymax;
<a name="l00415"></a>00415     key.getExtent().getBounds( xmin, ymin, xmax, ymax );
<a name="l00416"></a>00416 
<a name="l00417"></a>00417     <span class="comment">// A locator will place the tile on the globe:</span>
<a name="l00418"></a>00418     osg::ref_ptr&lt;GeoLocator&gt; locator = GeoLocator::createForKey( key, mapInfo );
<a name="l00419"></a>00419 
<a name="l00420"></a>00420     <span class="comment">// The empty tile:</span>
<a name="l00421"></a>00421     StreamingTile* tile = <span class="keyword">new</span> StreamingTile( key, locator.get(), terrain-&gt;getQuickReleaseGLObjects() );
<a name="l00422"></a>00422     tile-&gt;setTerrainTechnique( terrain-&gt;cloneTechnique() );
<a name="l00423"></a>00423     tile-&gt;setVerticalScale( _terrainOptions.verticalScale().value() );
<a name="l00424"></a>00424     tile-&gt;setDataVariance( osg::Object::DYNAMIC );
<a name="l00425"></a>00425     <span class="comment">//tile-&gt;setLocator( locator.get() );</span>
<a name="l00426"></a>00426 
<a name="l00427"></a>00427     <span class="comment">// Attach an updatecallback to normalize the edges of TerrainTiles.</span>
<a name="l00428"></a>00428 <span class="preprocessor">#if 0</span>
<a name="l00429"></a>00429 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ( hasElevation &amp;&amp; _terrainOptions.normalizeEdges().get() )
<a name="l00430"></a>00430     {
<a name="l00431"></a>00431         tile-&gt;setUpdateCallback(<span class="keyword">new</span> TerrainTileEdgeNormalizerUpdateCallback());
<a name="l00432"></a>00432         tile-&gt;setDataVariance(osg::Object::DYNAMIC);
<a name="l00433"></a>00433     }
<a name="l00434"></a>00434 <span class="preprocessor">#endif</span>
<a name="l00435"></a>00435 <span class="preprocessor"></span>
<a name="l00436"></a>00436     <span class="comment">// Generate placeholder imagery and elevation layers. These &quot;inherit&quot; data from an</span>
<a name="l00437"></a>00437     <span class="comment">// ancestor tile.</span>
<a name="l00438"></a>00438     {
<a name="l00439"></a>00439         <span class="comment">//Threading::ScopedReadLock parentLock( ancestorTile-&gt;getTileLayersMutex() );</span>
<a name="l00440"></a>00440         addPlaceholderImageLayers     ( tile, ancestorTile.get() );
<a name="l00441"></a>00441         addPlaceholderHeightfieldLayer( tile, ancestorTile.get(), locator.get(), key, ancestorKey );
<a name="l00442"></a>00442     }
<a name="l00443"></a>00443 
<a name="l00444"></a>00444     <span class="comment">// calculate the switching distances:</span>
<a name="l00445"></a>00445     osg::BoundingSphere bs = tile-&gt;getBound();
<a name="l00446"></a>00446     <span class="keywordtype">double</span> max_range = 1e10;
<a name="l00447"></a>00447     <span class="keywordtype">double</span> radius = bs.radius();
<a name="l00448"></a>00448     <span class="keywordtype">double</span> min_range = radius * _terrainOptions.minTileRangeFactor().get();
<a name="l00449"></a>00449 
<a name="l00450"></a>00450     <span class="comment">// Set the skirt height of the heightfield</span>
<a name="l00451"></a>00451     osgTerrain::HeightFieldLayer* hfLayer = <span class="keyword">static_cast&lt;</span>osgTerrain::HeightFieldLayer*<span class="keyword">&gt;</span>(tile-&gt;getElevationLayer());
<a name="l00452"></a>00452     <span class="keywordflow">if</span> (!hfLayer)
<a name="l00453"></a>00453     {
<a name="l00454"></a>00454         OE_WARN &lt;&lt; <a class="code" href="_o_s_g_tile_factory_8cpp.html#aa499bb75bb504909cd0a72baf48c4653">LC</a> &lt;&lt; <span class="stringliteral">&quot;Warning: Couldn&#39;t get hfLayer for &quot;</span> &lt;&lt; key.str() &lt;&lt; std::endl;
<a name="l00455"></a>00455     }
<a name="l00456"></a>00456     hfLayer-&gt;getHeightField()-&gt;setSkirtHeight(radius * _terrainOptions.heightFieldSkirtRatio().get() );
<a name="l00457"></a>00457 
<a name="l00458"></a>00458     <span class="comment">// In a Plate Carre tesselation, scale the heightfield elevations from meters to degrees</span>
<a name="l00459"></a>00459     <span class="keywordflow">if</span> ( mapInfo.isPlateCarre() &amp;&amp; hfLayer-&gt;getHeightField() )
<a name="l00460"></a>00460         HeightFieldUtils::scaleHeightFieldToDegrees( hfLayer-&gt;getHeightField() );
<a name="l00461"></a>00461 
<a name="l00462"></a>00462     <span class="keywordtype">bool</span> markTileLoaded = <span class="keyword">false</span>;
<a name="l00463"></a>00463 
<a name="l00464"></a>00464     <span class="keywordflow">if</span> ( _terrainOptions.loadingPolicy()-&gt;mode().get() != LoadingPolicy::MODE_STANDARD )
<a name="l00465"></a>00465     {
<a name="l00466"></a>00466         markTileLoaded = <span class="keyword">true</span>;
<a name="l00467"></a>00467         tile-&gt;setHasElevationHint( hasElevation );
<a name="l00468"></a>00468     }
<a name="l00469"></a>00469 
<a name="l00470"></a>00470     <span class="comment">// install a tile switcher:</span>
<a name="l00471"></a>00471     tile-&gt;attachToTerrain( terrain );
<a name="l00472"></a>00472     <span class="comment">//tile-&gt;setTerrain( terrain );</span>
<a name="l00473"></a>00473     <span class="comment">//terrain-&gt;registerTile( tile );</span>
<a name="l00474"></a>00474 
<a name="l00475"></a>00475     osg::Node* result = 0L;
<a name="l00476"></a>00476 
<a name="l00477"></a>00477     <span class="comment">// create a PLOD so we can keep subdividing:</span>
<a name="l00478"></a>00478     osg::PagedLOD* plod = <span class="keyword">new</span> osg::PagedLOD();
<a name="l00479"></a>00479     plod-&gt;setCenter( bs.center() );
<a name="l00480"></a>00480     plod-&gt;addChild( tile, min_range, max_range );
<a name="l00481"></a>00481 
<a name="l00482"></a>00482     <span class="keywordflow">if</span> ( key.getLevelOfDetail() &lt; (<span class="keywordtype">unsigned</span> int)getTerrainOptions().maxLOD().get() )
<a name="l00483"></a>00483     {
<a name="l00484"></a>00484         plod-&gt;setFileName( 1, createURI( _engineId, key ) ); <span class="comment">//map-&gt;getId(), key ) );</span>
<a name="l00485"></a>00485         plod-&gt;setRange( 1, 0.0, min_range );
<a name="l00486"></a>00486     }
<a name="l00487"></a>00487     <span class="keywordflow">else</span>
<a name="l00488"></a>00488     {
<a name="l00489"></a>00489         plod-&gt;setRange( 0, 0, FLT_MAX );
<a name="l00490"></a>00490     }
<a name="l00491"></a>00491 
<a name="l00492"></a>00492 <span class="preprocessor">#if 0 //USE_FILELOCATIONCALLBACK</span>
<a name="l00493"></a>00493 <span class="preprocessor"></span>    osgDB::Options* options = <span class="keyword">new</span> osgDB::Options;
<a name="l00494"></a>00494     options-&gt;setFileLocationCallback( <span class="keyword">new</span> FileLocationCallback);
<a name="l00495"></a>00495     plod-&gt;setDatabaseOptions( options );
<a name="l00496"></a>00496 <span class="preprocessor">#endif</span>
<a name="l00497"></a>00497 <span class="preprocessor"></span>
<a name="l00498"></a>00498     result = plod;
<a name="l00499"></a>00499 
<a name="l00500"></a>00500     <span class="comment">// Install a callback that will load the actual tile data via the pager.</span>
<a name="l00501"></a>00501     result-&gt;addCullCallback( <span class="keyword">new</span> PopulateStreamingTileDataCallback( _cull_thread_mapf ) );
<a name="l00502"></a>00502 
<a name="l00503"></a>00503     <span class="comment">// Install a cluster culler (FIXME for cube mode)</span>
<a name="l00504"></a>00504     <span class="comment">//bool isCube = map-&gt;getMapOptions().coordSysType() == MapOptions::CSTYPE_GEOCENTRIC_CUBE;</span>
<a name="l00505"></a>00505     <span class="keywordflow">if</span> ( mapInfo.isGeocentric() &amp;&amp; !mapInfo.isCube() )
<a name="l00506"></a>00506     {
<a name="l00507"></a>00507         osg::ClusterCullingCallback* ccc = createClusterCullingCallback( tile, locator-&gt;getEllipsoidModel() );
<a name="l00508"></a>00508         result-&gt;addCullCallback( ccc );
<a name="l00509"></a>00509     }     
<a name="l00510"></a>00510 
<a name="l00511"></a>00511     <span class="keywordflow">return</span> result;
<a name="l00512"></a>00512 }
<a name="l00513"></a>00513 
<a name="l00514"></a>00514 <span class="keyword">namespace</span>
<a name="l00515"></a>00515 {
<a name="l00516"></a>00516     <span class="keyword">struct </span>GeoImageData
<a name="l00517"></a>00517     {
<a name="l00518"></a>00518         GeoImageData() : _layerUID(-1) , _imageTileKey(0,0,0,0L) { }
<a name="l00519"></a>00519         GeoImage _image;
<a name="l00520"></a>00520         UID      _layerUID;
<a name="l00521"></a>00521         TileKey  _imageTileKey;
<a name="l00522"></a>00522     };
<a name="l00523"></a>00523 }
<a name="l00524"></a>00524 
<a name="l00525"></a>00525 
<a name="l00526"></a>00526 osg::Node*
<a name="l00527"></a>00527 OSGTileFactory::createPopulatedTile(<span class="keyword">const</span> MapFrame&amp;  mapf, 
<a name="l00528"></a>00528                                     Terrain*         terrain, 
<a name="l00529"></a>00529                                     <span class="keyword">const</span> TileKey&amp;   key, 
<a name="l00530"></a>00530                                     <span class="keywordtype">bool</span>             wrapInPagedLOD, 
<a name="l00531"></a>00531                                     <span class="keywordtype">bool</span>             fallback, 
<a name="l00532"></a>00532                                     <span class="keywordtype">bool</span>&amp;            validData )
<a name="l00533"></a>00533 {
<a name="l00534"></a>00534     <span class="keyword">const</span> MapInfo&amp; mapInfo = mapf.getMapInfo();
<a name="l00535"></a>00535     <span class="keywordtype">bool</span> isPlateCarre = !mapInfo.isGeocentric() &amp;&amp; mapInfo.isGeographicSRS();
<a name="l00536"></a>00536 
<a name="l00537"></a>00537     <span class="keyword">typedef</span> std::vector&lt;GeoImageData&gt; GeoImageDataVector;
<a name="l00538"></a>00538     GeoImageDataVector image_tiles;
<a name="l00539"></a>00539 
<a name="l00540"></a>00540     <span class="comment">// Collect the image layers</span>
<a name="l00541"></a>00541     <span class="keywordtype">bool</span> empty_map = mapf.imageLayers().size() == 0 &amp;&amp; mapf.elevationLayers().size() == 0;
<a name="l00542"></a>00542 
<a name="l00543"></a>00543     <span class="comment">// Create the images for the tile</span>
<a name="l00544"></a>00544     <span class="keywordflow">for</span>( ImageLayerVector::const_iterator i = mapf.imageLayers().begin(); i != mapf.imageLayers().end(); ++i )
<a name="l00545"></a>00545     {
<a name="l00546"></a>00546         ImageLayer* layer = i-&gt;get();
<a name="l00547"></a>00547         GeoImageData imageData;
<a name="l00548"></a>00548 
<a name="l00549"></a>00549         <span class="comment">// Only try to create images if the key is valid</span>
<a name="l00550"></a>00550         <span class="keywordflow">if</span> ( layer-&gt;isKeyValid( key ) )
<a name="l00551"></a>00551         {
<a name="l00552"></a>00552             imageData._image = layer-&gt;createImage( key );
<a name="l00553"></a>00553             imageData._layerUID = layer-&gt;getUID();
<a name="l00554"></a>00554             imageData._imageTileKey = key;
<a name="l00555"></a>00555         }
<a name="l00556"></a>00556 
<a name="l00557"></a>00557         <span class="comment">// always push images, even it they are empty, so that the image_tiles vector is one-to-one</span>
<a name="l00558"></a>00558         <span class="comment">// with the imageLayers() vector.</span>
<a name="l00559"></a>00559         image_tiles.push_back( imageData );
<a name="l00560"></a>00560     }
<a name="l00561"></a>00561 
<a name="l00562"></a>00562     <span class="keywordtype">bool</span> hasElevation = <span class="keyword">false</span>;
<a name="l00563"></a>00563 
<a name="l00564"></a>00564     <span class="comment">//Create the heightfield for the tile</span>
<a name="l00565"></a>00565     osg::ref_ptr&lt;osg::HeightField&gt; hf;
<a name="l00566"></a>00566     <span class="keywordflow">if</span> ( mapf.elevationLayers().size() &gt; 0 )
<a name="l00567"></a>00567     {
<a name="l00568"></a>00568         mapf.getHeightField( key, <span class="keyword">false</span>, hf, 0L, _terrainOptions.elevationInterpolation().value());     
<a name="l00569"></a>00569     }
<a name="l00570"></a>00570 
<a name="l00571"></a>00571     <span class="comment">//If we are on the first LOD and we couldn&#39;t get a heightfield tile, just create an empty one.  Otherwise you can run into the situation</span>
<a name="l00572"></a>00572     <span class="comment">//where you could have an inset heightfield on one hemisphere and the whole other hemisphere won&#39;t show up.</span>
<a name="l00573"></a>00573     <span class="keywordflow">if</span> ( mapInfo.isGeocentric() &amp;&amp; key.getLevelOfDetail() &lt;= 1 &amp;&amp; !hf.valid())
<a name="l00574"></a>00574     {
<a name="l00575"></a>00575         hf = createEmptyHeightField( key );
<a name="l00576"></a>00576     }
<a name="l00577"></a>00577     hasElevation = hf.valid();
<a name="l00578"></a>00578 
<a name="l00579"></a>00579     <span class="comment">//Determine if we&#39;ve created any images</span>
<a name="l00580"></a>00580     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numValidImages = 0;
<a name="l00581"></a>00581     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; image_tiles.size(); ++i)
<a name="l00582"></a>00582     {
<a name="l00583"></a>00583         <span class="keywordflow">if</span> (image_tiles[i]._image.valid()) numValidImages++;
<a name="l00584"></a>00584     }
<a name="l00585"></a>00585 
<a name="l00586"></a>00586 
<a name="l00587"></a>00587     <span class="comment">//If we couldn&#39;t create any imagery or heightfields, bail out</span>
<a name="l00588"></a>00588     <span class="keywordflow">if</span> (!hf.valid() &amp;&amp; (numValidImages == 0) &amp;&amp; !empty_map)
<a name="l00589"></a>00589     {
<a name="l00590"></a>00590         <a class="code" href="_h_t_t_p_client_8cpp.html#ac6600c2662696d8b43a4deb6877c8591">OE_DEBUG</a> &lt;&lt; <a class="code" href="_o_s_g_tile_factory_8cpp.html#aa499bb75bb504909cd0a72baf48c4653">LC</a> &lt;&lt; <span class="stringliteral">&quot;Could not create any imagery or heightfields for &quot;</span> &lt;&lt; key.str() &lt;&lt;<span class="stringliteral">&quot;.  Not building tile&quot;</span> &lt;&lt; std::endl;
<a name="l00591"></a>00591         validData = <span class="keyword">false</span>;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593         <span class="comment">//If we&#39;re not asked to fallback on previous LOD&#39;s and we have no data, return NULL</span>
<a name="l00594"></a>00594         <span class="keywordflow">if</span> (!fallback)
<a name="l00595"></a>00595         {
<a name="l00596"></a>00596             <span class="keywordflow">return</span> NULL;
<a name="l00597"></a>00597         }
<a name="l00598"></a>00598     }
<a name="l00599"></a>00599     <span class="keywordflow">else</span>
<a name="l00600"></a>00600     {
<a name="l00601"></a>00601         validData = <span class="keyword">true</span>;
<a name="l00602"></a>00602     }
<a name="l00603"></a>00603 
<a name="l00604"></a>00604     <span class="comment">//Try to interpolate any missing image layers from parent tiles</span>
<a name="l00605"></a>00605     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; mapf.imageLayers().size(); i++ )
<a name="l00606"></a>00606     {
<a name="l00607"></a>00607         <span class="keywordflow">if</span> (!image_tiles[i]._image.valid())
<a name="l00608"></a>00608         {
<a name="l00609"></a>00609             <span class="keywordflow">if</span> (mapf.getImageLayerAt(i)-&gt;isKeyValid(key))
<a name="l00610"></a>00610             {
<a name="l00611"></a>00611                 <span class="comment">//If the key was valid and we have no image, then something possibly went wrong with the image creation such as a server being busy.</span>
<a name="l00612"></a>00612                 createValidGeoImage(mapf.getImageLayerAt(i), key, image_tiles[i]._image, image_tiles[i]._imageTileKey);
<a name="l00613"></a>00613             }
<a name="l00614"></a>00614 
<a name="l00615"></a>00615             <span class="comment">//If we still couldn&#39;t create an image, either something is really wrong or the key wasn&#39;t valid, so just create a transparent placeholder image</span>
<a name="l00616"></a>00616             <span class="keywordflow">if</span> (!image_tiles[i]._image.valid())
<a name="l00617"></a>00617             {
<a name="l00618"></a>00618                 <span class="comment">//If the image is not valid, create an empty texture as a placeholder</span>
<a name="l00619"></a>00619                 image_tiles[i]._image = GeoImage(ImageUtils::createEmptyImage(), key.getExtent());
<a name="l00620"></a>00620                 image_tiles[i]._imageTileKey = key;
<a name="l00621"></a>00621             }
<a name="l00622"></a>00622         }
<a name="l00623"></a>00623     }
<a name="l00624"></a>00624 
<a name="l00625"></a>00625     <span class="comment">//Fill in missing heightfield information from parent tiles</span>
<a name="l00626"></a>00626     <span class="keywordflow">if</span> (!hf.valid())
<a name="l00627"></a>00627     {
<a name="l00628"></a>00628         <span class="comment">//We have no heightfield sources, </span>
<a name="l00629"></a>00629         <span class="keywordflow">if</span> ( mapf.elevationLayers().size() == 0 )
<a name="l00630"></a>00630         {
<a name="l00631"></a>00631             hf = createEmptyHeightField( key );
<a name="l00632"></a>00632         }
<a name="l00633"></a>00633         <span class="keywordflow">else</span>
<a name="l00634"></a>00634         {
<a name="l00635"></a>00635             <span class="comment">//Try to get a heightfield again, but this time fallback on parent tiles</span>
<a name="l00636"></a>00636             <span class="keywordflow">if</span> ( mapf.getHeightField( key, <span class="keyword">true</span>, hf, 0L, _terrainOptions.elevationInterpolation().value() ) )
<a name="l00637"></a>00637             {
<a name="l00638"></a>00638                 hasElevation = <span class="keyword">true</span>;
<a name="l00639"></a>00639             }
<a name="l00640"></a>00640             <span class="keywordflow">else</span>
<a name="l00641"></a>00641             {
<a name="l00642"></a>00642                 <span class="comment">//We couldn&#39;t get any heightfield, so just create an empty one.</span>
<a name="l00643"></a>00643                 hf = createEmptyHeightField( key );
<a name="l00644"></a>00644             }
<a name="l00645"></a>00645         }
<a name="l00646"></a>00646     }
<a name="l00647"></a>00647 
<a name="l00648"></a>00648 
<a name="l00649"></a>00649     <span class="comment">// In a Plate Carre tesselation, scale the heightfield elevations from meters to degrees</span>
<a name="l00650"></a>00650     <span class="keywordflow">if</span> ( isPlateCarre )
<a name="l00651"></a>00651     {
<a name="l00652"></a>00652         HeightFieldUtils::scaleHeightFieldToDegrees( hf.get() );
<a name="l00653"></a>00653     }
<a name="l00654"></a>00654 
<a name="l00655"></a>00655     osg::ref_ptr&lt;GeoLocator&gt; locator = GeoLocator::createForKey( key, mapInfo );
<a name="l00656"></a>00656     osgTerrain::HeightFieldLayer* hf_layer = <span class="keyword">new</span> osgTerrain::HeightFieldLayer();
<a name="l00657"></a>00657     hf_layer-&gt;setLocator( locator.get() );
<a name="l00658"></a>00658     hf_layer-&gt;setHeightField( hf.get() );
<a name="l00659"></a>00659 
<a name="l00660"></a>00660     <span class="keywordtype">bool</span> isStreaming = 
<a name="l00661"></a>00661         _terrainOptions.loadingPolicy()-&gt;mode() == LoadingPolicy::MODE_SEQUENTIAL ||
<a name="l00662"></a>00662         _terrainOptions.loadingPolicy()-&gt;mode() == LoadingPolicy::MODE_PREEMPTIVE;
<a name="l00663"></a>00663 
<a name="l00664"></a>00664     Tile* tile = terrain-&gt;createTile( key, locator.get() );
<a name="l00665"></a>00665     tile-&gt;setTerrainTechnique( terrain-&gt;cloneTechnique() );
<a name="l00666"></a>00666     tile-&gt;setVerticalScale( _terrainOptions.verticalScale().value() );
<a name="l00667"></a>00667     <span class="comment">//tile-&gt;setLocator( locator.get() );</span>
<a name="l00668"></a>00668     tile-&gt;setElevationLayer( hf_layer );
<a name="l00669"></a>00669     <span class="comment">//tile-&gt;setRequiresNormals( true );</span>
<a name="l00670"></a>00670     tile-&gt;setDataVariance(osg::Object::DYNAMIC);
<a name="l00671"></a>00671 
<a name="l00672"></a>00672 <span class="preprocessor">#if 0</span>
<a name="l00673"></a>00673 <span class="preprocessor"></span>    <span class="comment">//Attach an updatecallback to normalize the edges of TerrainTiles.</span>
<a name="l00674"></a>00674     <span class="keywordflow">if</span> (hasElevation &amp;&amp; _terrainOptions.normalizeEdges().get() )
<a name="l00675"></a>00675     {
<a name="l00676"></a>00676         tile-&gt;setUpdateCallback(<span class="keyword">new</span> TerrainTileEdgeNormalizerUpdateCallback());
<a name="l00677"></a>00677         tile-&gt;setDataVariance(osg::Object::DYNAMIC);
<a name="l00678"></a>00678     }
<a name="l00679"></a>00679 <span class="preprocessor">#endif</span>
<a name="l00680"></a>00680 <span class="preprocessor"></span>
<a name="l00681"></a>00681     <span class="comment">//Assign the terrain system to the TerrainTile.</span>
<a name="l00682"></a>00682     <span class="comment">//It is very important the terrain system is set while the MapConfig&#39;s sourceMutex is locked.</span>
<a name="l00683"></a>00683     <span class="comment">//This registers the terrain tile so that adding/removing layers are always in sync.  If you don&#39;t do this</span>
<a name="l00684"></a>00684     <span class="comment">//you can end up with a situation where the database pager is waiting to merge a tile, then a layer is added, then</span>
<a name="l00685"></a>00685     <span class="comment">//the tile is finally merged and is out of sync.</span>
<a name="l00686"></a>00686 
<a name="l00687"></a>00687     <span class="keywordtype">double</span> min_units_per_pixel = DBL_MAX;
<a name="l00688"></a>00688 
<a name="l00689"></a>00689 <span class="preprocessor">#if 0</span>
<a name="l00690"></a>00690 <span class="preprocessor"></span>    <span class="comment">// create contour layer:</span>
<a name="l00691"></a>00691     <span class="keywordflow">if</span> (map-&gt;getContourTransferFunction() != NULL)
<a name="l00692"></a>00692     {
<a name="l00693"></a>00693         osgTerrain::ContourLayer* contourLayer(<span class="keyword">new</span> osgTerrain::ContourLayer(map-&gt;getContourTransferFunction()));
<a name="l00694"></a>00694 
<a name="l00695"></a>00695         contourLayer-&gt;setMagFilter(_terrainOptions.getContourMagFilter().value());
<a name="l00696"></a>00696         contourLayer-&gt;setMinFilter(_terrainOptions.getContourMinFilter().value());
<a name="l00697"></a>00697         tile-&gt;setCustomColorLayer(layer,contourLayer); <span class="comment">//TODO: need layerUID, not layer index here -GW</span>
<a name="l00698"></a>00698         ++layer;
<a name="l00699"></a>00699     }
<a name="l00700"></a>00700 <span class="preprocessor">#endif</span>
<a name="l00701"></a>00701 <span class="preprocessor"></span>
<a name="l00702"></a>00702     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; image_tiles.size(); ++i)
<a name="l00703"></a>00703     {
<a name="l00704"></a>00704         <span class="keywordflow">if</span> (image_tiles[i]._image.valid())
<a name="l00705"></a>00705         {
<a name="l00706"></a>00706             <span class="keyword">const</span> GeoImage&amp; geo_image = image_tiles[i]._image;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708             <span class="keywordtype">double</span> img_xmin, img_ymin, img_xmax, img_ymax;
<a name="l00709"></a>00709             geo_image.getExtent().getBounds( img_xmin, img_ymin, img_xmax, img_ymax );
<a name="l00710"></a>00710 
<a name="l00711"></a>00711             <span class="comment">//Specify a new locator for the color with the coordinates of the TileKey that was actually used to create the image</span>
<a name="l00712"></a>00712             osg::ref_ptr&lt;GeoLocator&gt; img_locator = key.getProfile()-&gt;getSRS()-&gt;createLocator( 
<a name="l00713"></a>00713                 img_xmin, img_ymin, img_xmax, img_ymax,
<a name="l00714"></a>00714                 isPlateCarre );
<a name="l00715"></a>00715 
<a name="l00716"></a>00716             <span class="keywordflow">if</span> ( mapInfo.isGeocentric() )
<a name="l00717"></a>00717                 img_locator-&gt;setCoordinateSystemType( osgTerrain::Locator::GEOCENTRIC );
<a name="l00718"></a>00718 
<a name="l00719"></a>00719             tile-&gt;setCustomColorLayer( CustomColorLayer(
<a name="l00720"></a>00720                 mapf.getImageLayerAt(i),
<a name="l00721"></a>00721                 geo_image.getImage(),
<a name="l00722"></a>00722                 img_locator.get(),
<a name="l00723"></a>00723                 key.getLevelOfDetail(),
<a name="l00724"></a>00724                 key) );
<a name="l00725"></a>00725 
<a name="l00726"></a>00726             <span class="keywordtype">double</span> upp = geo_image.getUnitsPerPixel();
<a name="l00727"></a>00727 
<a name="l00728"></a>00728             <span class="comment">// Scale the units per pixel to degrees if the image is mercator (and the key is geo)</span>
<a name="l00729"></a>00729             <span class="keywordflow">if</span> ( geo_image.getSRS()-&gt;isMercator() &amp;&amp; key.getExtent().getSRS()-&gt;isGeographic() )
<a name="l00730"></a>00730                 upp *= 1.0f/111319.0f;
<a name="l00731"></a>00731 
<a name="l00732"></a>00732             min_units_per_pixel = osg::minimum(upp, min_units_per_pixel);
<a name="l00733"></a>00733         }
<a name="l00734"></a>00734     }
<a name="l00735"></a>00735 
<a name="l00736"></a>00736     osg::BoundingSphere bs = tile-&gt;getBound();
<a name="l00737"></a>00737     <span class="keywordtype">double</span> max_range = 1e10;
<a name="l00738"></a>00738     <span class="keywordtype">double</span> radius = bs.radius();
<a name="l00739"></a>00739 
<a name="l00740"></a>00740 <span class="preprocessor">#if 1</span>
<a name="l00741"></a>00741 <span class="preprocessor"></span>    <span class="keywordtype">double</span> min_range = radius * _terrainOptions.minTileRangeFactor().get();
<a name="l00742"></a>00742     <span class="comment">//osg::LOD::RangeMode mode = osg::LOD::DISTANCE_FROM_EYE_POINT;</span>
<a name="l00743"></a>00743 <span class="preprocessor">#else</span>
<a name="l00744"></a>00744 <span class="preprocessor"></span>    <span class="keywordtype">double</span> width = key.getExtent().width();     
<a name="l00745"></a>00745     <span class="keywordflow">if</span> (min_units_per_pixel == DBL_MAX) min_units_per_pixel = width/256.0;
<a name="l00746"></a>00746     <span class="keywordtype">double</span> min_range = (width / min_units_per_pixel) * _terrainOptions.getMinTileRangeFactor(); 
<a name="l00747"></a>00747     <span class="comment">//osg::LOD::RangeMode mode = osg::LOD::PIXEL_SIZE_ON_SCREEN;</span>
<a name="l00748"></a>00748 <span class="preprocessor">#endif</span>
<a name="l00749"></a>00749 <span class="preprocessor"></span>
<a name="l00750"></a>00750 
<a name="l00751"></a>00751     <span class="comment">// a skirt hides cracks when transitioning between LODs:</span>
<a name="l00752"></a>00752     hf-&gt;setSkirtHeight(radius * _terrainOptions.heightFieldSkirtRatio().get() );
<a name="l00753"></a>00753 
<a name="l00754"></a>00754     <span class="comment">// for now, cluster culling does not work for CUBE rendering</span>
<a name="l00755"></a>00755     <span class="comment">//bool isCube = mapInfo.isCube(); //map-&gt;getMapOptions().coordSysType() == MapOptions::CSTYPE_GEOCENTRIC_CUBE;</span>
<a name="l00756"></a>00756     <span class="keywordflow">if</span> ( mapInfo.isGeocentric() &amp;&amp; !mapInfo.isCube() )
<a name="l00757"></a>00757     {
<a name="l00758"></a>00758         <span class="comment">//TODO:  Work on cluster culling computation for cube faces</span>
<a name="l00759"></a>00759         osg::ClusterCullingCallback* ccc = createClusterCullingCallback(tile, locator-&gt;getEllipsoidModel() );
<a name="l00760"></a>00760         tile-&gt;setCullCallback( ccc );
<a name="l00761"></a>00761     }
<a name="l00762"></a>00762 
<a name="l00763"></a>00763     <span class="comment">// Wait until now, when the tile is fully baked, to assign the terrain to the tile.</span>
<a name="l00764"></a>00764     <span class="comment">// Placeholder tiles might try to locate this tile as an ancestor, and access its layers</span>
<a name="l00765"></a>00765     <span class="comment">// and locators...so they must be intact before making this tile available via setTerrain.</span>
<a name="l00766"></a>00766     <span class="comment">//</span>
<a name="l00767"></a>00767     <span class="comment">// If there&#39;s already a placeholder tile registered, this will be ignored. If there isn&#39;t,</span>
<a name="l00768"></a>00768     <span class="comment">// this will register the new tile.</span>
<a name="l00769"></a>00769     tile-&gt;attachToTerrain( terrain );
<a name="l00770"></a>00770     <span class="comment">//tile-&gt;setTerrain( terrain );</span>
<a name="l00771"></a>00771     <span class="comment">//terrain-&gt;registerTile( tile );</span>
<a name="l00772"></a>00772 
<a name="l00773"></a>00773     <span class="keywordflow">if</span> ( isStreaming &amp;&amp; key.getLevelOfDetail() &gt; 0 )
<a name="l00774"></a>00774     {
<a name="l00775"></a>00775         <span class="keyword">static_cast&lt;</span>StreamingTile*<span class="keyword">&gt;</span>(tile)-&gt;setHasElevationHint( hasElevation );
<a name="l00776"></a>00776     }
<a name="l00777"></a>00777 
<a name="l00778"></a>00778     osg::Node* result = 0L;
<a name="l00779"></a>00779 
<a name="l00780"></a>00780     <span class="keywordflow">if</span> (wrapInPagedLOD)
<a name="l00781"></a>00781     {
<a name="l00782"></a>00782         <span class="comment">// create a PLOD so we can keep subdividing:</span>
<a name="l00783"></a>00783         osg::PagedLOD* plod = <span class="keyword">new</span> osg::PagedLOD();
<a name="l00784"></a>00784         plod-&gt;setCenter( bs.center() );
<a name="l00785"></a>00785         plod-&gt;addChild( tile, min_range, max_range );
<a name="l00786"></a>00786 
<a name="l00787"></a>00787         std::string filename = createURI( _engineId, key ); <span class="comment">//map-&gt;getId(), key );</span>
<a name="l00788"></a>00788 
<a name="l00789"></a>00789         <span class="comment">//Only add the next tile if it hasn&#39;t been blacklisted</span>
<a name="l00790"></a>00790         <span class="keywordtype">bool</span> isBlacklisted = osgEarth::Registry::instance()-&gt;isBlacklisted( filename );
<a name="l00791"></a>00791         <span class="keywordflow">if</span> (!isBlacklisted &amp;&amp; key.getLevelOfDetail() &lt; (<span class="keywordtype">unsigned</span> int)getTerrainOptions().maxLOD().value() &amp;&amp; validData )
<a name="l00792"></a>00792         {
<a name="l00793"></a>00793             plod-&gt;setFileName( 1, filename  );
<a name="l00794"></a>00794             plod-&gt;setRange( 1, 0.0, min_range );
<a name="l00795"></a>00795         }
<a name="l00796"></a>00796         <span class="keywordflow">else</span>
<a name="l00797"></a>00797         {
<a name="l00798"></a>00798             plod-&gt;setRange( 0, 0, FLT_MAX );
<a name="l00799"></a>00799         }
<a name="l00800"></a>00800 
<a name="l00801"></a>00801 <span class="preprocessor">#if USE_FILELOCATIONCALLBACK</span>
<a name="l00802"></a>00802 <span class="preprocessor"></span>        osgDB::Options* options = <span class="keyword">new</span> osgDB::Options;
<a name="l00803"></a>00803         options-&gt;setFileLocationCallback( <span class="keyword">new</span> FileLocationCallback() );
<a name="l00804"></a>00804         plod-&gt;setDatabaseOptions( options );
<a name="l00805"></a>00805 <span class="preprocessor">#endif</span>
<a name="l00806"></a>00806 <span class="preprocessor"></span>        result = plod;
<a name="l00807"></a>00807 
<a name="l00808"></a>00808         <span class="keywordflow">if</span> ( isStreaming )
<a name="l00809"></a>00809             result-&gt;addCullCallback( <span class="keyword">new</span> PopulateStreamingTileDataCallback( _cull_thread_mapf ) );
<a name="l00810"></a>00810     }
<a name="l00811"></a>00811     <span class="keywordflow">else</span>
<a name="l00812"></a>00812     {
<a name="l00813"></a>00813         result = tile;
<a name="l00814"></a>00814     }
<a name="l00815"></a>00815 
<a name="l00816"></a>00816     <span class="keywordflow">return</span> result;
<a name="l00817"></a>00817 }
<a name="l00818"></a>00818 
<a name="l00819"></a>00819 CustomColorLayerRef*
<a name="l00820"></a>00820 OSGTileFactory::createImageLayer(<span class="keyword">const</span> MapInfo&amp;    mapInfo,
<a name="l00821"></a>00821                                  ImageLayer*       layer,
<a name="l00822"></a>00822                                  <span class="keyword">const</span> TileKey&amp;    key,
<a name="l00823"></a>00823                                  ProgressCallback* progress)
<a name="l00824"></a>00824 {
<a name="l00825"></a>00825     <span class="keywordflow">if</span> ( !layer )
<a name="l00826"></a>00826         <span class="keywordflow">return</span> 0L;
<a name="l00827"></a>00827 
<a name="l00828"></a>00828     GeoImage geoImage;
<a name="l00829"></a>00829 
<a name="l00830"></a>00830     <span class="comment">//If the key is valid, try to get the image from the MapLayer</span>
<a name="l00831"></a>00831     <span class="keywordtype">bool</span> keyValid = layer-&gt;isKeyValid( key );
<a name="l00832"></a>00832     <span class="keywordflow">if</span> ( keyValid )
<a name="l00833"></a>00833     {
<a name="l00834"></a>00834         geoImage = layer-&gt;createImage(key, progress);
<a name="l00835"></a>00835     }
<a name="l00836"></a>00836     <span class="keywordflow">else</span>
<a name="l00837"></a>00837     {
<a name="l00838"></a>00838         <span class="comment">//If the key is not valid, simply make a transparent tile</span>
<a name="l00839"></a>00839         geoImage = GeoImage(ImageUtils::createEmptyImage(), key.getExtent());
<a name="l00840"></a>00840     }
<a name="l00841"></a>00841 
<a name="l00842"></a>00842     <span class="keywordflow">if</span> (geoImage.valid())
<a name="l00843"></a>00843     {
<a name="l00844"></a>00844         osg::ref_ptr&lt;GeoLocator&gt; imgLocator = GeoLocator::createForKey( key, mapInfo );
<a name="l00845"></a>00845 
<a name="l00846"></a>00846         <span class="keywordflow">if</span> ( mapInfo.isGeocentric() )
<a name="l00847"></a>00847             imgLocator-&gt;setCoordinateSystemType( osgTerrain::Locator::GEOCENTRIC );
<a name="l00848"></a>00848 
<a name="l00849"></a>00849         <span class="keywordflow">return</span> <span class="keyword">new</span> CustomColorLayerRef( CustomColorLayer(
<a name="l00850"></a>00850             layer,
<a name="l00851"></a>00851             geoImage.getImage(),
<a name="l00852"></a>00852             imgLocator.get(),
<a name="l00853"></a>00853             key.getLevelOfDetail(),
<a name="l00854"></a>00854             key) );
<a name="l00855"></a>00855     }
<a name="l00856"></a>00856 
<a name="l00857"></a>00857     <span class="keywordflow">return</span> NULL;
<a name="l00858"></a>00858 }
<a name="l00859"></a>00859 
<a name="l00860"></a>00860 osgTerrain::HeightFieldLayer* 
<a name="l00861"></a>00861 OSGTileFactory::createHeightFieldLayer( <span class="keyword">const</span> MapFrame&amp; mapf, <span class="keyword">const</span> TileKey&amp; key, <span class="keywordtype">bool</span> exactOnly )
<a name="l00862"></a>00862 {
<a name="l00863"></a>00863     <span class="keyword">const</span> MapInfo&amp; mapInfo = mapf.getMapInfo();
<a name="l00864"></a>00864     <span class="keywordtype">bool</span> isPlateCarre = !mapInfo.isGeocentric() &amp;&amp; mapInfo.isGeographicSRS();
<a name="l00865"></a>00865 
<a name="l00866"></a>00866     <span class="comment">// try to create a heightfield at native res:</span>
<a name="l00867"></a>00867     osg::ref_ptr&lt;osg::HeightField&gt; hf;
<a name="l00868"></a>00868     <span class="keywordflow">if</span> ( !mapf.getHeightField( key, !exactOnly, hf, 0L, _terrainOptions.elevationInterpolation().value() ) )
<a name="l00869"></a>00869     {
<a name="l00870"></a>00870         <span class="keywordflow">if</span> ( exactOnly )
<a name="l00871"></a>00871             <span class="keywordflow">return</span> NULL;
<a name="l00872"></a>00872         <span class="keywordflow">else</span>
<a name="l00873"></a>00873             hf = createEmptyHeightField( key );
<a name="l00874"></a>00874     }
<a name="l00875"></a>00875 
<a name="l00876"></a>00876     <span class="comment">// In a Plate Carre tesselation, scale the heightfield elevations from meters to degrees</span>
<a name="l00877"></a>00877     <span class="keywordflow">if</span> ( isPlateCarre )
<a name="l00878"></a>00878     {
<a name="l00879"></a>00879         HeightFieldUtils::scaleHeightFieldToDegrees( hf.get() );
<a name="l00880"></a>00880     }
<a name="l00881"></a>00881 
<a name="l00882"></a>00882     osgTerrain::HeightFieldLayer* hfLayer = <span class="keyword">new</span> osgTerrain::HeightFieldLayer( hf.get() );
<a name="l00883"></a>00883 
<a name="l00884"></a>00884     GeoLocator* locator = GeoLocator::createForKey( key, mapInfo );
<a name="l00885"></a>00885     hfLayer-&gt;setLocator( locator );
<a name="l00886"></a>00886 
<a name="l00887"></a>00887     <span class="keywordflow">return</span> hfLayer;
<a name="l00888"></a>00888 }
<a name="l00889"></a>00889 
<a name="l00890"></a>00890 osg::ClusterCullingCallback*
<a name="l00891"></a>00891 OSGTileFactory::createClusterCullingCallback(Tile* tile, osg::EllipsoidModel* et)
<a name="l00892"></a>00892 {
<a name="l00893"></a>00893     <span class="comment">//This code is a very slightly modified version of the DestinationTile::createClusterCullingCallback in VirtualPlanetBuilder.</span>
<a name="l00894"></a>00894     osg::HeightField* grid = ((osgTerrain::HeightFieldLayer*)tile-&gt;getElevationLayer())-&gt;getHeightField();
<a name="l00895"></a>00895     <span class="keywordflow">if</span> (!grid) <span class="keywordflow">return</span> 0;
<a name="l00896"></a>00896 
<a name="l00897"></a>00897     <span class="keywordtype">float</span> verticalScale = 1.0f;
<a name="l00898"></a>00898     Tile* customTile = <span class="keyword">dynamic_cast&lt;</span>Tile*<span class="keyword">&gt;</span>(tile);
<a name="l00899"></a>00899     <span class="keywordflow">if</span> (customTile)
<a name="l00900"></a>00900     {
<a name="l00901"></a>00901         verticalScale = customTile-&gt;getVerticalScale();
<a name="l00902"></a>00902     }
<a name="l00903"></a>00903 
<a name="l00904"></a>00904     <span class="keywordtype">double</span> globe_radius = et ? et-&gt;getRadiusPolar() : 1.0;
<a name="l00905"></a>00905     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numColumns = grid-&gt;getNumColumns();
<a name="l00906"></a>00906     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numRows = grid-&gt;getNumRows();
<a name="l00907"></a>00907 
<a name="l00908"></a>00908     <span class="keywordtype">double</span> midLong = grid-&gt;getOrigin().x()+grid-&gt;getXInterval()*((double)(numColumns-1))*0.5;
<a name="l00909"></a>00909     <span class="keywordtype">double</span> midLat = grid-&gt;getOrigin().y()+grid-&gt;getYInterval()*((double)(numRows-1))*0.5;
<a name="l00910"></a>00910     <span class="keywordtype">double</span> midZ = grid-&gt;getOrigin().z();
<a name="l00911"></a>00911 
<a name="l00912"></a>00912     <span class="keywordtype">double</span> midX,midY;
<a name="l00913"></a>00913     et-&gt;convertLatLongHeightToXYZ(osg::DegreesToRadians(midLat),osg::DegreesToRadians(midLong),midZ, midX,midY,midZ);
<a name="l00914"></a>00914 
<a name="l00915"></a>00915     osg::Vec3 center_position(midX,midY,midZ);
<a name="l00916"></a>00916 
<a name="l00917"></a>00917     osg::Vec3 center_normal(midX,midY,midZ);
<a name="l00918"></a>00918     center_normal.normalize();
<a name="l00919"></a>00919 
<a name="l00920"></a>00920     osg::Vec3 transformed_center_normal = center_normal;
<a name="l00921"></a>00921 
<a name="l00922"></a>00922     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r,c;
<a name="l00923"></a>00923 
<a name="l00924"></a>00924     <span class="comment">// populate the vertex/normal/texcoord arrays from the grid.</span>
<a name="l00925"></a>00925     <span class="keywordtype">double</span> orig_X = grid-&gt;getOrigin().x();
<a name="l00926"></a>00926     <span class="keywordtype">double</span> delta_X = grid-&gt;getXInterval();
<a name="l00927"></a>00927     <span class="keywordtype">double</span> orig_Y = grid-&gt;getOrigin().y();
<a name="l00928"></a>00928     <span class="keywordtype">double</span> delta_Y = grid-&gt;getYInterval();
<a name="l00929"></a>00929     <span class="keywordtype">double</span> orig_Z = grid-&gt;getOrigin().z();
<a name="l00930"></a>00930 
<a name="l00931"></a>00931 
<a name="l00932"></a>00932     <span class="keywordtype">float</span> min_dot_product = 1.0f;
<a name="l00933"></a>00933     <span class="keywordtype">float</span> max_cluster_culling_height = 0.0f;
<a name="l00934"></a>00934     <span class="keywordtype">float</span> max_cluster_culling_radius = 0.0f;
<a name="l00935"></a>00935 
<a name="l00936"></a>00936     <span class="keywordflow">for</span>(r=0;r&lt;numRows;++r)
<a name="l00937"></a>00937     {
<a name="l00938"></a>00938         <span class="keywordflow">for</span>(c=0;c&lt;numColumns;++c)
<a name="l00939"></a>00939         {
<a name="l00940"></a>00940             <span class="keywordtype">double</span> X = orig_X + delta_X*(double)c;
<a name="l00941"></a>00941             <span class="keywordtype">double</span> Y = orig_Y + delta_Y*(double)r;
<a name="l00942"></a>00942             <span class="keywordtype">double</span> Z = orig_Z + grid-&gt;getHeight(c,r) * verticalScale;
<a name="l00943"></a>00943             <span class="keywordtype">double</span> height = Z;
<a name="l00944"></a>00944 
<a name="l00945"></a>00945             et-&gt;convertLatLongHeightToXYZ(
<a name="l00946"></a>00946                 osg::DegreesToRadians(Y), osg::DegreesToRadians(X), Z,
<a name="l00947"></a>00947                 X, Y, Z);
<a name="l00948"></a>00948 
<a name="l00949"></a>00949             osg::Vec3d v(X,Y,Z);
<a name="l00950"></a>00950             osg::Vec3 dv = v - center_position;
<a name="l00951"></a>00951             <span class="keywordtype">double</span> d = sqrt(dv.x()*dv.x() + dv.y()*dv.y() + dv.z()*dv.z());
<a name="l00952"></a>00952             <span class="keywordtype">double</span> theta = acos( globe_radius/ (globe_radius + fabs(height)) );
<a name="l00953"></a>00953             <span class="keywordtype">double</span> phi = 2.0 * asin (d*0.5/globe_radius); <span class="comment">// d/globe_radius;</span>
<a name="l00954"></a>00954             <span class="keywordtype">double</span> beta = theta+phi;
<a name="l00955"></a>00955             <span class="keywordtype">double</span> cutoff = osg::PI_2 - 0.1;
<a name="l00956"></a>00956 
<a name="l00957"></a>00957             <span class="comment">//log(osg::INFO,&quot;theta=&quot;&lt;&lt;theta&lt;&lt;&quot;\tphi=&quot;&lt;&lt;phi&lt;&lt;&quot; beta &quot;&lt;&lt;beta);</span>
<a name="l00958"></a>00958             <span class="keywordflow">if</span> (phi&lt;cutoff &amp;&amp; beta&lt;cutoff)
<a name="l00959"></a>00959             {
<a name="l00960"></a>00960                 <span class="keywordtype">float</span> local_dot_product = -sin(theta + phi);
<a name="l00961"></a>00961                 <span class="keywordtype">float</span> local_m = globe_radius*( 1.0/ cos(theta+phi) - 1.0);
<a name="l00962"></a>00962                 <span class="keywordtype">float</span> local_radius = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(globe_radius * tan(beta)); <span class="comment">// beta*globe_radius;</span>
<a name="l00963"></a>00963                 min_dot_product = osg::minimum(min_dot_product, local_dot_product);
<a name="l00964"></a>00964                 max_cluster_culling_height = osg::maximum(max_cluster_culling_height,local_m);      
<a name="l00965"></a>00965                 max_cluster_culling_radius = osg::maximum(max_cluster_culling_radius,local_radius);
<a name="l00966"></a>00966             }
<a name="l00967"></a>00967             <span class="keywordflow">else</span>
<a name="l00968"></a>00968             {
<a name="l00969"></a>00969                 <span class="comment">//log(osg::INFO,&quot;Turning off cluster culling for wrap around tile.&quot;);</span>
<a name="l00970"></a>00970                 <span class="keywordflow">return</span> 0;
<a name="l00971"></a>00971             }
<a name="l00972"></a>00972         }
<a name="l00973"></a>00973     }    
<a name="l00974"></a>00974 
<a name="l00975"></a>00975     osg::ClusterCullingCallback* ccc = <span class="keyword">new</span> osg::ClusterCullingCallback;
<a name="l00976"></a>00976 
<a name="l00977"></a>00977     ccc-&gt;set(center_position + transformed_center_normal*max_cluster_culling_height ,
<a name="l00978"></a>00978         transformed_center_normal, 
<a name="l00979"></a>00979         min_dot_product,
<a name="l00980"></a>00980         max_cluster_culling_radius);
<a name="l00981"></a>00981 
<a name="l00982"></a>00982     <span class="keywordflow">return</span> ccc;
<a name="l00983"></a>00983 }
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="_o_s_g_tile_factory_8cpp.html">OSGTileFactory.cpp</a>      </li>
      <li class="footer">Generated on Tue Jan 17 2012 18:35:18 for osgEarth by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
